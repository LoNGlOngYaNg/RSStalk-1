<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Blog · Tanky Woo</title>
		<description>Tanky Woo&#39;s Blog, focus on Python, Linux, Gentoo, Mac OS, Vim, Open Source and so on.</description>		
		<link>http://blog.tankywoo.com</link>
		<atom:link href="http://blog.tankywoo.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>乌镇游</title>
				<description>&lt;p&gt;时间: 2016/04/22 - 2016/04/24&lt;/p&gt;

&lt;p&gt;赶在五一假期之前，和海鹏、超堂、磊磊、杰宝一起去乌镇和西湖玩了一趟。&lt;/p&gt;

&lt;p&gt;其实这趟出游计划在去年就已经有了，那时我们五个人只是约好今年一起出去玩一趟，但是还没定定点。今年年初本来定的黄山，不过因为这个季节山上还是有点冷，且是梅雨季节，所以临时改为乌镇了。&lt;/p&gt;

&lt;p&gt;整趟出游的时间还是比较紧凑的，没什么富余的时间。&lt;/p&gt;

&lt;p&gt;22号周五请了一天假，21号晚上就和海鹏、超堂去北京站坐直达卧铺，睡一觉直接到杭州。话说我和海鹏差点没赶上火车，超堂一个人在车站干着急……&lt;/p&gt;

&lt;p&gt;22号到了杭州后，直接转地铁和大巴，坐到乌镇，已是下午1、2点，和磊磊、杰宝碰头。然后去简单的吃了顿饭，下午买票直接去了东栅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;有句话是「游玩东栅游西栅」，东栅偏向于历史文化景点。而西栅则是原生的水乡风情。&lt;/p&gt;

&lt;p&gt;当然，东栅的水上景色也不错（人很多，对面都是的……）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;茅盾纪念馆：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;酒窖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;初来一天，杭州给我的感觉就是有几个特色：白鲢鱼（中午吃了……），粽子（以及荷叶做的各种延伸的菜），青团，再就是酒（包括米酒，北方叫醪糟）。&lt;/p&gt;

&lt;p&gt;下午逛完东栅后，人已经累的懵逼了，毕竟头一晚在火车上也没休息好，第二天又坐了地铁和大巴加起来三个小时的车才来到乌镇，没休息就接着玩了一下午……&lt;/p&gt;

&lt;p&gt;但是，更懵逼的来了，因为订的青年旅馆在西栅里，所以又回到西栅，进去后搞了一份地图，发现订的旅馆在西栅最里面，走了半个多小时才走到。&lt;/p&gt;

&lt;p&gt;关于青年旅馆，我是第一次住，环境比预期的好多了，应该说是好相当多，当然这也归功于整个乌镇，作为互联网大会的地方，这里的公共设施是我见过最好的，厕所干净没异味，相当难得（原谅我去关注厕所了，因为确实非常干净……），更主要的是，全区覆盖的无线网，可以达到2Mb/s且非常稳定，我简直乐坏了……&lt;/p&gt;

&lt;p&gt;回到青旅休息了半天，才一起出来吃饭，话说南方这几天都在下雨，乌镇这边白天天气还是很热，晚上出来时已经开始下点小雨了，配上江南水乡，非常惬意。&lt;/p&gt;

&lt;p&gt;夜晚的西栅，灯火通明，人不比白天少：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;找了个地方，开始我最开心的事情了，喝酒和唠嗑（吹牛逼）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;第二天，就开始玩西栅了，这天雨比较大，不过都是一阵一阵的。当然，玩的人并不比昨天少，因为是周六。&lt;/p&gt;

&lt;p&gt;西栅更符合我的口味，东栅的文化景点太文艺，他们几个家伙都是这类人，我还是喜欢一些自然风景：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-7.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;白莲塔寺（不过貌似和那啥没关系）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;京杭大运河：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-10.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;下午坐大巴返回杭州。&lt;/p&gt;

&lt;p&gt;25号是在杭州玩的，先去看了下岳王庙：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后走了一遍苏堤，大概4、5公里，因为时间比较赶，没怎么停留：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-12.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;下午就赶着去火车站坐高铁回京了，晚上快11点才到家。&lt;/p&gt;

&lt;p&gt;最后来一张合影，在修真观前面拍的，几个大老爷儿们都不太爱上镜，所以在东栅逛完后，最后到了这里才想起来合影一张。&lt;/p&gt;

&lt;p&gt;乌镇有一观二塔之称，一观就是指这修真观，二塔之一就是上面的白莲塔寺。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://tankywoo-wb.b0.upaiyun.com/wuzhen/wuzhen-0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;难得几个兄弟从全国三个地方一起聚起来玩一趟，真的不容易，明年再约起。&lt;/p&gt;
</description>
				<pubDate>Mon, 25 Apr 2016 22:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/04/25/wuzhen-travel.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/04/25/wuzhen-travel.html</guid>
			</item>
		
			<item>
				<title>PHP-FPM的chroot</title>
				<description>&lt;p&gt;之前的&lt;a href=&quot;/2016/03/06/nginx-php-fpm-configuration-security.html&quot;&gt;Nginx 和 PHP-FPM 权限安全配置&lt;/a&gt;提到过&lt;code&gt;chroot&lt;/code&gt;的配置。&lt;/p&gt;

&lt;p&gt;不过在一个实际(稍复杂的)环境下，还有很多的依赖文件和lib库需要处理。&lt;/p&gt;

&lt;p&gt;比如昨天排查一个程序发送邮件的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先smtp地址解析不了&lt;/li&gt;
&lt;li&gt;开启ssl失败&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中一个方法就是把如 &lt;code&gt;/dev&lt;/code&gt;、 &lt;code&gt;/etc&lt;/code&gt;、 &amp;#39;/lib&amp;#39; 等目录做 &lt;code&gt;mount --bind&lt;/code&gt; 到chroot的环境下。不过增加了维护的成本，比如一个机器上有多个站点要维护，那么就是N个目录乘以站点数，mount列表会很混乱。&lt;/p&gt;

&lt;p&gt;也可以定制一个基本的&lt;strong&gt;最小chroot环境&lt;/strong&gt;，供后续使用。&lt;/p&gt;

&lt;p&gt;这个问题&lt;a href=&quot;https://forum.nginx.org/read.php?3,212362,212372&quot;&gt;Problems with chroot php-fpm /nginx and resolving&lt;/a&gt;里有人已经给出了一个比较全面的文件列表。&lt;/p&gt;

&lt;p&gt;首先是DNS解析问题：&lt;/p&gt;

&lt;p&gt;除了要copy一些配置文件，另外就是lib库了。&lt;/p&gt;

&lt;p&gt;可以通过一些二进制命令来排查，如常用的&lt;code&gt;ping&lt;/code&gt;、 &lt;code&gt;host&lt;/code&gt;等等。将相应的命令和依赖的库copy到chroot环境。如我要使用ping来排查:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ ldd `which ping`
linux-vdso.so.1 (0x00007fff200fa000)
libc.so.6 =&amp;gt; /lib64/libc.so.6 (0x00007fafab504000)
/lib64/ld-linux-x86-64.so.2 (0x00007fafab8a6000)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意lib库的查找路径定义在 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt;，包含子配置目录&lt;code&gt;/etc/ld.so.conf.d/*&lt;/code&gt;，这些也要copy过去，否则一些如&lt;code&gt;/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.3/&lt;/code&gt;下的库默认找不到。(参考&lt;a href=&quot;https://forums.gentoo.org/viewtopic-p-7310128.html&quot;&gt;update to gcc-4.7.3 killed libgcc_s.so.1&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;测试chroot下ping:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ chroot /path/to/ /bin/ping -c1 example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ chroot /path/to /bin/bb     # /bin/bb 即 /bin/busybox
$ /bin/ping -c example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里推荐使用&lt;code&gt;busybox&lt;/code&gt; 而不是 &lt;code&gt;/bin/bash&lt;/code&gt;, 是因为前者不需要额外lib库依赖。&lt;/p&gt;

&lt;p&gt;调式的过程中记得要重启php-fpm进程，否则解析不生效。&lt;/p&gt;

&lt;p&gt;另外一个是ssl的问题，smtp开启ssl走465端口，看日志是fsockopen()无法开启加密，而ssl, crypto相关的lib库都copy过去了，最后发现是 &lt;code&gt;/etc/openssl/*&lt;/code&gt; 下的内容没有copy。还有一个要注意里面的一些证书是软链接，需要&lt;code&gt;cp -L&lt;/code&gt;来将软链接拷贝为实际文件。&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://forum.nginx.org/read.php?3,212362,212372&quot;&gt;Problems with chroot php-fpm /nginx and resolving&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003044622&quot;&gt;建立PHP-FPM的Chroot执行环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sagar.se/an-absolutely-minimal-chroot.html&quot;&gt;An absolutely minimal chroot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ae.koroglu.org/chrooted-php-fpm-with-nginx-on-centos-6/&quot;&gt;Chrooted PHP-FPM with Nginx on CentOS 6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/25336617/1276501&quot;&gt;PHP5 - Fails to resolve hostnames when not in interactive mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://forum.nginx.org/read.php?3,228808&quot;&gt;php-fpm + FreeBSD 8.2 and SSL issue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Fri, 15 Apr 2016 12:50:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/04/15/php-fpm-with-chroot.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/04/15/php-fpm-with-chroot.html</guid>
			</item>
		
			<item>
				<title>网站迁回国内&amp;备案</title>
				<description>&lt;p&gt;昨天终于收到短信提醒，几个网站备案都通过了。&lt;/p&gt;

&lt;p&gt;之前博客是放在Linode的Fremont机房，应该有快3年了。当初选择Linode最主要的原因一是它支持Gentoo (kvm除外)；另外一个就是它的服务很好。&lt;/p&gt;

&lt;p&gt;那时Fremont的速度还可以接受，SSH连上去，还能改改配置啥的。但是现在，这堵墙越来越高，在上面改下配置啥的，本来2、3分钟的事情，结果敲几秒钟，断几分钟甚至几十分钟。实在受不了这样的节奏，所以才选择迁回国内，也就是现在用的阿里云ECS，比较给力的是现在阿里云也有Gentoo系统。&lt;/p&gt;

&lt;p&gt;本来是准备选择阿里云的香港机房，不过价格比国内的高了一倍，而且找了几个ip看了下，发现到国内的线路也不理想。所以只能不情愿的选择了国内的机房并备案。&lt;/p&gt;

&lt;p&gt;09、10年刚开始玩网站时，买的是国内的虚拟主机，花了一些钱买的代备，挂在别人公司名下；不过第二年备案就管的很严了，然后我的备案也被取消了。。。&lt;/p&gt;

&lt;p&gt;当时我就搬到香港的服务器上去，并在心里说，妈的以后绝对不迁移国内，直到一个月前，我还一直保持着这个想法。可是，我还是败在了这堵高墙下，只能认怂。&lt;/p&gt;

&lt;p&gt;备案选择的是北京这边，有点坑的时不支持其它国别域名，导致我有一个 .us 的域名还得继续丢在Linode上。。。&lt;/p&gt;

&lt;p&gt;因为阿里云提供了代备案系统，所以整体还是比较方便的，大致流程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按照后台提示到代备案系统注册&lt;/li&gt;
&lt;li&gt;填写相关的个人信息，身份证拍照，打印表格签字拍照等。阿里代备案初审&lt;/li&gt;
&lt;li&gt;初审通过后交15元申请邮寄幕布，其实就是一张海报&lt;/li&gt;
&lt;li&gt;收到幕布后拍照，阿里代备案核验&lt;/li&gt;
&lt;li&gt;核验通过后提交给管局，然后就是漫长的等待&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我03.21提交的初审，第二天阿里代备客服打电话过来，说我的几个网站名称全部不符合，我全部写了xxx个人主页，要求是严禁出现「个人主页」等字样。不过他们的服务还是很不错的，给出了一些建议，比如名称选择一首歌的歌词等。我随便改了个名字，重新提交了下，当天就通过初审。接着申请幕布，拍照上传，通过个人核验。&lt;/p&gt;

&lt;p&gt;03.24号提交给管局审核，提示审核时间大概17天，最长20天。到了04.05号，提示又变为审核时间大概20天了。。。不过在昨天，也就是04.08号，历经18天，终于审核通过了，收到了备案的短信、邮件提醒，以及阿里云的邮件提醒，并赠送了ECS的18天时长，这点还是很给力的。&lt;/p&gt;

&lt;p&gt;昨晚先把Gentoo的一些依赖都处理了，然后更新了world，早上就把几个静态站点都迁移过来了。&lt;/p&gt;

&lt;p&gt;访问速度还是相当快的，本地ping的时间在20ms内。SSH连上去，没有任何延时，感觉和本地操作一样。&lt;/p&gt;

&lt;p&gt;关于备案，之前以为备案期间不能开站，所以我作了一些小处理，为了不影响爬虫和部分用户(通过统计看大概是一半的Windows用户，一半的Mac用户)，所以我把User-Agent带Windows的访问全部rewrite到一个提示正在备案中的空白页面上:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;location = / {
    if ($http_user_agent ~* (Windows) ) {
        rewrite / /index2.html break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过后来询问过客服，对方说北京这边没有要求备案需要关站。。。&lt;/p&gt;

&lt;p&gt;现在来看，其实个人备案也不是太麻烦，主要就是得等，看别人说大概都是一周左右，我这审核的时间确实有点长了。&lt;/p&gt;

&lt;p&gt;回来的感觉还是很不错的~~&lt;/p&gt;
</description>
				<pubDate>Sat, 09 Apr 2016 12:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/04/09/move-website-and-beian.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/04/09/move-website-and-beian.html</guid>
			</item>
		
			<item>
				<title>「简约之美：软件设计之道」摘录</title>
				<description>&lt;blockquote&gt;
&lt;p&gt;昨晚打开Kindle，准备看下这本书。然后发现已经读过了，但是却一点印象都没。发现现在健忘越来越严重了，经常一个小时前的事情都记不住了。&lt;/p&gt;

&lt;p&gt;通过笔记时间想起来原来是在年后回京的高铁上读完的。于是靠笔记再回顾了一遍。&lt;/p&gt;

&lt;p&gt;以后对读过的书，应当及时整理摘录，放到博客上留存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这本书篇幅非常小，估摸3小时可以就读完。都是软件工程方面的经验之谈，值得读一读。&lt;/p&gt;

&lt;p&gt;下面是从Kindle上导出的标注：&lt;/p&gt;

&lt;p&gt;简约之美：软件设计之道, Max Kanat-Alexander&lt;/p&gt;

&lt;p&gt;《简约之美》其实只强调了几条互相联系的简单道理：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;软件是必然要变化的，变化是常态；&lt;/li&gt;
&lt;li&gt;有变化就需要维护，随着时间的推移，维护成本会远远超过初期开发的成本，占据成本的大头；&lt;/li&gt;
&lt;li&gt;因此，在软件开发中，最重要的是要降低维护成本；&lt;/li&gt;
&lt;li&gt;维护成本正比于系统的复杂程度，所以要降低维护成本，系统的设计就应当追求简单清晰。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这根逻辑链条看似简单，其实并非如此。不少有经验的开发人员，似乎对这类“道理”不屑一顾。&lt;/p&gt;

&lt;p&gt;软件系统中任何与架构有关的技术决策，以及在开发系统中所做的技术决策，都可以归到“软件设计”的范畴里。&lt;/p&gt;

&lt;p&gt;设计程序员能尽可能容易开发和维护的软件系统，这样的系统才能为用户提供尽可能多的帮助，而且能持续提供尽可能多的帮助。&lt;/p&gt;

&lt;p&gt;软件设计的本质中的所有问题，都可以用下面的方程式来解答：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; D = V/E
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;D 表示这个变化的合意程度（可取程度）。我们对此项工作的需求有多么迫切？&lt;/li&gt;
&lt;li&gt;V 表示它的价值。该变化价值几何？一般来说，你可以问自己“这个变化对用户有多少用”；当然，还有很多其他方法来判断其价值。&lt;/li&gt;
&lt;li&gt;E 表示完成这个变化的成本，也就是完成它需要付出的代价。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，这个等式的意思是：任何一点改变，其合意程度与其价值成正比，与所付出的成本成反比。&lt;/p&gt;

&lt;p&gt;这并不是在判断某个变化绝对对错，而是指导你如何分辨并排序你的选项。能带来较大价值、花费成本较少的变化，要比带来较少价值、花费较多成本的变化“更好”。&lt;/p&gt;

&lt;p&gt;价值由两部分组成：可能价值（这个变化有多大可能帮到用户）、潜在价值（这个变化在对用户提供帮助的时候，将为用户提供多大的帮助）。&lt;/p&gt;

&lt;p&gt;成本包含实现成本和维护成本，价值也包括当前价值和未来价值。用方程式来表示就是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;E = Ei + Em
V = Vn + Vf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ei 代表实现成本&lt;/li&gt;
&lt;li&gt;Em 代表维护成本&lt;/li&gt;
&lt;li&gt;Vn 代表当前价值&lt;/li&gt;
&lt;li&gt;Vf 代表未来价值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑所有因素，完整的方程式就是：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;D = ( Vn + Vf ) / ( Ei + Em )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用文字说明就是：改变的合意程度，正比于软件当前价值与未来价值之和，反比于实现成本和维护成本之和。 这就是软件设计的最重要规律。&lt;/p&gt;

&lt;p&gt;相比降低实现成本，降低维护成本更加重要。&lt;/p&gt;

&lt;p&gt;设计的质量好坏，正比于该系统在未来能持续帮助他人时间的长度。&lt;/p&gt;

&lt;p&gt;程序员犯的最常见也是最严重的错误，就是在其实不知道未来的时候去预测未来。&lt;/p&gt;

&lt;p&gt;如果完全不考虑未来，只根据当前已知的确切信息确定所有设计决策，那就百分百安全了。 这个说法听起来与本章之前说的相矛盾，其实并非如此。在进行决策时，未来才是最重要的事情。但在进行决策时，考虑未来的变数和尝试预测未来，是有区别的。&lt;/p&gt;

&lt;p&gt;在软件设计时，可以根据已知的信息做某些决策，目的是为了创造更好的未来（提升价值，降低维护成本），而不必预测未来究竟会发生什么具体的事情。&lt;/p&gt;

&lt;p&gt;「变化定律」（Law of Change）：程序存在的时间越久，它的某个部分需要变化的可能性就越高。&lt;/p&gt;

&lt;p&gt;关键在于，你并不需要去预测什么会变化，你需要知道的是，变化必然会发生。程序应该保证尽可能合理的灵活性，这样，不管未来发生什么变化，都可以应付得了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;另一点值得学习的有趣之处是，回顾某个特定文件修改历史。如果某个文件存在了很长时间，而且你有程序记录每个文件的修改历史，请回顾整个过程中的每次修改。问问自己，最初写这个文件时，你能预测到这些变化吗，是否一开始写好就能够减轻后期的工作量。总的来说，就是要尝试理解每次修改，看看是否能从中得到一些关于软件开发的新的收获。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了适应变化定律，软件设计师常常会掉进误区。其中有3个误区最常见，这里按照其发生频率逐一列出来：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;（1）编写不必要的代码&lt;/li&gt;
&lt;li&gt;（2）代码难以修改&lt;/li&gt;
&lt;li&gt;（3）过分追求通用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如今，软件设计中有一条常见的规则，叫做「你不会需要它」（You Ain&amp;#39;t Gonna Need It），或者简称为 &lt;code&gt;YAGNI&lt;/code&gt; 。其实这条规则的意思是，不应该在真正的需求来临之前编写那些代码。&lt;/p&gt;

&lt;p&gt;其实，这条规则应当这样展开：不要编写不是必需的代码，并且要删除没有用到的代码。 也就是说，你还需要删除所有用不到的代码；如果真的需要，你随时可以恢复回来。&lt;/p&gt;

&lt;p&gt;软件项目的一大杀手就是所谓的「僵化设计」（rigid design）。也就是说，程序员写出来的代码很难修改。僵化设计有两大原因： 对未来做太多假设 不仔细设计就编写代码&lt;/p&gt;

&lt;p&gt;更好的办法是每次只确定一个或者少数几个需求，然后立刻让开发人员实现它。在开发过程中，用户可以扮演开发人员的角色，反复进行沟通。上次确定的功能实现并发布之后，就可以继续处理其他的功能。这样，最终得到的系统是设计良好的，完全满足用户需求的。&lt;/p&gt;

&lt;p&gt;设计程序时，应当根据&lt;strong&gt;你现在确切知道的需求，而不是你认为未来会出现的需求。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这不是说不要做规划。在软件设计中，一定程度的规划是非常有价值的。但是，即便不做详细的规划，只要你能保持改变的幅度很小，代码也很容易适应不确定的未来，就没有大的风险。&lt;/p&gt;

&lt;p&gt;做一个足够通用的办法，保证（他们自己相信）可以适应未来任何可能的形势。我们称这种做法为“过度工程”（overengineering）。 按照字典的定义，overengineering就是over（意思是“过分了”）加engineer（意思是“设计和构造”）。根据这种解释，过度工程意思就是，在设计或者构造上花了过多的精力。&lt;/p&gt;

&lt;p&gt;在追求通用时，应当选择正确的事情，选择正确的方法，这是成功的软件设计的基础。然而，太过通用，会带来说不完的复杂和混乱，也会大大抬高维护成本。避免此误区的办法，和避免僵化设计的一样： 仅仅根据目前确知的需求来考虑通用。&lt;/p&gt;

&lt;p&gt;有个办法可从根本上避免这三大误区，这就是「渐进式开发和设计」。它要求按照特定顺序，一点一点地设计和构建系统。&lt;/p&gt;

&lt;p&gt;「缺陷概率定律」： 在程序中新增缺陷的可能性与代码修改量成正比。&lt;/p&gt;

&lt;p&gt;有时候，该规则也会被非正式地表述为：“如果不新加代码，也不修改代码，就不会产生新缺陷。”&lt;/p&gt;

&lt;p&gt;最好的设计，就是能适应外界尽可能多的变化，而软件自身的变化要尽可能少。&lt;/p&gt;

&lt;p&gt;永远不要「修正」任何东西，除非它真的是一个问题，而且有证据表明问题确实存在。&lt;/p&gt;

&lt;p&gt;在这类问题上，最有名的错误就是所谓的「提前优化」。也就是说，有些开发人员想让速度尽可能快，所以，他们还没弄清楚速度到底慢不慢，就花时间来优化程序。这就好像做慈善事业时，一边把食物送给富人，一边说“我们只是希望帮助他人”。这不合逻辑，对吧？因为这样是在解决根本不存在的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理想情况下，任何系统里的任何信息，都应当只存在一次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果既要做很多修改，又希望这些变化不要引入错误，还可以用上另一条法则。它不仅仅用来消除错误，还可以保持程序的可维护性，降低新增功能的难度，让代码更容易理解。这就是「简洁定律」（Law of Simplicity）： 软件任何一部分的维护难度，与该部分的简洁程度成反比。 (&lt;em&gt;这块原文和翻译好像有点问题, 我适当修正了下&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用户只希望尽可能简单，这样才能迅速上手，才能真正用起来。 许多程序员在这方面做得尤其差劲。他们以为别人都愿意花很多时间来学习自己写的代码，毕竟这是自己花很多时间写出来的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;名字应当足够长，能够完整表达其意义或描述其功能，但不能太长，以免影响阅读。&lt;/p&gt;

&lt;p&gt;复杂性是会叠加的，而且不是简单的线性叠加。&lt;/p&gt;

&lt;p&gt;只有在满足以下任何一个条件的前提下，重新发明轮子才有价值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你需要的东西不存在；&lt;/li&gt;
&lt;li&gt;现有的各种“轮子”都很糟糕，会把你困住；&lt;/li&gt;
&lt;li&gt;现有的“轮子”根本无法满足你的需求；&lt;/li&gt;
&lt;li&gt;现有的“轮子”缺乏良好的维护，而你也不能接过维护的任务（比如，你没有源代码）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所谓互通性，指的是如果需要，从一种技术切换到另一种技术有多难。&lt;/p&gt;

&lt;p&gt;所以，如果事情变复杂，不妨回过头去看看真正要解决的是什么问题。&lt;/p&gt;

&lt;p&gt;如果系统中某个部分太过复杂，有个好办法来解决：把它分解成几个独立的小部分，逐步重新设计。每次修改都应该足够小，这样可以放心动手，不会让事情更复杂。不过这个过程中最大的。&lt;/p&gt;
</description>
				<pubDate>Mon, 14 Mar 2016 21:05:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/03/14/code-simplicity-notes.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/03/14/code-simplicity-notes.html</guid>
			</item>
		
			<item>
				<title>PHP/MySQL中的localhost和127.0.0.1</title>
				<description>&lt;p&gt;接上一篇 &lt;a href=&quot;/2016/03/06/nginx-php-fpm-configuration-security.html&quot;&gt;Nginx 和 PHP-FPM 权限安全配置&lt;/a&gt; 最后一段关于数据库连接失败的处理。&lt;/p&gt;

&lt;p&gt;之前配置WordPress时, 当时想让mysql连接走tcp, google一下就得到答案:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;define(&amp;#39;DB_HOST&amp;#39;, &amp;#39;127.0.0.1&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 当时没注意看wp-config.php配置, 原先已经有一条配置了:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;define(&amp;#39;DB_HOST&amp;#39;, &amp;#39;localhost&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后来在针对Discuz论坛做权限处理时, 因为mysql也是走的unix domain socket, 所以想看看如何改为走tcp, 当时看到是配了localhost, 总想着是不是配一个端口上去就强制走tcp了。&lt;/p&gt;

&lt;p&gt;折腾了半天, 还是不行, 直接通过报错定位PHP代码, 最终定位到&lt;code&gt;mysql_connect()&lt;/code&gt;函数上。&lt;/p&gt;

&lt;p&gt;看了文档也没看出哪里有问题, 随手把 &lt;code&gt;localhost&lt;/code&gt; 改为 &lt;code&gt;127.0.0.1&lt;/code&gt;, 突然发现行了, 兴奋之余也感觉很莫名其妙。&lt;/p&gt;

&lt;p&gt;初以为是PHP对 &lt;code&gt;localhost&lt;/code&gt; 作了特殊处理, 直接解析为mysql sock路径了。&lt;/p&gt;

&lt;p&gt;今天折腾完手头事情再回头看看这个问题。&lt;/p&gt;

&lt;p&gt;依然在本地作了一个PHP-FPM chroot的隔离环境, 测试脚本:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;root@gentoo-local /var/www/test % cat index.php
&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
&amp;lt;?php
    define(&amp;#39;DB_HOST&amp;#39;,&amp;#39;localhost&amp;#39;);
    //define(&amp;#39;DB_HOST&amp;#39;,&amp;#39;127.0.0.1&amp;#39;);
    define(&amp;#39;DB_USER&amp;#39;,&amp;#39;root&amp;#39;);
    define(&amp;#39;DB_PWD&amp;#39;,&amp;#39;******&amp;#39;);


    $connect = mysql_connect(DB_HOST, DB_USER, DB_PWD) or die(&amp;#39;数据库连接失败，错误信息：&amp;#39;.mysql_error());
    echo $connect;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和昨天的情况一样, 如果是 &lt;code&gt;localhost&lt;/code&gt;, 则失败; &lt;code&gt;localhost:3306&lt;/code&gt;也失败; &lt;code&gt;127.0.0.1&lt;/code&gt; 则OK。&lt;/p&gt;

&lt;p&gt;因为知道是哪块的问题, 所以搜索起来离正确的答案也就越来越近。&lt;/p&gt;

&lt;p&gt;于是搜到了这篇回答 &lt;a href=&quot;http://stackoverflow.com/a/8829005/1276501&quot;&gt;Warning: mysql_connect(): [2002] No such file or directory&lt;/a&gt;, 里面有一句话:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The reason is that &amp;quot;localhost&amp;quot; is a special name for the mysql driver making it use the unix socket to connect to mysql instead of the a tcp socket.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里说是因为mysql对localhost的解析问题。和我之前猜测是PHP解析的不一致。&lt;/p&gt;

&lt;p&gt;本地mysql命令行客户端测试, 正常情况下下面两者都OK (&lt;code&gt;-h localhost&lt;/code&gt; 是默认方式, 可不指定):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ mysql -h localhost -u root -p   # OK
$ mysql -h 127.0.0.1 -u root -p   # OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 localhost 是 &lt;code&gt;/etc/hosts&lt;/code&gt; 中定义的, 所以临时注释掉这块, 自然localhost就变成无意义的字串了, 再次尝试:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ mysql -h localhost -u root -p   # OK
$ mysql -h 127.0.0.1 -u root -p   # OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者依然OK, 所以可以确定原因应该是mysql driver对 db host 的解析问题了。&lt;/p&gt;

&lt;p&gt;另外, 通过 &lt;code&gt;lsof&lt;/code&gt; 也可以看到连接进程的通信:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# localhost
mysql 27971 tankywoo  3u  unix 0xffff880078d25540  0t0  371911 type=STREAM

# 127.0.0.1
mysql 28249 tankywoo  3u  IPv4 373797       0t0  TCP localhost:50187-&amp;gt;localhost:mysql (ESTABLISHED)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照经验来说, &lt;code&gt;localhost&lt;/code&gt; 和 &lt;code&gt;127.0.0.1&lt;/code&gt; 是等价的, 如果主机是非IP地址, 都会尝试去做解析操作。MySQL可能是考虑到unix domain socket效率更高, 所以默认对localhost作了这个处理。&lt;/p&gt;

&lt;p&gt;但是这种处理太不明显, 或者说模凌两可, 所以给我的感觉是「坑」的性质更大一些。&lt;/p&gt;

&lt;p&gt;后续针对这块又搜了下, 发现遇到这个问题的人真不少, 就比如上面StackOverflow的那个回答, 有接近300的Up vote就能看出来。&lt;/p&gt;

&lt;p&gt;:(&lt;/p&gt;
</description>
				<pubDate>Wed, 09 Mar 2016 17:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/03/09/localhost-and-127-1-in-php-and-mysql.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/03/09/localhost-and-127-1-in-php-and-mysql.html</guid>
			</item>
		
			<item>
				<title>Nginx 和 PHP-FPM 权限安全配置</title>
				<description>&lt;p&gt;环境:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一台Gentoo宿主机&lt;/li&gt;
&lt;li&gt;两个WordPress博客&lt;/li&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;PHP-FPM 5.6&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要做到两个WordPress博客权限上互相安全隔离。&lt;/p&gt;

&lt;p&gt;大致步骤:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新建两个系统用户: blog1, blog2. shell是nologin.&lt;/li&gt;
&lt;li&gt;MySQL 新建两个用户blog1/blog2, 两个新数据库dbblog1/dbblog2, 分别将用户开放给各自数据库&lt;/li&gt;
&lt;li&gt;WordPress压缩包解压后, 属主全部改为blog1/blog2&lt;/li&gt;
&lt;li&gt;PHP-FPM 使用sock通信; 进程属主是blog1/blog2, sock文件的属主是blog1/blog2, 属组是nginx; 开启chroot&lt;/li&gt;
&lt;li&gt;Nginx进程权限是nginx&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;以下记录步骤, 只针对blog1, blog2和blog1配置完全一样, 改其中个别字段即可:&lt;/p&gt;

&lt;p&gt;创建两个系统服务用户:&lt;/p&gt;

&lt;p&gt;因为是作为服务用户, 所以shell需要设置为&lt;code&gt;/sbin/nologin&lt;/code&gt; 禁止登录; 另外, 不需要生成home目录.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ useradd -u 1201 -s /sbin/nologin -d /dev/null blog1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MySQL新建用户, 数据库, 配置权限:&lt;/p&gt;

&lt;p&gt;数据库级别权限隔离, 且各用户只有自己相关数据库的权限.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CREATE DATABASE dbblog1;
CREATE USER &amp;#39;blog1&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;&amp;lt;password&amp;gt;&amp;#39;;
GRANT ALL ON dbblog1.* TO &amp;#39;blog1&amp;#39;@&amp;#39;localhost&amp;#39;;
FLUSH PRIVILEGE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WordPress压缩包解压, 更改文件属主:&lt;/p&gt;

&lt;p&gt;属主更改是为了PHP-FPM有权限读写站点文件.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ tar zxvf wordpress-4.4.2-zh_CN.tar.gz
$ mv wordpress blog1
$ chown -R blog1 blog1
$ ls -alhd blog1
drwxr-xr-x 5 blog1 nogroup 4.0K Feb  3 08:13 blog1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PHP-FPM 配置:&lt;/p&gt;

&lt;p&gt;首先修改主配置 &lt;code&gt;/etc/php/fpm-php5.6/php-fpm.conf&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;注释掉 &lt;code&gt;Pool Definitions&lt;/code&gt; 中的所有配置项, 即去掉默认的 &lt;code&gt;www&lt;/code&gt; Pool; 开启 &lt;code&gt;include&lt;/code&gt; 项:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;; Include one or more files. If glob(3) exists, it is used to include a bunch of
; files from a glob(3) pattern. This directive can be used everywhere in the
; file.
; Relative path can also be used. They will be prefixed by:
;  - the global prefix if it&amp;#39;s been set (-p argument)
;  - /usr/lib64/php5.6 otherwise
include=/etc/php/fpm-php5.6/etc/fpm.d/*.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个web site一个独立的php-fpm配置(具体解释看默认的配置文件):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ cat /etc/php/fpm-php5.6/etc/fpm.d/blog1.conf
[blog1]
user = blog1    ; php-fpm子进程的uid
group = nogroup

listen = /var/run/php-fpm-blog1.sock
listen.owner = nginx    ; sock通信文件的属主, 和nginx通信
listen.group = nginx    ; sock通信文件的属组, 和nginx通信
listen.mode = 0660

pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

chroot = /var/www/blog1
chdir = /
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置 &lt;code&gt;user&lt;/code&gt; 是为了控制权限, 读写站点文件.&lt;/p&gt;

&lt;p&gt;配置 &lt;code&gt;listen.owner/group&lt;/code&gt; 是为了nginx有权限和php-fpm通信.&lt;/p&gt;

&lt;p&gt;设置 &lt;code&gt;chroot&lt;/code&gt; 到站点目录下, 限制最小访问权限. 命令 &lt;code&gt;pwdx&lt;/code&gt; 可以查看指定进程的当前工作目录.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ ps aux | grep php
root      5646  0.0  0.3 247836  7192 ?        Ss   14:55   0:00 php-fpm: master process (/etc/php/fpm-php5.6/php-fpm.conf)
blog1     5647  0.0  0.6 247944 13884 ?        S    14:55   0:00 php-fpm: pool blog1
blog1     5648  0.0  0.6 247812 13192 ?        S    14:55   0:00 php-fpm: pool blog1
blog2     5649  0.0  1.4 251840 29756 ?        S    14:55   0:00 php-fpm: pool blog2
blog2     5650  0.0  0.3 247812  6636 ?        S    14:55   0:00 php-fpm: pool blog2
root     10071  0.0  0.1 112700  2100 pts/4    S+   15:52   0:00 grep --color php

$ pwdx 5647
5647: /var/www/blog1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nginx配置:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;server {
    listen 80;
    server_name blog1.tankywoo.com;

    index index.php;

    access_log /var/log/nginx/blog1_log main;
    error_log /var/log/nginx/blog1_error_log;

    root /var/www/blog1/;

    location ~ .php$ {
        try_files      $uri  =404;
        fastcgi_pass   unix:///var/run/php-fpm-blog1.sock;
        include        fastcgi.conf;
        fastcgi_param  SCRIPT_FILENAME    /$fastcgi_script_name;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意 &lt;code&gt;fastcgi_param&lt;/code&gt; 配置. 如果是默认的:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则PHP-FPM(fastcgi)读取index.php, 即/var/www/blog1/inex.php.&lt;/p&gt;

&lt;p&gt;而因为PHP-FPM配置了chroot, 所以这个目录是当对于chroot后的目录.&lt;/p&gt;

&lt;p&gt;即实际读取/var/www/blog1/var/www/blog1/index.php&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;中间过程中, 遇到几个报错:&lt;/p&gt;

&lt;p&gt;php-fpm log:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;php-fpm chroot FastCGI sent in stderr: &amp;quot;Primary script unknown&amp;quot; while reading response header from upstream&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找不到php文件, 原因就是fastcgi的&lt;code&gt;SCRIPT_FILENAME&lt;/code&gt;配置之前没配.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;数据库连接失败&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原因是WordPress默认是通过socket连接数据库, 而此时web site是chroot的, 所以没法找到sock文件.&lt;/p&gt;

&lt;p&gt;方法1是把sock文件mount进去:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ mkdir -p /var/www/blog1/var/run/mysqld
$ mount --bind /var/run/mysqld /var/www/blog1/var/run/mysqld
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过此方法不够完美。&lt;/p&gt;

&lt;p&gt;方法2就是将WordPress改为通过tcp链接MySQL, wp-config.php 增加:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;define(&amp;#39;DB_HOST&amp;#39;, &amp;#39;127.0.0.1&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;p&gt;参考链接:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.if-not-true-then-false.com/2011/nginx-and-php-fpm-configuration-and-optimizing-tips-and-tricks/&quot;&gt;Nginx and PHP-FPM Configuration and Optimizing Tips and Tricks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-host-multiple-websites-securely-with-nginx-and-php-fpm-on-ubuntu-14-04&quot;&gt;How To Host Multiple Websites Securely With Nginx And Php-fpm On Ubuntu 14.04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gir.me.uk/nginx-php-fpm-with-chroot/&quot;&gt;Nginx + PHP-FPM with chroot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/a/16674537/1276501&quot;&gt;Apache + PHP-FPM + chroot results “File not found.” error&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sun, 06 Mar 2016 14:30:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/03/06/nginx-php-fpm-configuration-security.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/03/06/nginx-php-fpm-configuration-security.html</guid>
			</item>
		
			<item>
				<title>Simiki基于Github Pages配合Travis CI做持续集成</title>
				<description>&lt;p&gt;P.S. 2016年第一篇博客, 15年就没写总结和计划来安慰自己了~~&lt;/p&gt;

&lt;p&gt;回归正题&lt;/p&gt;

&lt;p&gt;关于这个方案，最早看过是关于Jekyll的，那时没想太多，扫一眼就忽略了。&lt;/p&gt;

&lt;p&gt;后来 &lt;a href=&quot;https://github.com/zvving&quot;&gt;@zvving&lt;/a&gt; 年前在 &lt;a href=&quot;https://github.com/tankywoo/simiki/issues/23#issuecomment-179675088&quot;&gt;issue上提交了simiki的解决方案&lt;/a&gt;，也提出了一些问题。于是我最近两天实践了一次，也hack了一些坑。&lt;/p&gt;

&lt;p&gt;具体的步骤可以参考以下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/d56008e6c2e1&quot;&gt;@zvving Simiki + Travis-ci + Github-Pages 搭建自动部署的个人 Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xuanwo.org/2015/02/07/Travis-CI-Hexo-Autodeploy/&quot;&gt;@xuanwo 使用Travis CI自动部署Hexo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/&quot;&gt;用 Travis CI 自動部署網站到 GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;issue上讨论的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;这里不讲一步步该如何做，主要对其中的一些步骤和问题，给出讲解说明以及解决方案。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;除了&lt;a href=&quot;http://simiki.org/&quot;&gt;Simiki&lt;/a&gt;本身，还需要的额外服务:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;  这个之前已经写过文档 &lt;a href=&quot;http://simiki.org/zh-docs/deploy.html&quot;&gt;Simiki Docs - Deploy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt;  做持续集成，配合Github，Simiki项目开发一直在用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大致的流程就是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;推送源分支到Github&lt;/li&gt;
&lt;li&gt;Travis CI收到推送，执行相应的build服务&lt;/li&gt;
&lt;li&gt;Travis CI生成相应的output，反推回到Github的gh-pages分支&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先在Travis CI上开启对自己项目的持续集成。&lt;/p&gt;

&lt;p&gt;因为这个涉及到推送回Github的写权限问题，所以生成一对单独的公私钥，专门给这个提供使用(这里我私钥就没有加密码了，因为travis会进一步加密):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ssh-keygen -C &amp;quot;wiki@tankywoo.com&amp;quot; -t rsa -b 2048 -f ~/.ssh/wiki
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将公钥内容贴到Github上项目的 「Settings -&amp;gt; Deploy keys -&amp;gt; Add deploy key」&lt;/p&gt;

&lt;p&gt;其次安装「travis」的本地工具，登录:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;gem install travis
travis login --auto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会生成一个token文件存放在&lt;code&gt;~/.travis/config.yml&lt;/code&gt; (部分字符串用&lt;code&gt;*&lt;/code&gt;代替):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ cat ~/.travis/config.yml
---
last_check:
  etag: W/&amp;quot;**********&amp;quot;
  version: 1.8.2
  at: 1455634393
checked_completion: true
completion_version: 1.8.2
endpoints:
  https://api.travis-ci.org/:
    access_token: *******
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入相应的Github项目目录，加密私钥：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ travis encrypt-file ~/.ssh/wiki --add
encrypting /Users/TankyWoo/.ssh/wiki for tankywoo/wiki.tankywoo.com
storing result as wiki.enc
storing secure env variables for decryption

Make sure to add wiki.enc to the git repository.
Make sure not to add /Users/TankyWoo/.ssh/wiki to the git repository.
Commit all changes to your .travis.yml.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个操作主要做了几件事情:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加密ssh私钥, 生成一个wiki.enc。这个文件需要放到项目里，上面的输出已经提示了，千万别把原始的私钥放进去了~~&lt;/li&gt;
&lt;li&gt;相应的解密k/v值以环境变量方式存在Travis CI上, 见Travis CI上项目的「More options -&amp;gt; Settings -&amp;gt; Environment Variables」&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将解密命令自动写入到本地项目的&lt;code&gt;.travis.yml&lt;/code&gt;里 (注意每个人的环境变量名不一样, 不需要去复制我的, travis加密时会自动写入)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;before_install:
- openssl aes-256-cbc -K $encrypted_f9a8a4d68f34_key -iv $encrypted_f9a8a4d68f34_iv
  -in wiki.enc -out ~\/.ssh/wiki -d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后本地项目新增文件&lt;code&gt;ssh_config&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Host github.com
    User git
    StrictHostKeyChecking no
    IdentityFile ~/.ssh/id_rsa
    IdentitiesOnly yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要指定用户是git, 走的「ssh/git」协议, 而不是「http/https」协议。&lt;/p&gt;

&lt;p&gt;到这里，我先把配置ok的完整「.travis.yml」贴出来:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;language: python
python:
  - &amp;#39;2.7&amp;#39;
install:
  - pip install fabric
  - pip install ghp-import
  - pip install simiki
branches:
  only:
    - master
    - gh-pages
before_install:
  - openssl aes-256-cbc -K $encrypted_f9a8a4d68f34_key -iv $encrypted_f9a8a4d68f34_iv
    -in wiki.enc -out ~/.ssh/id_rsa -d
  - chmod 600 ~/.ssh/id_rsa  # ssh私钥权限
  - cp ssh_config ~/.ssh/config  # 配置ssh client
  - git config --global user.name &amp;quot;Tanky Woo&amp;quot;  # 推送回gh-pages需要的基本配置
  - git config --global user.email wtq1990@gmail.com
  - git remote set-url origin git@github.com:tankywoo/wiki.tankywoo.com.git  # hack 1
  - git fetch origin gh-pages:refs/remotes/origin/gh-pages  # hack 2
  - git branch gh-pages origin/gh-pages
script:
  - simiki g
  - fab deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里面有两处hack的地方(注释处):&lt;/p&gt;

&lt;p&gt;hack 1, 因为Travis CI克隆是用的「http/https」协议(需要输入username/password)，所以我在push gh-pages时没法使用公私钥认证，于是克隆下来后我就改了origin的地址为「ssh/git」。&lt;/p&gt;

&lt;p&gt;hack 2, 作了一个单独拉出&lt;code&gt;gh-pages&lt;/code&gt;分支的操作。&lt;/p&gt;

&lt;p&gt;看Travis CI的build log, 克隆项目指定了&lt;code&gt;--depth&lt;/code&gt;，这个会只拉出当前分支:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git clone --depth=50 --branch=master https://github.com/tankywoo/wiki.tankywoo.com.git tankywoo/wiki.tankywoo.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实最简单的就是配置选项，再加上&lt;code&gt;--no-single-branch&lt;/code&gt;选项就可以了；但是，Travis CI对于克隆命令，除了可以配置&lt;code&gt;depth&lt;/code&gt;外，不支持其它选项，所以我只能作了这个hack，单独拉出gh-pages分支，否则会报错:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ fab deploy
[localhost] local: which ghp-import &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; echo $?
[localhost] local: ghp-import -p -m &amp;quot;Update output documentation&amp;quot; -r origin -b gh-pages output
Warning: Permanently added the RSA host key for IP address &amp;#39;192.30.252.131&amp;#39; to the list of known hosts.
To git@github.com:tankywoo/wiki.tankywoo.com.git
 ! [rejected]        gh-pages -&amp;gt; gh-pages (fetch first)
error: failed to push some refs to &amp;#39;git@github.com:tankywoo/wiki.tankywoo.com.git&amp;#39;
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., &amp;#39;git pull ...&amp;#39;) before pushing again.
hint: See the &amp;#39;Note about fast-forwards&amp;#39; in &amp;#39;git push --help&amp;#39; for details.
Traceback (most recent call last):
  File &amp;quot;/home/travis/virtualenv/python2.7.9/bin/ghp-import&amp;quot;, line 198, in &amp;lt;module&amp;gt;
    main()
  File &amp;quot;/home/travis/virtualenv/python2.7.9/bin/ghp-import&amp;quot;, line 194, in main
    sp.check_call([&amp;#39;git&amp;#39;, &amp;#39;push&amp;#39;, opts.remote, opts.branch])
  File &amp;quot;/opt/python/2.7.9/lib/python2.7/subprocess.py&amp;quot;, line 540, in check_call
    raise CalledProcessError(retcode, cmd)
subprocess.CalledProcessError: Command &amp;#39;[&amp;#39;git&amp;#39;, &amp;#39;push&amp;#39;, &amp;#39;origin&amp;#39;, &amp;#39;gh-pages&amp;#39;]&amp;#39; returned non-zero exit status 1
Fatal error: local() encountered an error (return code 1) while executing &amp;#39;ghp-import -p -m &amp;quot;Update output documentation&amp;quot; -r origin -b gh-pages output&amp;#39;
Aborting.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为克隆时origin没有带上gh-pages分支，所以这样相当于新建了gh-pages分支，并会覆盖远端的，这时需要加上&lt;code&gt;-f/--force&lt;/code&gt;强制push，但是这样显然也并不是一个好的方案。&lt;/p&gt;

&lt;p&gt;另外，在配置ssh client配置时，也可以不用这个「ssh-config」配置文件，改用&lt;code&gt;ssh_agent&lt;/code&gt;(这玩意相当于win下常用的PuTTY工具集的Pageant，我的&lt;a href=&quot;https://github.com/tankywoo/dotfiles/blob/master/.zshrc&quot;&gt;dotfiles&lt;/a&gt;里也有这个的配置，有兴趣的可以看看):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;before_install:
  - openssl aes-256-cbc -K $encrypted_f9a8a4d68f34_key -iv $encrypted_f9a8a4d68f34_iv
    -in wiki.enc -out ~/.ssh/id_rsa -d
  - chmod 600 ~/.ssh/id_rsa
  - eval $(ssh-agent)  # 这两行使用ssh-agent
  - ssh-add ~/.ssh/id_rsa
  - git config --global user.name &amp;quot;Tanky Woo&amp;quot;
  - ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，网上很多方案把这两种都加进去了，也无所谓~~~&lt;/p&gt;

&lt;p&gt;这个说白了就是一点点的测试，我前后也测试了20次，才测试OK。&lt;/p&gt;

&lt;p&gt;后续，我会再基于此篇基础上，整理一份文档放到 &lt;a href=&quot;http://simiki.org&quot;&gt;simiki.org&lt;/a&gt; 上。&lt;/p&gt;

&lt;p&gt;最后感谢 &lt;a href=&quot;https://github.com/zvving&quot;&gt;@zvving&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/Xuanwo&quot;&gt;@Xuanwo&lt;/a&gt; 对这个方案的贡献.&lt;/p&gt;
</description>
				<pubDate>Fri, 19 Feb 2016 21:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2016/02/19/simiki-with-travis-ci.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2016/02/19/simiki-with-travis-ci.html</guid>
			</item>
		
			<item>
				<title>Nagios权限管理 - 实现指定人员只能查看指定主机</title>
				<description>&lt;p&gt;一个很常见的需求: 对于某些人员, 只允许其在Nagios Web管理页面查看指定的主机&lt;/p&gt;

&lt;p&gt;首先确保Nagios配置和用户的帐号是OK的, 也就是配置正确后, 登录Nagios Web, 是可以看到期望的主机列表.&lt;/p&gt;

&lt;p&gt;首先是&lt;code&gt;cgi.cfg&lt;/code&gt;的配置, 具体可以参考 &lt;a href=&quot;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/configcgi.html&quot;&gt;CGI Configuration File Options&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;use_authentication&lt;/code&gt; 控制是否开启权限管理. 默认开启.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;This option controls whether or not the CGIs will use the authentication and authorization functionality when determining what information and commands users have access to.I would strongly suggest that you use the authentication functionality for the CGIs. If you decide not to use authentication, make sure to remove the command CGI to prevent unauthorized users from issuing commands to Nagios. The CGI will not issue commands to Nagios if authentication is disabled, but I would suggest removing it altogether just to be on the safe side. More information on how to setup authentication and configure authorization for the CGIs can be found here.

* 0 = Don&amp;#39;t use authentication functionality
* 1 = Use authentication and authorization functionality (default)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外就是一系列&lt;code&gt;authorized_*&lt;/code&gt;开头的配置项:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;authorized_for_system_information=
authorized_for_configuration_information=
authorized_for_system_commands=
authorized_for_all_services=
authorized_for_all_hosts=
authorized_for_all_service_commands=
authorized_for_all_host_commands=
authorized_for_read_only=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面都接的用户名, 逗号分隔.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;authorized_for_all_hosts/authorized_for_all_service&lt;/code&gt; 控制用户是否有权限查看主机/服务的状态; &lt;code&gt;authorized_for_all_host_commands/authorized_for_all_service_commands&lt;/code&gt;控制用户是否有权限去下发一些命令.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;authorized_for_read_only&lt;/code&gt;配置用户是只读权限, 只能看, 不能做一些管理类的操作, 进入一个主机或服务的状态页面, 没有右边的管理栏.&lt;/p&gt;

&lt;p&gt;上面是一些全局性的控制, 更细粒度的控制在自定义的配置文件中. 首先自习看几遍 &lt;a href=&quot;https://assets.nagios.com/downloads/nagioscore/docs/nagioscore/4/en/cgiauth.html&quot;&gt;Authentication And Authorization In The CGIs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nagios的认证对象分为两个:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;authenticated user: web server配置的账户/密码, 并且被Nagios配置授权&lt;/li&gt;
&lt;li&gt;authenticated contact: 本质是一个authenticated user, 不过他的username和contact定义的name是一样. 这样他就能访问配置了指定他contact的主机/服务.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们需要的就是后者.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单的说就是定义一个contact对象, 并且这个对象的 &lt;code&gt;contact_name&lt;/code&gt; 和 &lt;code&gt;username&lt;/code&gt; 一致.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举一个具体的例子(无关配置省略), 一般情况:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def contact {
    contact_name                   Ops
    email                          user_a@example.com,user_b@example.com,...
}

define host {
    use                            generic-host
    host_name                      Server1
    alias                          Server1
    contacts                       Ops
    ...
}

define service {
    use                            generic-service
    host_name                      Server1
    service_description            HTTP
    contacts                       Ops
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在想让user_a这个用户登录Nagios后可以看到Server1的状态. 需要修改为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def contact {
    contact_name                   user_a
    email                          user_a@example.com
}

define host {
    use                            generic-host
    host_name                      Server1
    alias                          Server1
    contacts                       Ops,user_a
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, 也可以保留原来的风格, 将Ops这个contact改为一个contact_group:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def contact {
    contact_name                   user_a
    email                          user_a@example.com
}

def contact {
    contact_name                   user_b
    email                          user_b@example.com
}

def contactgroup {
    contactgroup_name              Ops
    members                        user_a,user_b
}

define host {
    use                            generic-host
    host_name                      Server1
    alias                          Server1
    contact_groups                 Ops
    ...
}

define service {
    use                            generic-service
    host_name                      Server1
    service_description            HTTP
    contact_groups                 Ops
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://serverfault.com/questions/436886/nagios-is-it-possible-to-create-view-only-users-and-let-them-view-only-speci&quot;&gt;Nagios - Is it possible to create “view only” users and let them view only specific services/servers?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linuxsysadminblog.com/2009/05/setup-nagios-user-to-view-specific-host-and-services/&quot;&gt;Setup Nagios User to View Specific Host and Services&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Mon, 23 Nov 2015 21:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2015/11/23/nagios-auth-control.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2015/11/23/nagios-auth-control.html</guid>
			</item>
		
			<item>
				<title>Tmux下Mutt没有重绘终端窗口的问题</title>
				<description>&lt;p&gt;现象: 使用mutt查看邮件, 连续查看下一封, 或者按q回退到邮件列表, 屏幕上字符会混乱, 也就是比如看到下一封邮件, 但是有些地方还是上一封的内容字符, 并没有完全重绘(redraw)窗口.&lt;/p&gt;

&lt;p&gt;这个问题困扰了很长一段时间, 多次搜索无果, 找不到切入点.&lt;/p&gt;

&lt;p&gt;这两天又试了下, 发现在tmux下运行mutt会有这个问题, 否则是正常的. Google &amp;quot;tmux mutt not flush&amp;quot; 搜出这篇回答: &lt;a href=&quot;http://superuser.com/questions/844058/tmux-mutt-not-redrawing&quot;&gt;Tmux + mutt not redrawing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;试了下, 果然是这个原因.&lt;/p&gt;

&lt;p&gt;查看&lt;code&gt;man tmux&lt;/code&gt;关于default-terminal的设置:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Set the default terminal for new windows created in this session - the default value of the TERM environment variable.  For tmux to work correctly, this must be set to `screen&amp;#39; or a derivative of it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个是设置新建窗口的&lt;code&gt;TERM&lt;/code&gt;环境变量, 默认是&lt;code&gt;screen&lt;/code&gt;. 另外这里还强调了必须设置screen或它的衍生. 而我设置的是&lt;code&gt;xterm-256color&lt;/code&gt;. 于是改为:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;set -g default-terminal &amp;quot;screen-256color&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, tmux设置&lt;code&gt;TERM&lt;/code&gt;是在加载~/.zshrc之前, 所以如果在~/.zsh中设置了&lt;code&gt;TERM&lt;/code&gt;, 还要做一定的定制:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if [ -z &amp;quot;$TMUX&amp;quot; ] &amp;amp;&amp;amp; [[ &amp;quot;$TERM&amp;quot; =~ &amp;quot;xterm&amp;quot; ]]; then
    if [ -e /usr/share/terminfo/*/xterm-256color ]; then
        echo &amp;quot;1&amp;quot;
        export TERM=&amp;#39;xterm-256color&amp;#39;
    else
        echo &amp;quot;2&amp;quot;
        export TERM=&amp;#39;xterm-color&amp;#39;
    fi
elif [ -n &amp;quot;$TMUX&amp;quot; ]; then
    if [ -e /usr/share/terminfo/*/screen-256color ]; then
        echo &amp;quot;3&amp;quot;
        export TERM=&amp;#39;screen-256color&amp;#39;
    else
        echo &amp;quot;4&amp;quot;
        export TERM=&amp;#39;screen&amp;#39;
    fi
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有两个地方说明下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$TMUX&lt;/code&gt; 环境变量, 在使用tmux后, 这个变量是一个路径值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e /usr/share/terminfo/*/xterm-256color&lt;/code&gt;, 在linux下, &lt;code&gt;*&lt;/code&gt;这个其实是terminal type的首字母, 但是mac os下不是这样, 我原先设置的是&lt;code&gt;-e /usr/share/terminfo/x/xterm-256color&lt;/code&gt;, 在mac下不工作.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果shell配置中没有设置&lt;code&gt;TERM&lt;/code&gt;, 则只需要配置tmux.conf即可.&lt;/p&gt;

&lt;p&gt;问题解决, mutt查看邮件的闹心问题总算没了&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;(
TL;DR&lt;/p&gt;

&lt;p&gt;并且没有完全弄清楚, 可能会有理解错误的地方
)&lt;/p&gt;

&lt;p&gt;tty, pty, pts: (&lt;code&gt;man 4 xxx&lt;/code&gt;查看手册)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tty&lt;/code&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Teleprinter&quot;&gt;Tele TYpewriter&lt;/a&gt; 是一个终端设备, 是硬件设备(如&lt;a href=&quot;https://en.wikipedia.org/wiki/VT100&quot;&gt;VT100&lt;/a&gt; 或由 内核仿真(如&lt;code&gt;Ctrl+Alt+F1~F6&lt;/code&gt;, 虚拟控制台).&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A tty is a native terminal device, the backend is either hardware or kernel emulated.&lt;/li&gt;
&lt;li&gt;The TTY is a terminal that doesn&amp;#39;t require X or any program to exist, aka a Real Terminal. So you can use that terminal even when X fails to load. (kernel stuff)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;pty, pts&lt;/code&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Pseudoterminal&quot;&gt;pseudoterminal&lt;/a&gt;, 伪终端. 是由普通程序仿真出来, 如screen, ssh等. pty分为ptmx(master)和pts(slave).&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A pty (pseudo terminal device) is a terminal device which is emulated by an other program (example: xterm, screen, or ssh are such programs).&lt;/li&gt;
&lt;li&gt;In practice, pseudo-terminals are used for implementing terminal emulators such as xterm&lt;/li&gt;
&lt;li&gt;A PTS is a a Pseudo Terminal that needs a program to exist. You can launch several PTS in the same TTY. Both behaviors almost the same. (user stuff)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux/Mac 下按 &lt;code&gt;w&lt;/code&gt; 可以看到登录情况以及terminal name:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# 这台机器是部署在虚拟机上
# tty1 是我直接在虚拟机终端输入帐号密码登录进去
# pts/0 是通过ssh登录上去
tankywoo ~ % w
 18:13:38 up 13 days,  6:08,  2 users,  load average: 0.02, 0.04, 0.05
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
tankywoo tty1      17:59   14:05   0.36s  0.34s -zsh
tankywoo pts/0     17:41    0.00s  0.57s  0.00s w
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.quora.com/What-is-the-difference-between-a-TTY-terminal-and-a-PTS-graphical-terminal-in-Linux&quot;&gt;What is the difference between a TTY terminal and a PTS graphical terminal in Linux?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/21280/difference-between-pts-and-tty&quot;&gt;Difference between pts and tty&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;terminal, console, terminal emulator, terminal multiplexer&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Terminal_emulator&quot;&gt;terminal emulator&lt;/a&gt;, 终端仿真器.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;is a program that emulates a video terminal within some other display architecture.&lt;/li&gt;
&lt;li&gt;provides a standardised character based interface for text mode applications, it emulates the behavior of real or idealised hardware.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;如基于X Window的&lt;a href=&quot;https://en.wikipedia.org/wiki/Xterm&quot;&gt;xterm&lt;/a&gt;, KDE默认的terminal &lt;a href=&quot;https://en.wikipedia.org/wiki/Konsole&quot;&gt;konsole&lt;/a&gt;, Mac下比自带更好用的&lt;a href=&quot;https://en.wikipedia.org/wiki/ITerm2&quot;&gt;iTerm2&lt;/a&gt;, Win下的 &lt;a href=&quot;https://en.wikipedia.org/wiki/PuTTY&quot;&gt;PuTTY&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Xshell&quot;&gt;XShell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;这是一份完整的列表&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_terminal_emulators&quot;&gt;List of terminal emulators&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Terminal_multiplexer&quot;&gt;terminal multiplexer&lt;/a&gt;, 终端复用器.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;is a software application that can be used to multiplex several virtual consoles, allowing a user to access multiple separate terminal sessions inside a single terminal window or remote terminal session.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如系统自带的&lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_Screen&quot;&gt;screen&lt;/a&gt;, Ubuntu下有名的&lt;a href=&quot;https://en.wikipedia.org/wiki/Byobu_(software)&quot;&gt;Byobu&lt;/a&gt;, 以及&lt;a href=&quot;https://en.wikipedia.org/wiki/Tmux&quot;&gt;tmux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;console&lt;/code&gt;和&lt;code&gt;terminal&lt;/code&gt;, 其实在日常的技术交流中, 这两个基本是等价的. 所以这里这里要是深究其区别, 并追溯历史原因, 是一件很蛋疼的事情.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;terminal&lt;/strong&gt; refers to a wrapper program which runs a shell. Decades ago, this was a physical device consisting of little more than a monitor and keyboard. As unix/linux systems added better multiprocessing and windowing systems, this terminal concept was abstracted into software. Now you have programs such as Gnome Terminal which launches a window in a Gnome windowing environment which will run a shell into which you can enter commands.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;console&lt;/strong&gt; is a special sort of terminal. Historically, the console was a single keyboard and monitor plugged into a dedicated serial console port on a computer used for direct communication at a low level with the operating system. Modern linux systems provide virtual consoles. These are accessed through key combinations (e.g. &lt;code&gt;Alt+F1&lt;/code&gt; or &lt;code&gt;Ctrl+Alt+F1&lt;/code&gt;; the function key numbers different consoles) which are handled at low levels of the linux operating system -- this means that there is no special service which needs to be installed and configured to run. Interacting with the console is also done using a shell program.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/33881/what-is-the-difference-between-a-console-shell-terminal-terminal-emulator-te&quot;&gt;What is the difference between a Console, Shell, Terminal, Terminal emulator, Terminal multiplexer, and a Window manager?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://superuser.com/a/144668/251495&quot;&gt;What is the difference between shell, console, and terminal?&lt;/a&gt; 比较认可这篇的解释&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://askubuntu.com/questions/506510/what-is-the-difference-between-terminal-console-shell-and-command-line&quot;&gt;What is the difference between Terminal, Console, Shell, and Command Line?&lt;/a&gt; 这个帖子的一些回答都值得看看&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con&quot;&gt;What is the exact difference between a &amp;#39;terminal&amp;#39;, a &amp;#39;shell&amp;#39;, a &amp;#39;tty&amp;#39; and a &amp;#39;console&amp;#39;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linuxmantra.com/2010/04/console-vs-terminal.html&quot;&gt;console vs terminal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结合上面的这些说下自己的理解:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;tty和pty其实都可以总称tty(terminal).&lt;/li&gt;
&lt;li&gt;console是一个特殊的terminal.&lt;/li&gt;
&lt;li&gt;terminal一般用于指terminal emulator&lt;/li&gt;
&lt;li&gt;直接显示器连服务器看到的是console&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实, 这块还是不纠结, 就当作一回事比较好, 基于历史原因, 曾经的terminal, console现在都software/virtual化了.&lt;/p&gt;

&lt;p&gt;查了几个小时, 越看越晕.&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;$TERM&lt;/code&gt;环境变量, 定义terminal type (&lt;code&gt;man 7 term&lt;/code&gt;):&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The  environment  variable TERM should normally contain the type name of the terminal, console or display-device type you are using.  This  information  is  critical for all screen-oriented programs, including your editor and mailer.&lt;/li&gt;
&lt;li&gt;associates the terminal you are using with a list of characteristics given in the terminfo(M) database. The characteristics tell the system how to interpret your terminal&amp;#39;s keys and how to display data on your terminal screen.&lt;/li&gt;
&lt;li&gt;The $TERM variable is for use by applications to take advantage of capabilities of that terminal.&lt;/li&gt;
&lt;li&gt;For example, if a program want&amp;#39;s to display colored text, it must first find out if the terminal you&amp;#39;re using supports colored text, and then if it does, how to do colored text.&lt;/li&gt;
&lt;li&gt;The way this works is that the system keeps a library of known terminals and their capabilities. On most systems this is in /usr/share/terminfo (there&amp;#39;s also termcap, but it&amp;#39;s legacy not used much any more).&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;toe&lt;/code&gt; 可以查看支持的terminal type&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/share/terminfo/&lt;/code&gt; 是一个数据库, 存放是支持的terminal功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;infocmp &amp;lt;term type 1&amp;gt; &amp;lt;term type 2&amp;gt;&lt;/code&gt; 用于对比两个term的不同&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/93376/which-terminal-type-am-i-using&quot;&gt;Which terminal type am I using?&lt;/a&gt; 解释的比较详细&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/43945/whats-the-difference-between-various-term-variables&quot;&gt;What&amp;#39;s the difference between various $TERM variables?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7617458/terminal-emacs-colors-only-work-with-term-xterm-256color&quot;&gt;Terminal emacs colors only work with TERM=xterm-256color&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;个人理解, terminal emulator 和 terminal type的关系, 有点类似Linux发行版和系统内核的关系. 比如guake和gnome-terminal这两个terminal emulator都是GNOME终端, terminal type可以是gnome一系的.&lt;/p&gt;

&lt;p&gt;常规的万金油设置一般就是&lt;code&gt;screen-*&lt;/code&gt;或者&lt;code&gt;xterm-*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其它:&lt;/p&gt;

&lt;p&gt;iTerm 在 Profiles -&amp;gt; Terminal -&amp;gt; Report Terminal Type 里可以设置终端仿真器的类型.&lt;/p&gt;

&lt;p&gt;这个可以被shell配置(.basrc/.zshrc/...)中配置的&lt;code&gt;$TERM&lt;/code&gt;环境变量覆盖.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/79334/how-does-a-linux-terminal-work&quot;&gt;How does a Linux terminal work?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://oss.sgi.com/LDP/HOWTO/Text-Terminal-HOWTO-9.html&quot;&gt;Text-Terminal-HOWTO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/140139/how-are-xterm-and-screen-related&quot;&gt;How are “xterm” and “screen” related?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/dkblog/archive/2009/07/16/1980729.html&quot;&gt;系统变量TERM不知是用来干什么的？它的值有vt100，vt220等，这些值代表什么意思？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 24 Oct 2015 18:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2015/10/24/tmux-mutt-not-redraw-problem.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2015/10/24/tmux-mutt-not-redraw-problem.html</guid>
			</item>
		
			<item>
				<title>关于最近写的小玩具tfcs</title>
				<description>&lt;p&gt;说是最近写的, 其实就是最近几天晚上抽了点时间写的, 没有什么技术含量, 也没有什么工作量...&lt;/p&gt;

&lt;p&gt;平时的工作中, 会时不时搜到一些不错的代码片段(code snippet). 也没有保存代码片段的习惯, 就是偶尔给保存在Gist上.&lt;/p&gt;

&lt;p&gt;最近看到两个不错的片段, 寻思着该收集一下了. 以目前我所了解的来看, Gist应该是最好用的.&lt;/p&gt;

&lt;p&gt;但是Gist只有一个贴代码的地方, 和一个简单的描述栏.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我想的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以做一些category/tag, 方便分类&lt;/li&gt;
&lt;li&gt;可以让我有一个更详细的说明的地方, 支持标记语言, 如md/rst&lt;/li&gt;
&lt;li&gt;以后我可以很方便的迁移到其它地方使用, 或者导出&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;于是我又翻看了自己曾经在知乎的一篇回答&lt;a href=&quot;http://www.zhihu.com/question/21003319/answer/16931276&quot;&gt;哪些程序或服务可以方便地保存常用代码片段？&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;网上关于这个的讨论不多, 大部分还是推荐Gist, 我的这篇回答应该是包括了圈里比较常用的几个web code snippet网站.&lt;/p&gt;

&lt;p&gt;但是这些功能上都大同小异, 都是在一些细节上有不同的特色, 无法满足我的需求.&lt;/p&gt;

&lt;p&gt;至于MacOs App, 网上倒是可以搜出十来个, 很多人也推荐的是&lt;a href=&quot;https://kapeli.com/dash&quot;&gt;Dash&lt;/a&gt;自带的code snippet功能, 和Gist相比多了一个Tag功能.&lt;/p&gt;

&lt;p&gt;而Vim的插件, 我印象中也是有这类插件的, 可以配置快捷键快速调出snippet, 不过配置有点麻烦&lt;/p&gt;

&lt;p&gt;既然没有合适的, 我就选择了自己写一个, 取名叫tfcs, 没有什么其它意义, 就是几个单词的缩写, 原谅我自恋了一把(TankyWoo Flask Code Snippet)...&lt;/p&gt;

&lt;p&gt;关于这个tfcs, 项目主页&lt;a href=&quot;https://github.com/tankywoo/tfcs&quot;&gt;tankywoo/tfcs&lt;/a&gt;, 目前是:&lt;/p&gt;

&lt;p&gt;使用markdown作为静态输入源. 对这类文本标记语言, 尤其markdown, 我几乎达到一个狂热的地步了, 见我之前写的&lt;a href=&quot;http://simiki.org/&quot;&gt;Simiki&lt;/a&gt;就知道了...&lt;/p&gt;

&lt;p&gt;依然使用了yaml front matter作为每一篇code snippet的meta信息.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;---
title: &amp;#39;xxx&amp;#39;
description: &amp;#39;xxx&amp;#39;
tag: xxx1,xxx2
date: 2015-10-23 00:00
id: xxx
---

...
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然, 这个id是暂时需要手动需生成的, 作为url部分, 我自己是使用的8位随机ascii/digit字符串, 以个人使用来说, 应该是足够了.&lt;/p&gt;

&lt;p&gt;code snippet存放在一个单独的目录下, 有一个大的分类(category), 如:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.
├── cpp
│   └── xxx3.md
├── nodejs
│   └── xxx4.md
├── python
│   └── xxx1.md
└── ruby
    └── xxx2.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后tag是在meta信息里配置的.&lt;/p&gt;

&lt;p&gt;暂时使用os.path.walk遍历snippets目录, re分割meta和body. 试了几十篇的情况, 效率上应该是足够了.&lt;/p&gt;

&lt;p&gt;关于它和wiki以及blog的区别, 这里简单说下我的理解:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tfcs以snippet为主，几十上百字的简单的说明, 外加一个或多个snippet, 可以认为是一个微型blog.&lt;/li&gt;
&lt;li&gt;blog以记录生成、问题解决方案、研究的某一块笔记为主, 是一个更复杂的笔记&lt;/li&gt;
&lt;li&gt;wiki是在某一类形成一定规模时, 尤其blog上的, 可以逐步汇总到wiki上了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于tfcs和以上web code snippet的对比缺点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首次需要配置, 部署, 需要有自己的服务器&lt;/li&gt;
&lt;li&gt;展示稍微麻烦, 比如我现在是更新后把文档传到我的vps指定目录上&lt;/li&gt;
&lt;li&gt;没有fork/star功能, Gist的这个功能比较方便, 因为它自身就是一个snippets体系, 可以随时把别人的收藏了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后续考虑的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据源转换下存在sqlite里. 模式就是编辑md, 脚本转换写入sqlite, flask是直接和sqlite交互.&lt;/li&gt;
&lt;li&gt;支持点击代码复制到clipboard&lt;/li&gt;
&lt;li&gt;category/tag分支检索&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后, 这个是折腾着玩写的, 后续基本不会怎么变动, 也没有考虑太多, 就像README里写的, be used with caution, 慎用...&lt;/p&gt;

&lt;p&gt;demo传送门: &lt;a href=&quot;http://code.tankywoo.com&quot;&gt;code.tankywoo.com&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 24 Oct 2015 10:00:00 +0800</pubDate>
				<link>http://blog.tankywoo.com/2015/10/24/about-tfcs.html</link>
				<guid isPermaLink="true">http://blog.tankywoo.com/2015/10/24/about-tfcs.html</guid>
			</item>
		
	</channel>
</rss>
