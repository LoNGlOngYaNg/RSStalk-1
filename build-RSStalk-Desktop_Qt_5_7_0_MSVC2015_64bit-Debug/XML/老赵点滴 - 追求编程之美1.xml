<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>老赵点滴 - 追求编程之美</title>
    <link>http://blog.zhaojie.me/</link>
    <description>先做人，再做技术人员，最后做程序员。打造国内最好的.NET技术博客。</description>
    <language>zh-cn</language>
    <managingEditor>jeffz@live.com (老赵)</managingEditor>
    <webMaster>jeffz@live.com (老赵)</webMaster>
    <pubDate>Wed, 31 Oct 2012 23:02:10 GMT</pubDate>
    <lastBuildDate>Wed, 31 Oct 2012 23:16:32 GMT</lastBuildDate>
    <ttl>60</ttl>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/essential/">重中之重</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>你的字典里有多少元素？</title>
      <link>http://blog.zhaojie.me/2014/07/how-many-elements-in-your-dictionary.html</link>
      <guid>http://blog.zhaojie.me/2014/07/how-many-elements-in-your-dictionary.html</guid>
      <description>&lt;p&gt;“字典”或者说“哈希表”大家都会用，这真是一个好东西，只要创建了之后就可以不断的丢东西进去，添加删除都是&lt;code&gt;O(1)&lt;/code&gt;操作，那叫一个快字了得。不过这里我要再次引用Alan Perlis的名言：“Lisp programmers know the value of everything but the cost of nothing.”，目的是想提醒做事“不要忘记背后的代价”。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/how-many-elements-in-your-dictionary/1.png" /&gt;&lt;/p&gt;

&lt;p&gt;上图引自&lt;a href="http://en.wikipedia.org/wiki/Hash_table"&gt;Wikipedia中“Hash table”条目&lt;/a&gt;，描述了最常用的“哈希表”实现方式之一，也是.NET中&lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt;所采用的做法。那么就以.NET中的&lt;code&gt;Dictionary&lt;/code&gt;实现来举例，它的代价是什么呢？这里的代价主要是其内存开销。&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;Dictionary&lt;/code&gt;对象时我们可以传入一个“容量”值，但这并不是它会使用的实际容量。&lt;code&gt;Dictionary&lt;/code&gt;内部会找到“不小于该值的最小质数”来作为它使用的实际容量，最小是3。这么做的目的是减少碰撞几率，因为从哈希值定位buckets时会用到取模操作。得到实际容量之后，就会它用来创建&lt;code&gt;int[] buckets&lt;/code&gt;和&lt;code&gt;Entry[] entries&lt;/code&gt;两个数组，用来实现间接索引（即&lt;code&gt;buckets&lt;/code&gt;中保存的其实是&lt;code&gt;entries&lt;/code&gt;数组的下标，具体可以参考&lt;a href="http://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs"&gt;Reference Source中的实现代码&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;请注意，这个实际容量也是下次rehash之前可以保存的最大元素个数。因此，假如你预计会要保存N个元素，那么就把N传入构造函数吧，这可以避免一次又一次无谓的rehash操作。&lt;/p&gt;

&lt;p&gt;因此，即便你只创建了一个空字典，它至少也创建了两个长度为3的数组，再加上其他杂七杂八的字段，一个字典至少也占用了48个字节——还记得&lt;a href="http://zrx.zhaojie.me/"&gt;“赵人希”公众账号&lt;/a&gt;上的第一篇文章《&lt;a href="http://zrx.zhaojie.me/20140513/"&gt;.NET程序性能的基本要领&lt;/a&gt;》吗？&lt;/p&gt;

&lt;p&gt;事实上，假如是一次初始化之后需要进行多次查找（很常见的模式），也完全可以尝试排序后使用二分查找。甚至在元素数量很少的时候，使用&lt;code&gt;List&amp;lt;KeyValuePair&amp;lt;TKey, TValue&amp;gt;&amp;gt;&lt;/code&gt;保存对象，而在需要读写的时候进行线性查找，效率也不会差。尽管这里的时间复杂度会是&lt;code&gt;O(log(N))&lt;/code&gt;甚至&lt;code&gt;O(N)&lt;/code&gt;，但对于实际开发来说，算法除了“时间复杂度”还有“常数”的因素在里面。使用节省内存的实现方式，更可能会影响到GC的效率，这也是托管程序性能重要方面。&lt;/p&gt;

&lt;p&gt;尽管如此，但这样的“问题”还是会到处出现。例如《基本要领》里面提到，他们在对Visual Studio和新编译器进行Profiling时，发现有大量的字典只保存了一个元素——甚至是空的。&lt;/p&gt;

&lt;p&gt;上周我们在做Profiling时，也发现程序里一个被密集调用的算法使用了字典保持临时状态，但是在绝大部分情况里，这个字典里面只有5到6个元素，此时使用字典就有些得不偿失了。事实上，那个算法在绝大部分情况下，字典里的元素数量都是可以预知的，只有极少数情况下会超出。因此，算法可以修改为：预先获得元素数量，假如小于一个阈值，则使用普通的数组来保存元素，需要时进行线性查找。虽然这个算法还有更激进的优化手段（性能热点怎么优化都不过分），但现在这种则是最容易，也最安全的做法。&lt;/p&gt;

&lt;p&gt;而在.NET框架里也用到了类似的实践。例如为了解决之前也在“赵人希”上提到过的&lt;a href="http://zrx.zhaojie.me/20140613/"&gt;死锁问题&lt;/a&gt;，我看了&lt;a href="http://referencesource.microsoft.com/#WindowsBase/src/Base/System/ComponentModel/PropertyChangedEventManager.cs"&gt;&lt;code&gt;PropertyChangedEventManager&lt;/code&gt;类的实现&lt;/a&gt;，其中便用到了&lt;a href="http://msdn.microsoft.com/en-us/library/system.collections.specialized.hybriddictionary(v=vs.110).aspx"&gt;&lt;code&gt;HybridDictionary&lt;/code&gt;类&lt;/a&gt;，内部会根据元素数量来切换使用&lt;code&gt;ListDictionary&lt;/code&gt;或哈希表来保存数据。&lt;/p&gt;

&lt;p&gt;最后再推荐一篇文章吧：《&lt;a href="http://www.cnblogs.com/gaochundong/p/3813252.html"&gt;常用数据结构及复杂度&lt;/a&gt;》，里面以.NET里的实现为基础，介绍了常用容器各操作的特征。这东西对于一个合格的程序员来说必须是烂熟于心的。其实这东西也完全不用去背，因为这些基础数据结构和算法实在是太容易理解了，几乎只要知道它是怎样一种结构，各特征都可以很快推断出来。&lt;/p&gt;

&lt;p&gt;之前我在微博上抱怨过遇到如何如何不靠谱的面试者，连基本的&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;是怎么存放元素的都搞不清是怎么一回事，居然还有人说这是在考“背诵”，这些细节不重要云云。对此我只想说：既然你就这点追求，那就一辈子老老实实写那些土鳖程序吧，呵呵呵。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2014/07/how-many-elements-in-your-dictionary.html#comments</comments>
      <pubDate>Sat, 12 Jul 2014 23:42:01 GMT</pubDate>
      <lastBuildDate>Sat, 12 Jul 2014 23:53:24 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>逆泛型执行器</title>
      <link>http://blog.zhaojie.me/2014/05/zrx-quiz-1-answer.html</link>
      <guid>http://blog.zhaojie.me/2014/05/zrx-quiz-1-answer.html</guid>
      <description>&lt;p&gt;话说微信公众账号上的&lt;a href="http://zrx.zhaojie.me/20140515/"&gt;第一期有奖征答&lt;/a&gt;活动发布至今已有两周时间，不过参与人数寥寥，是太难，还是奖品不够吸引人？大家要多参与，我们才能长期互动嘛。现在我就对第一期的题目“逆泛型执行器”进行简单讲解吧，其实这题很简单，以后类似难度的题目可能会放在“快速问答”环节中。话说&lt;a href="http://zrx.zhaojie.me/20140525/"&gt;第一期的快速问答&lt;/a&gt;还在进行之中，大家加油。&lt;/p&gt;

&lt;h1&gt;参考解答&lt;/h1&gt;

&lt;p&gt;所谓“逆泛型”，即我们希望可以在一个泛型操作中，只对特定的类型组合进行响应。例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;TicksToDateTimeCaller &lt;/span&gt;{

    &lt;span style="color: blue"&gt;private static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DateTime &lt;/span&gt;TicksToDateTime(&lt;span style="color: blue"&gt;long &lt;/span&gt;ticks) {
        &lt;span style="color: blue"&gt;return new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DateTime&lt;/span&gt;(ticks);
    }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;TResult Call&amp;lt;T, TResult&amp;gt;(T arg) {
        &lt;span style="color: blue"&gt;return &lt;/span&gt;(TResult)(&lt;span style="color: blue"&gt;object&lt;/span&gt;)TicksToDateTime((&lt;span style="color: blue"&gt;long&lt;/span&gt;)(&lt;span style="color: blue"&gt;object&lt;/span&gt;)arg);
    }
}&lt;/pre&gt;


&lt;p&gt;以上代码会产生无谓的代码转换及装箱拆箱操作（尽管它们在 Release 模式下会被优化掉），为了避免这点，我们可以这么做：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;TicksToDateTimeCaller &lt;/span&gt;{

    &lt;span style="color: blue"&gt;private static class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Cache&lt;/span&gt;&amp;lt;T, TResult&amp;gt; {
        &lt;span style="color: blue"&gt;public static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;T, TResult&amp;gt; Call;
    }

    &lt;span style="color: blue"&gt;private static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DateTime &lt;/span&gt;TicksToDateTime(&lt;span style="color: blue"&gt;long &lt;/span&gt;ticks) {
        &lt;span style="color: blue"&gt;return new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DateTime&lt;/span&gt;(ticks);
    }

    &lt;span style="color: blue"&gt;static &lt;/span&gt;TicksToDateTimeCaller() {
        &lt;span style="color: #2b91af"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;long&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;DateTime&lt;/span&gt;&amp;gt;.Call = TicksToDateTime;
    }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;TResult Call&amp;lt;T, TResult&amp;gt;(T arg) {
        &lt;span style="color: blue"&gt;return &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Cache&lt;/span&gt;&amp;lt;T, TResult&amp;gt;.Call(arg);
    }
}&lt;/pre&gt;


&lt;p&gt;我们创建了一个内部类 &lt;code&gt;Cache&lt;/code&gt;，它起到了缓存的作用。.NET 泛型的奇妙之处便在于其“动态”及“区分”。“动态”在于它可以于运行时进行具体化（相对于 C++ 里的“静态”），不过目前的问题不涉及这点。而“区分”则意味着不同的具体泛型参数，在 .NET 中都是不同的类型，拥有完全分离的元数据，例如方法表（Method Table），以及静态字段等等。&lt;/p&gt;

&lt;p&gt;这里我们便利用了这一点。由于我们只针对特定类型组合的 &lt;code&gt;Cache&lt;/code&gt; 类型设置其 &lt;code&gt;Call&lt;/code&gt; 字段，于是其他的类型组合自然就会直接抛出异常了。值得注意的是，也正是由于“区分”，不同的具体化类型拥有不同的元数据。因此，假如这个方法会遭遇大量非法调用的话，最好在访问 &lt;code&gt;Cache&amp;lt;T, TResult&amp;gt;&lt;/code&gt; 之前进行类型判断，并直接抛出异常，这样可以避免产生无用的元数据。&lt;/p&gt;

&lt;p&gt;之前有人问，为什么不可以用 Java 来实现呢？要知道 .NET 的泛型岂是 Java 的“伪泛型”可以相提并论的。&lt;/p&gt;

&lt;h1&gt;推广用法&lt;/h1&gt;

&lt;p&gt;这种做法还可以推广开来。例如在我目前的项目中用到一个第三方类库，它提供了一条条记录，我们可以读取其各字段的值，API 如下方 &lt;code&gt;IRecord&lt;/code&gt; 接口所示：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af"&gt;IRecord &lt;/span&gt;{
    &lt;span style="color: blue"&gt;string &lt;/span&gt;GetString(&lt;span style="color: blue"&gt;string &lt;/span&gt;field);
    &lt;span style="color: blue"&gt;int &lt;/span&gt;GetInt(&lt;span style="color: blue"&gt;string &lt;/span&gt;field);
    &lt;span style="color: blue"&gt;long &lt;/span&gt;GetLong(&lt;span style="color: blue"&gt;string &lt;/span&gt;field);
}&lt;/pre&gt;


&lt;p&gt;但这个 API 在使用上并不友好，我们更期望可以有一个通用的 &lt;code&gt;Get&amp;lt;T&amp;gt;&lt;/code&gt; 方法，可以用来读取各种类型。于是我们便可以如此来编写一个扩展方法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;public static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;RecordExtensions &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;private static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T&amp;gt; {
        &lt;span style="color:blue;"&gt;public static &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;, T&amp;gt; Get;
    }

    &lt;span style="color:blue;"&gt;static &lt;/span&gt;RecordExtensions() {
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;string&lt;/span&gt;&amp;gt;.Get = (record, field) =&amp;gt; record.GetString(field);
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;int&lt;/span&gt;&amp;gt;.Get = (record, field) =&amp;gt; record.GetInt(field);
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;long&lt;/span&gt;&amp;gt;.Get = (record, field) =&amp;gt; record.GetLong(field);
    }

    &lt;span style="color:blue;"&gt;public static &lt;/span&gt;T Get&amp;lt;T&amp;gt;(&lt;span style="color:blue;"&gt;this &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;IRecord &lt;/span&gt;record, &lt;span style="color:blue;"&gt;string &lt;/span&gt;field) {
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T&amp;gt;.Get(record, field);
    }
}&lt;/pre&gt;


&lt;p&gt;事实上，使用 Lambda 表达式会生成额外的间接调用，我们直接使用 &lt;code&gt;CreateDelegate&lt;/code&gt; 方法可以进一步降低开销。当然，这属于极小的优化，但既然不麻烦，又何乐而不为呢：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;public static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;ReflectionExtensions &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;public static &lt;/span&gt;TDelegate CreateDelegate&amp;lt;TDelegate&amp;gt;(&lt;span style="color:blue;"&gt;this &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;MethodInfo &lt;/span&gt;method) {
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;(TDelegate)(&lt;span style="color:blue;"&gt;object&lt;/span&gt;)&lt;span style="color:#2b91af;"&gt;Delegate&lt;/span&gt;.CreateDelegate(&lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(TDelegate), method);
    }
}

&lt;span style="color:blue;"&gt;public static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;RecordExtensions &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;private static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T&amp;gt; {
        &lt;span style="color:blue;"&gt;public static &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;, T&amp;gt; Get;
    }

    &lt;span style="color:blue;"&gt;static &lt;/span&gt;RecordExtensions() {
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;string&lt;/span&gt;&amp;gt;.Get = &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;).GetMethod(&lt;span style="color:#a31515;"&gt;"GetString"&lt;/span&gt;).CreateDelegate&amp;lt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;&amp;gt;&amp;gt;();
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;int&lt;/span&gt;&amp;gt;.Get = &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;).GetMethod(&lt;span style="color:#a31515;"&gt;"GetInt"&lt;/span&gt;).CreateDelegate&amp;lt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;, &lt;span style="color:blue;"&gt;int&lt;/span&gt;&amp;gt;&amp;gt;();
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;long&lt;/span&gt;&amp;gt;.Get = &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;).GetMethod(&lt;span style="color:#a31515;"&gt;"GetLong"&lt;/span&gt;).CreateDelegate&amp;lt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;, &lt;span style="color:blue;"&gt;long&lt;/span&gt;&amp;gt;&amp;gt;();
    }

    &lt;span style="color:blue;"&gt;public static &lt;/span&gt;T Get&amp;lt;T&amp;gt;(&lt;span style="color:blue;"&gt;this &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;IRecord &lt;/span&gt;record, &lt;span style="color:blue;"&gt;string &lt;/span&gt;field) {
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T&amp;gt;.Get(record, field);
    }
}&lt;/pre&gt;


&lt;p&gt;作为一个主要工作是写基础代码给别人用的人，我还真积累了不少编写 API 的有趣经验，有机会慢慢分享。这里先来一发，那就是使用 &lt;code&gt;out&lt;/code&gt; 关键字来减少类型信息——谁让 C# 只能通过参数进行类型推断呢？&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;public static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;ReflectionExtensions &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;public static void &lt;/span&gt;CreateDelegate&amp;lt;TDelegate&amp;gt;(&lt;span style="color:blue;"&gt;this &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;MethodInfo &lt;/span&gt;method, &lt;span style="color:blue;"&gt;out &lt;/span&gt;TDelegate result) {
        result = (TDelegate)(&lt;span style="color:blue;"&gt;object&lt;/span&gt;)&lt;span style="color:#2b91af;"&gt;Delegate&lt;/span&gt;.CreateDelegate(&lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(TDelegate), method);
    }
}

&lt;span style="color:blue;"&gt;public static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;RecordExtensions &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;private static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T&amp;gt; {
        &lt;span style="color:blue;"&gt;public static &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;, T&amp;gt; Get;
    }

    &lt;span style="color:blue;"&gt;static &lt;/span&gt;RecordExtensions() {
        &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;).GetMethod(&lt;span style="color:#a31515;"&gt;"GetString"&lt;/span&gt;).CreateDelegate(&lt;span style="color:blue;"&gt;out &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;string&lt;/span&gt;&amp;gt;.Get);
        &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;).GetMethod(&lt;span style="color:#a31515;"&gt;"GetInt"&lt;/span&gt;).CreateDelegate(&lt;span style="color:blue;"&gt;out &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;int&lt;/span&gt;&amp;gt;.Get);
        &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;IRecord&lt;/span&gt;).GetMethod(&lt;span style="color:#a31515;"&gt;"GetLong"&lt;/span&gt;).CreateDelegate(&lt;span style="color:blue;"&gt;out &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;long&lt;/span&gt;&amp;gt;.Get);
    }

    &lt;span style="color:blue;"&gt;public static &lt;/span&gt;T Get&amp;lt;T&amp;gt;(&lt;span style="color:blue;"&gt;this &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;IRecord &lt;/span&gt;record, &lt;span style="color:blue;"&gt;string &lt;/span&gt;field) {
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T&amp;gt;.Get(record, field);
    }
}&lt;/pre&gt;


&lt;p&gt;再留个问题：参考解答中的 &lt;code&gt;TicksToDateTime&lt;/code&gt; 方法是静态方法，那假如我们需要调用的是一个实例方法又该怎么做？注意，这里不允许在每个对象的构造函数里创建独立的委托对象，因为这个操作的开销太大。创建一个静态的对象不过是一次性工作，而创建大量的对象则会造成十分可观的开销了。&lt;/p&gt;

&lt;p&gt;没想出来？举一反三的能力必须加强啊。&lt;/p&gt;

&lt;h1&gt;其他答案&lt;/h1&gt;

&lt;p&gt;这个问题只收到的答案寥寥无几。有的比较无厘头，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;public class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;TicksToDateTimeCaller &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;private static dynamic &lt;/span&gt;TicksToDateTime(&lt;span style="color:blue;"&gt;dynamic &lt;/span&gt;ticks) {
        &lt;span style="color:blue;"&gt;return new &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;DateTime&lt;/span&gt;(ticks);
    }

    &lt;span style="color:blue;"&gt;public &lt;/span&gt;TResult Call&amp;lt;T, TResult&amp;gt;(T arg) {
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;(TResult)TicksToDateTime(arg);
    }
}&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;dynamic&lt;/code&gt; 怎么能解决装箱拆箱问题？一定要记住，&lt;code&gt;dynamic&lt;/code&gt; 等同于 &lt;code&gt;object&lt;/code&gt;，它只是在访问的时候，会由编译器生成额外负责动态调用的代码而已。事实上，这方面的开销可不仅仅是装箱拆箱，不信用 ILSpy 反编译看看？我们不能如此简单地望文生义。&lt;/p&gt;

&lt;p&gt;还有个答案较为有趣，虽然会有额外的开销，但这个思路还是比较有参考意义的，于是这次的大奖就发给他了：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;public class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Parser&lt;/span&gt;&amp;lt;T, TResult&amp;gt; {

    &lt;span style="color:blue;"&gt;public static readonly &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;T, TResult&amp;gt; Func = Emit();

    &lt;span style="color:blue;"&gt;private static &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;T, TResult&amp;gt; Emit() {
        &lt;span style="color:blue;"&gt;var &lt;/span&gt;method = &lt;span style="color:blue;"&gt;new &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;DynamicMethod&lt;/span&gt;(&lt;span style="color:blue;"&gt;string&lt;/span&gt;.Empty, &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(TResult), &lt;span style="color:blue;"&gt;new&lt;/span&gt;[] { &lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(T) });
        &lt;span style="color:blue;"&gt;var &lt;/span&gt;il = method.GetILGenerator();
        il.Emit(&lt;span style="color:#2b91af;"&gt;OpCodes&lt;/span&gt;.Ldarg_0);
        il.Emit(&lt;span style="color:#2b91af;"&gt;OpCodes&lt;/span&gt;.Ret);
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;T, TResult&amp;gt;)method.CreateDelegate(&lt;span style="color:blue;"&gt;typeof&lt;/span&gt;(&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;T, TResult&amp;gt;));
    }
}

&lt;span style="color:blue;"&gt;public class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;TicksToDateTimeCaller &lt;/span&gt;{

    &lt;span style="color:blue;"&gt;private static &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;DateTime &lt;/span&gt;TicksToDateTime(&lt;span style="color:blue;"&gt;long &lt;/span&gt;ticks) {
        &lt;span style="color:blue;"&gt;return new &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;DateTime&lt;/span&gt;(ticks);
    }

    &lt;span style="color:blue;"&gt;public &lt;/span&gt;TResult Call&amp;lt;T, TResult&amp;gt;(T arg) {
        &lt;span style="color:blue;"&gt;return &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Parser&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;DateTime&lt;/span&gt;, TResult&amp;gt;.Func(TicksToDateTime(&lt;span style="color:#2b91af;"&gt;Parser&lt;/span&gt;&amp;lt;T, &lt;span style="color:blue;"&gt;long&lt;/span&gt;&amp;gt;.Func(arg)));
    }
}&lt;/pre&gt;


&lt;p&gt;还有个同学给出了类似的做法，他受到 StackOverflow 上&lt;a href="http://stackoverflow.com/questions/16259177/how-to-avoid-boxing-unboxing-when-using-generics-in-c"&gt;这个问题&lt;/a&gt;的启发，给出了如下的做法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;private static class &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;T, TResult&amp;gt; {

    &lt;span style="color:blue;"&gt;public static &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Func&lt;/span&gt;&amp;lt;T, TResult&amp;gt; Call;

    &lt;span style="color:blue;"&gt;static &lt;/span&gt;Cache() {
        &lt;span style="color:#2b91af;"&gt;Cache&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;long&lt;/span&gt;, &lt;span style="color:#2b91af;"&gt;DateTime&lt;/span&gt;&amp;gt;.Call = TicksToDateTime;
    } 
}&lt;/pre&gt;


&lt;p&gt;可惜的是，初始化 &lt;code&gt;Call&lt;/code&gt; 的代码放错了位置，且经过提醒还是未能发现问题。我认为这意味着并没有完全搞清楚代码的机制，因此只能给个小奖了。&lt;/p&gt;

&lt;p&gt;最后，欢迎大家关注我的公众账号“&lt;a href="http://zrx.zhaojie.me/"&gt;赵人希&lt;/a&gt;”，有技术有生活&lt;del&gt;，深入刻画了本人在娱乐圈内的起起伏伏&lt;/del&gt;。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2014/05/zrx-quiz-1-answer.html#comments</comments>
      <pubDate>Wed, 28 May 2014 23:25:17 GMT</pubDate>
      <lastBuildDate>Wed, 28 May 2014 23:51:47 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>.NET程序性能的基本要领</title>
      <link>http://blog.zhaojie.me/2014/05/essential-dotnet-perf-truths-tips.html</link>
      <guid>http://blog.zhaojie.me/2014/05/essential-dotnet-perf-truths-tips.html</guid>
      <description>&lt;p&gt;说起&lt;a href="http://roslyn.codeplex.com/"&gt;Roslyn&lt;/a&gt;大家肯定都已经有所耳闻了，这是下一代C#和VB.NET的编译器实现。Roslyn使用纯托管代码开发，但性能超过之前使用C++编写的原生实现。Bill Chiles是Roslyn的PM（程序经理，Program Manager），他最近写了一篇文章叫做《&lt;a href="http://download-codeplex.sec.s-msft.com/Download?ProjectName=roslyn&amp;amp;DownloadId=838017"&gt;Essential Performance Facts and .NET Framework Tips&lt;/a&gt;》，其中总结了几条经验，目前是个CodePlex上的PDF文件，以后可能会发布在MSDN上。&lt;/p&gt;

&lt;p&gt;他在文章里谈到以下几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不要进行过早优化。程序员有了一定经验以后，往往会对性能有所直觉，但也要避免盲目优化。&lt;/li&gt;
&lt;li&gt;没有评测，便是猜测。例如，有的时候重复计算都比使用哈希表进行缓存来的快。&lt;/li&gt;
&lt;li&gt;好工具很重要。这里他推荐了&lt;a href="http://blogs.msdn.com/b/dotnet/archive/2012/10/09/improving-your-app-s-performance-with-perfview.aspx"&gt;PerfView&lt;/a&gt;，这是个微软发布的免费工具，将来分析某些案例时我可能也会用到这个工具。&lt;/li&gt;
&lt;li&gt;性能的关键，在于内存分配。凭直觉可能很多人会觉得编译器是一个CPU密集型的场景，但实际上它终究还是个IO密集型的程序。&lt;/li&gt;
&lt;li&gt;其他一些细节。例如，对于字典的内存开销要有一些概念，还有例如我每次面试都会问到的class与struct的区别等等。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;第4点值得多说几句。对于托管环境来说，GC对于性能的影响重大。假如一段程序写的不够GC友好，让GC发生的多，尤其是那种Stop-the-World GC，这对性能的影响远胜某些“多花了几条拷贝指令”之类的“探索”。而且很多时候，用户眼中的“性能”在于程序的“响应程度（responsiveness）”，一旦GC暂停了所有的线程，程序便很容易发生卡顿，这甚至不是通过简单评测程序性能能够体现出来的。&lt;/p&gt;

&lt;p&gt;相较于Java平台来说，.NET已经是个相对GC友好的运行环境了。其中最重要的方面之一便是自定义值类型，即struct。struct让程序员进行一定程度上可控的内存分配，避免在堆上产生对象。而在Java中，只有几种原生类型是值类型，它们还不能包含成员。要知道在Java里无法使用一个未装箱的int值作为一个字典的键，这对一个.NET程序员来说可能很难想象，但事实便是如此。&lt;/p&gt;

&lt;p&gt;当然，&lt;a href="http://cr.openjdk.java.net/~jrose/values/values-0.html"&gt;Java似乎已经有打算作这方面的改进&lt;/a&gt;，但离真正可用还遥遥无期。目前Java只能通过一些如逃逸分析的手段，发现某个对象不会被共享到堆上，于是便将其分配在栈上，避免对GC产生压力。&lt;/p&gt;

&lt;p&gt;不过.NET提供再多对GC友好的功能，也抵不过开发人员的误用。Bill的文章里举了一些常见案例，这些其实都是每个.NET开发人员必须了解的基础。最后那个例子颇为有趣，他谈到，对于性能敏感的地方，有时候都要避免LINQ或Lambda。因为使用Lambda构造匿名函数时，编译器会产生闭包，因为所谓闭包，便是一个用来保存上下文的，分配在堆上的对象。此外，如&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;的迭代器被有意实现为struct，但使用通用的LINQ接口，则会被转化为&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;IEnumerator&amp;lt;T&amp;gt;&lt;/code&gt;，进而产生装箱。&lt;/p&gt;

&lt;p&gt;无独有偶，不久前&lt;a href="http://weibo.com/lianchengzju"&gt;@连城404&lt;/a&gt;在新浪微博上说到：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;按照Michael的建议把HiveTableScan关键路径上的FP风格的代码换成while循环加可复用的mutable对象，扫表性能提升40%。”，这其实也正和这次的话题密切相关。&lt;/p&gt;

&lt;p&gt;半夜不清醒，四则运算都算错了…发上条微博的时候实际上是提升了100%多点。之后继续蚊子腿上刮肉，不光是while循环，关键路径上的模式匹配代码也能刮出油水（例如省掉Array.unapplySeq调用开销）。目前使用LazySimpleSerDe的普通CVS表扫表性能提到2.2x，RCFile加上列剪枝可以提到3x。#Spark SQL#&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;而&lt;a href="http://en.wikiquote.org/wiki/Alan_Perlis"&gt;Alan Perlis&lt;/a&gt;同样说过：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Lisp programmers know the value of everything but the cost of nothing.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;可谓颇为有趣。常用的FP手段的确会带来性能开销，这是事实，不过假如你现在立即得出“不要用FP”或“还好没学FP”这样的结论，那我也只能用怜悯的眼光看着你了。&lt;/p&gt;

&lt;p&gt;最后，您有减少内存分配，优化GC这方面的实践吗？不妨联系我吧，有机会我也会谈一下我在这方面的一些技巧和案例的。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2014/05/essential-dotnet-perf-truths-tips.html#comments</comments>
      <pubDate>Wed, 14 May 2014 22:18:51 GMT</pubDate>
      <lastBuildDate>Wed, 14 May 2014 22:24:51 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/news/">新闻信息</category>
      <category domain="http://blog.zhaojie.me/life/">生活心情</category>
      <title>在香港生活的初步感受</title>
      <link>http://blog.zhaojie.me/2013/09/hongkong-life-first-impression.html</link>
      <guid>http://blog.zhaojie.me/2013/09/hongkong-life-first-impression.html</guid>
      <description>&lt;p&gt;好久没有更新博客了，主要是生活产生了一些变化。我这人比较没出息，生活稳定的时候，不论是工作和学习都会有条不紊，但一旦有所动荡，则就会心神不宁，啥事都做不进去，效率也一落千丈，比如Coursera上的基本课程也拉下了。这段时间比较重大的变化有两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;与女友领证了。&lt;/li&gt;
&lt;li&gt;在香港工作了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两件事其实是相关的。相信不少同学都知道&lt;a href="http://blog.zhaojie.me/2011/07/ibm-interview.html"&gt;我当年去IBM深圳&lt;/a&gt;的主要原因之一，就是看重这是个和JPMC的合作项目，两年后有机会可以去香港。可惜两年期满，这计划却黄了，幸好我还是为自己争取到了这样的机会。我去香港JPMC是三个月前便确定的，但直到最后一刻才正式对外公开。这事情带给我颇多感触，以后有机会再细谈。至于领证什么的，其实就是因为需要把前女友/现老婆作为受养人带去香港居住。&lt;/p&gt;

&lt;p&gt;我现在已经在香港租好了房子，许多东西也已经从深圳的住处搬过去了，是一家看上去很高级的搬家公司，经常做跨境搬家，会接触很多老外，费用自然由JPMC全包。房子在屯门市中心，那是个离深圳湾口岸只有15~20分钟车程的地方，地处新界，与港岛上的各经济/商业中心距离较远，但也算是一个比较繁华的商业区，各大品牌一应俱全，每天都有许多住在深圳的人来此购物，十分热闹。住处离我新单位，旧单位（有时还需要回去），以及我老婆的工作单位都需要一个小时多一点，还算能够接受，但毕竟再也不会有每天八点半起床，九点到公司的美好生活了。&lt;/p&gt;

&lt;p&gt;房租每月$8.5K，比我之前&lt;a href="http://blog.zhaojie.me/2013/07/china-hongkong-taxing-comparison.html"&gt;$12K的预算&lt;/a&gt;便宜了不少，所以我正在考虑是不是用这个差价分期买个钢琴什么的。房间很小，使用面积只有33.1平方米，却划成两室一厅，卧室连一张1.5米宽的双人床都放不下，逛家具市场时，发现香港双人床的标准尺寸是1.35米，一开始还真令人难以接受。现在想想，传说中香港“千呎豪宅”也不过100平方米左右（除以10.4），而在找房中介嘴里600多呎都已经算是“豪宅”了，可见香港人的住房是多么紧张。&lt;/p&gt;

&lt;p&gt;房间虽小，房型倒也不错，所以住下来不如听上去那么紧张。例如其中一个小房间虽说只有不到5平方米，但作为书房刚刚好。香港的房子大都是空房，只带极少的家具，我租的房子更可以用“家徒四壁”来形容。这几天请了假，跟着老婆到处跑，订了许多家具，离完全布置好还有一段距离。房间朝向很不错，三面窗都朝正南，阳光充沛，有山有水。按照房东的说法，这间房的风水不错，儿子在这里住了18年，现在已经买了大房。这里先上两张从窗外拍出去的照片：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/hongkong-life-first-impression/1.jpg"&gt;&lt;img alt="窗外1" src="http://img.zhaojie.me/blog/hongkong-life-first-impression/1.jpg" width="450" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/hongkong-life-first-impression/2.jpg"&gt;&lt;img alt="窗外2" src="http://img.zhaojie.me/blog/hongkong-life-first-impression/2.jpg" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;窗外可以看到一些运动场地，还有个游泳池，这都是住户可以免费或优惠使用的，例如游泳$20一次，可惜马上就要关闭了，只能明年再用了：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/hongkong-life-first-impression/3.jpg"&gt;&lt;img alt="窗外3" src="http://img.zhaojie.me/blog/hongkong-life-first-impression/3.jpg" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至于日常生活开销，我真不这么觉得香港比国内高多少。经过我这段时间的观察，我认为同等质量的东西，香港的价格甚至往往会低过国内，只是国内你可以买到质量很差但的确更便宜的东西。例如这几天我在香港买水果，在Taste这样的高端超市，$10可以买到3个黄猕猴桃或4个绿猕猴桃，昨天买的8个橙子才$12.4，质量跟深圳的“百果园”等高级水果店相比则差不多，但价格却便宜得多（注意HKD还要乘0.8才是RMB哟）。我在深圳的时候，三天两头去“百果园”或“鲜果100”买水果，随随便便便能花上2、30块钱，三下五除二便能吃完。当然东西的确好吃，像普通的水果铺或是沃尔玛可以买到的便宜水果，我已经不愿尝试了。&lt;/p&gt;

&lt;p&gt;同样道理，我在深圳出去吃饭，包括每天的工作餐，几乎从来不低于人均30，跟老婆两个人出去点几个菜，也随随便便就能上200块钱。国内当然有便宜的小店，但是我不敢吃，怕有地沟油，因此就便宜不下去。反之在香港出差时，公司周围的小店挑一家就敢吃，随便一个$40到$50的套餐，东西不错分量也大。此外在Taste里面还可以买到$60一大份的寿司拼盘（见下图），不到$15一磅（0.9斤）的猪脚等等，我拍下照片给父母看，他们也表示香港的东西原来这么便宜。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/hongkong-life-first-impression/4.jpg"&gt;&lt;img alt="寿司" src="http://img.zhaojie.me/blog/hongkong-life-first-impression/4.jpg" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这年头人民币一边对内通货膨胀，一边对外升值，平心而论其实国内的工资水平和生活成本已经很高了，稍微追求点生活质量的话，开销就刷刷刷地赶英超美。因此之前在&lt;a href="http://blog.zhaojie.me/2013/07/china-hongkong-taxing-comparison.html"&gt;计算香港和大陆的交税问题时&lt;/a&gt;，我只考虑了香港的房价，而普通生活开销并没有算进去，因为两边其实差别不大。当然，香港也有一些贵的东西，一是些再便宜质量差距也不大的小东西，二是交通，三是服务业或生活娱乐设施，例如KTV等等。幸好，屯门离&lt;del&gt;东莞&lt;/del&gt;深圳很近，真有需要直接去深圳逍遥一番。&lt;/p&gt;

&lt;p&gt;最后再来说说香港的网络。墙不墙的问题就不提了，这是我测出的连接香港本地服务器的速度：&lt;/p&gt;

&lt;p&gt;&lt;img alt="网速" src="http://img.zhaojie.me/blog/hongkong-life-first-impression/5.png" width="649" /&gt;&lt;/p&gt;

&lt;p&gt;我用的是&lt;a href="http://www.netvigator.com/chi/"&gt;PCCW的“网上行”&lt;/a&gt;，光纤入户，对称300Mbps带宽，每月$208，此外还有500M和1G带宽可供选择，但我还是想一步步来。连香港本地服务可以用满带宽，但好像需求不大，而连其他地区的服务时瓶颈基本上就在对方了。例如，我试下来用迅雷下载可以保持在每秒1MB的下载速度，有些时候能达到每秒4~5MB，而上Youtube之类的视频站看高清视频也毫无压力。之前还考察过“香港宽频”的服务，的确更实惠一些，但看了下香港本地网站上的评价，似乎访问大陆时是龟速，于是作罢，还是花钱买安心吧，毕竟一下子就要签两年。总体而言，我对目前的网络状况十分满意，毕竟是从深圳4Mbps的小水管过来的，还要￥140一个月。香港不愧是&lt;a href="http://www.akamai.com/html/about/press/releases/2012/press_080912.html"&gt;网速世界第三的地区&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;移动通讯的选择比屋内宽带更加丰富多彩，香港有许多家运营商，竞争激烈，因此对消费者有利。几乎每个运营商都会有每月$100左右的套餐，包无限的3G Lite流量，最高速度384Kbps，用来刷微博刷网页基本够用。目前我用的是联通香港的一卡双号，原价每月$120，目前优惠期是$68，一卡双号，信号似乎还算不错。香港已经进入了4G时代，速率150Mbps，一般都是包2G到5G流量。例如中国移动香港的套餐之一，是每月$158，包5G的高速流量，超过之后只能使用1Mbps带宽，但流量无限，直到下月。有了4G网络，真正算是进入了移动互联时代，可以直接在手机或平板上看高清视频，但我似乎还没有这习惯，因此我这段时间一直是用手机共享热点给iPad使用，因此还是比在深圳省下不少。&lt;/p&gt;

&lt;p&gt;总体而言，目前我对香港的生活还比较满意，比当时从上海到深圳的感觉好不少。当然，香港的工作节奏的确很快，早上地铁里人人埋头走路的情景令人印象深刻。我不太喜欢改变，因此选择香港，毕竟离深圳很近，与国内的生活习惯也比较相似，算是一个不错的过渡，可以想清楚接下来是继续往外跑还是留在国内，这也是为什么相比美帝我更倾向于香港的原因。美帝工资贫富差距不大，去美帝容易但拿高薪难，再加上税收高，其实也难有很多结余。而且去了美帝之后，老婆也得放弃工作，万一尝试下来感觉不好，耗费的成本就太高了。我还是不太愿意冒这个险，所以也一直没有去认真尝试美帝的机会。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/09/hongkong-life-first-impression.html#comments</comments>
      <pubDate>Mon, 02 Sep 2013 10:23:52 GMT</pubDate>
      <lastBuildDate>Thu, 05 Sep 2013 11:21:36 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/life/">生活心情</category>
      <title>比较下中国大陆和香港之间的个税差异</title>
      <link>http://blog.zhaojie.me/2013/07/china-hongkong-taxing-comparison.html</link>
      <guid>http://blog.zhaojie.me/2013/07/china-hongkong-taxing-comparison.html</guid>
      <description>&lt;p&gt;一直听说中国大陆个税税率之高，但一直没有跟哪儿作过比较，最近听说香港的税率很低，因此也想具体比较一下到底会差多少。单从数字上看，两者简直天差地远。例如，同样是累进税率，大陆从月入8K开始的部分就要缴纳20%的税率，超过38.5K则是30%，而香港最高也就只有17%。当然，比如香港租房之贵也遥遥领先于大陆一线城市，但房租亦可作为征税前的减免。正因为如此复杂，我们还是需要进行详细的计算才能有直观的概念，这里我就来尝试一下。这里以一对夫妻为例，但只计算其中一人的薪资，以传说中阿里P8级别的上限：月入5w人民币（年入60w），即月入6.25w港币（年入75w）为标准。当然，这只是对我比较有参考意义的数字，您也可以根据自己的标准来重新计算。&lt;/p&gt;

&lt;h1&gt;大陆&lt;/h1&gt;

&lt;p&gt;首先我们来计算中国大陆的个税。众所周知，在征收个税之前还要扣除社保和住房公积金，其中后者并非所有城市都有。这方面，不同城市有不同的规定，我这里以&lt;a href="http://bsy.sz.bendibao.com/bsyDetail/3352.html"&gt;非深圳户口，但在深圳工作的人员为例&lt;/a&gt;。以深圳目前的标准来说，2013年7月1日起采用的社会平均工资为4918元（下表简称A，3A即为三倍社会平均工资），于是：&lt;/p&gt;

&lt;table cellspacing="0" cellpadding="5" border="1"&gt;&lt;thead&gt;
    &lt;tr&gt;
      &lt;th align="center"&gt;项目 &lt;/th&gt;

      &lt;th align="center"&gt;基数 &lt;/th&gt;

      &lt;th align="center"&gt;个人比例 &lt;/th&gt;

      &lt;th align="center"&gt;个人缴纳 &lt;/th&gt;

      &lt;th align="center"&gt;单位比例 &lt;/th&gt;

      &lt;th align="center"&gt;单位缴纳&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;&lt;tbody&gt;
    &lt;tr&gt;
      &lt;td align="center"&gt;养老保险 &lt;/td&gt;

      &lt;td align="center"&gt;14754（3A） &lt;/td&gt;

      &lt;td align="center"&gt;8% &lt;/td&gt;

      &lt;td align="center"&gt;1180.32 &lt;/td&gt;

      &lt;td align="center"&gt;13% &lt;/td&gt;

      &lt;td align="center"&gt;1918.02&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;医疗保险 &lt;/td&gt;

      &lt;td align="center"&gt;4918（A） &lt;/td&gt;

      &lt;td align="center"&gt;2.2% &lt;/td&gt;

      &lt;td align="center"&gt;108.20 &lt;/td&gt;

      &lt;td align="center"&gt;7.8% &lt;/td&gt;

      &lt;td align="center"&gt;383.60&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;失业保险 &lt;/td&gt;

      &lt;td align="center"&gt;1600 &lt;/td&gt;

      &lt;td align="center"&gt;1% &lt;/td&gt;

      &lt;td align="center"&gt;16 &lt;/td&gt;

      &lt;td align="center"&gt;2% &lt;/td&gt;

      &lt;td align="center"&gt;32&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;工伤保险 &lt;/td&gt;

      &lt;td align="center"&gt;14754（3A） &lt;/td&gt;

      &lt;td align="center"&gt;0.4% &lt;/td&gt;

      &lt;td align="center"&gt;59.02 &lt;/td&gt;

      &lt;td align="center"&gt;- &lt;/td&gt;

      &lt;td align="center"&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;住房公积金方面，公司可以选择缴纳10%到40%之间的范围，其中个人和公司各缴一半。这里我认为大部分公司都不会愿意缴纳更多住房公积金（例如百度深圳也就不过13%），因此选择最低的10%为例（基数为五倍社会平均工资，即24590元）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;个人需缴纳5%，即1229.5元。 &lt;/li&gt;

  &lt;li&gt;单位需缴纳5%，即1229.5元。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在征收个税之前，需要从个人收入中扣除所有个人需缴纳的社保和住房公积金，即：&lt;/p&gt;

&lt;pre&gt;50000 - 1180.32 - 108.20 - 16 - 59.02 - 1229.5 = 47406.96&lt;/pre&gt;

&lt;p&gt;以&lt;a href="http://www.chachaba.com/news/tools/suodeshui/20111115/55577.html"&gt;大陆2011年调整后的最新个税税率&lt;/a&gt;，起征点为3500元，扣除之后的数目使用累进税率，标准为：&lt;/p&gt;

&lt;table cellspacing="0" cellpadding="5" border="1"&gt;&lt;thead&gt;
    &lt;tr&gt;
      &lt;th align="center"&gt;级别 &lt;/th&gt;

      &lt;th align="center"&gt;范围 &lt;/th&gt;

      &lt;th align="center"&gt;税率 &lt;/th&gt;

      &lt;th align="center"&gt;速算扣除数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;&lt;tbody&gt;
    &lt;tr&gt;
      &lt;td align="center"&gt;1 &lt;/td&gt;

      &lt;td align="center"&gt;(0, 1500] &lt;/td&gt;

      &lt;td align="center"&gt;3% &lt;/td&gt;

      &lt;td align="center"&gt;0&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;2 &lt;/td&gt;

      &lt;td align="center"&gt;(1500, 4500] &lt;/td&gt;

      &lt;td align="center"&gt;10% &lt;/td&gt;

      &lt;td align="center"&gt;105&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;3 &lt;/td&gt;

      &lt;td align="center"&gt;(4500, 9000] &lt;/td&gt;

      &lt;td align="center"&gt;20% &lt;/td&gt;

      &lt;td align="center"&gt;555&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;4 &lt;/td&gt;

      &lt;td align="center"&gt;(9000, 35000] &lt;/td&gt;

      &lt;td align="center"&gt;25% &lt;/td&gt;

      &lt;td align="center"&gt;1005&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;5 &lt;/td&gt;

      &lt;td align="center"&gt;(35000, 55000] &lt;/td&gt;

      &lt;td align="center"&gt;30% &lt;/td&gt;

      &lt;td align="center"&gt;2755&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;6 &lt;/td&gt;

      &lt;td align="center"&gt;(55000, 80000] &lt;/td&gt;

      &lt;td align="center"&gt;35% &lt;/td&gt;

      &lt;td align="center"&gt;5505&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
      &lt;td align="center"&gt;7 &lt;/td&gt;

      &lt;td align="center"&gt;(80000, +∞] &lt;/td&gt;

      &lt;td align="center"&gt;45% &lt;/td&gt;

      &lt;td align="center"&gt;13505&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;从47406.96扣除起征基数后，得到43906.96，属于30%那个级别，因征收30%的税率，因此需缴纳的税款为：&lt;/p&gt;

&lt;pre&gt;43906.96 * 30% - 2755 = 10417.09&lt;/pre&gt;

&lt;p&gt;因此，每月实际到手薪资为：&lt;/p&gt;

&lt;pre&gt;47406.96 - 10417.09 = 36989.87&lt;/pre&gt;

&lt;p&gt;假设每月花费3000元租房（便于跟香港进行比较），则扣除房租后的现金收入为：&lt;/p&gt;

&lt;pre&gt;36989.87 - 3000 = 33989.87&lt;/pre&gt;

&lt;p&gt;扣除年租后年入（现金）总额为：&lt;/p&gt;

&lt;pre&gt;33989.87 * 12 = 407878.44&lt;/pre&gt;

&lt;p&gt;住房公积金账户上则会进账：&lt;/p&gt;

&lt;pre&gt;(1229.5 + 1229.5) * 12 = 29508&lt;/pre&gt;

&lt;p&gt;每年社保卡上则会进账：&lt;/p&gt;

&lt;pre&gt;(108.20 + 383.60) * 12 = 5901.6&lt;/pre&gt;

&lt;p&gt;而养老、失业、工伤保险可以认为全部送给国家统筹安排。这里我们来做一个最为理想的假设，即把所有社保卡及住房公积金算进个人收入，则年总收入为：&lt;/p&gt;

&lt;pre&gt;407878.44 + 5901.6 + 29508 = 443288.04&lt;/pre&gt;

&lt;p&gt;此外还有一些细节，例如深圳规定租房者可以提取一半公积金，剩余一半则必须通过买房等手段才能拿出。为了简化计算，就不做考虑了。&lt;/p&gt;

&lt;h1&gt;香港&lt;/h1&gt;

&lt;p&gt;香港的征税方式并非每月自动从收入中扣除，而是每个会计年度过后自行报税。由于没有各种社保项目，&lt;a href="http://www.gov.hk/sc/residents/taxes/taxfiling/taxrates/salariesrates.htm"&gt;香港的征税规则&lt;/a&gt;比较简单，对普通人来说，可以选择两种征税方式选其低值：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从年总收入中扣除抵税项及免税额，再根据累进税率计算。&lt;/li&gt;
&lt;li&gt;从年总收入中扣除抵税项（但不包括免税额），再根据15%标准税率计算。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外，收入超过一定数额以后，则必须使用15%的标准税率计算，不过那些都是年入至少$1620K的高薪人士，就不予考虑了。&lt;/p&gt;

&lt;p&gt;在我们目前使用的案例中，“抵税项”主要是指“房租”，一般（能给出$750K年薪的）大公司，都会给员工提供房租全额抵税项目。香港房租很贵，以每月$12K为准，每年总计$144K，可抵扣一半。此外，例如慈善捐款，某些个人培训也能抵税，不过这些杂项暂不算入目前的案例。&lt;/p&gt;

&lt;/p&gt;而“免税额”方面，则可以享受到&lt;a href="http://www.gov.hk/tc/residents/taxes/salaries/allowances/allowances/7years.htm"&gt;个人以及配偶的基本免税额&lt;/a&gt;，数值各为$120K，共计$240K。此外还有一些我们暂不考虑项目，例如需要抚养小孩或赡养老人等等，这些情况可以获得额外的免税额。&lt;/p&gt;

&lt;p&gt;使用“累进税率”进行计算，则实际缴纳基数为：&lt;/p&gt;

&lt;pre&gt;750K - 240K - 144K / 2 = 438K&lt;/pre&gt;

&lt;p&gt;根据香港累进税率，前$120K共需缴纳$8.4K税款，而剩余部分则需使用17%的税率，因此个税总额为：&lt;/p&gt;

&lt;pre&gt;(438K - 120K) * 17% + 8.4K = 62.46K&lt;/pre&gt;

&lt;p&gt;于是扣除房租后年入总额为：&lt;/p&gt;

&lt;pre&gt;750K - 144K - 62.46K = 543.54K&lt;/pre&gt;

&lt;p&gt;折合人民币约为$434.83K，与大陆基本持平。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;年入60w人民币似乎正好是条分界线——考虑到香港全部为现金收入，而大陆有3.5w收入是社保和住房公积金，个人认为深圳和香港基本相同。假如您收入更高，或者自有住房（或者租差点的房子），则香港收入则会比大陆优厚，毕竟香港最大开销便是房租，且17%与30%（甚至更高）的税率存在很大差距。&lt;/p&gt;

&lt;p&gt;此外，早些年香港没有养老保险，现在则有了“&lt;a href="http://www.mpfa.org.hk/"&gt;强制性公积金（MPF）&lt;/a&gt;”，每月个人和公司各交5%，这部分类似于大陆统筹规划的“养老保险”，退休后发放。不过，大公司往往会给员工提供另一个更为优厚的退休金计划作为备选，可用于代替政府的“强积金”。例如，每月额外提供月收入的10%（无需个人掏钱），员工可以在退休或离职之后提取出来（根据年限不同，可能只可以取出部分退休金）。这也是一笔比较可观的收入，而大陆的养老金几乎可以认为是打水漂了。&lt;/p&gt;

&lt;p&gt;至于其他开销，由于已经去除了差距最大的“房租”部分，我个人并不认为大陆一线大城市（北京、上海、深圳）与香港相比有明显差距，更何况在某些方面，例如电子产品，手机费，宽带费，还有女性日常所需的化妆品保养品等方面，香港似乎都还比大陆便宜不少。&lt;/p&gt;

&lt;p&gt;因此我认为，假如您的收入较高（例如年入超过60w人民币），不如考虑下在香港发展的机会。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/07/china-hongkong-taxing-comparison.html#comments</comments>
      <pubDate>Sat, 06 Jul 2013 11:40:16 GMT</pubDate>
      <lastBuildDate>Sat, 31 Aug 2013 11:02:07 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/reading/">阅读相关</category>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <title>抓取InfoQ内容的calibre脚本</title>
      <link>http://blog.zhaojie.me/2013/06/calibre-recipe-infoq.html</link>
      <guid>http://blog.zhaojie.me/2013/06/calibre-recipe-infoq.html</guid>
      <description>&lt;p&gt;两个礼拜前我公开了一个抓取&lt;a href="http://blog.zhaojie.me/2013/06/calibre-recipe-for-msdn-magazine-2013.html"&gt;今年MSDN Magazine内容的calibre脚本&lt;/a&gt;，这次则是针对InfoQ的。最近用Kindle Paperwhite看书一发不可收拾，自然想要更好地利用这个设备。InfoQ是一个难得的高质量站点，可惜它的RSS只输出摘要，甚至只有前十条内容，让人感到十分不方便。但这显然难不住calibre这个电子书管理神器和伟大的程序员，于是我这段时间又断断续续地编写了InfoQ站点内容的抓取脚本，各个方面细节感觉修饰地都还算不错，&lt;a href="https://github.com/JeffreyZhao/calibre-recipes/blob/master/InfoQ.py"&gt;特此公布&lt;/a&gt;。至于这个脚本该怎么用，就请自行看下&lt;a href="http://manual.calibre-ebook.com/news.html"&gt;calibre的帮助&lt;/a&gt;吧。&lt;/p&gt;

&lt;p&gt;为了更好的使用这段脚本，我这里也再稍微谈下部分细节。这个脚本最一开始是一些配置：&lt;/p&gt;

&lt;pre class="code"&gt;language =&lt;span style="color: #a31515"&gt; 'en'&lt;/span&gt;

site_url =&lt;span style="color: #a31515"&gt; 'http://www.infoq.com/'&lt;/span&gt;

title_prefix = &lt;span style="color: #a31515"&gt;'InfoQ'&lt;/span&gt;

date_regexes = [
    &lt;span style="color: #a31515"&gt;r'Jan\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Feb\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Mar\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Apr\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'May\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Jun\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Jul\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Aug\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Sep\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Oct\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Nov\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'Dec\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;
]&lt;/pre&gt;

&lt;p&gt;这些代码记录了抓取目标的一些信息，包括用来匹配日期用的正则表达式。显然这些配置的目标是&lt;a href="http://www.infoq.com/"&gt;InfoQ英文主站&lt;/a&gt;，假如要针对&lt;a href="http://www.infoq.com/cn/"&gt;InfoQ中文站&lt;/a&gt;，则只需将下面这段注释去掉即可：&lt;/p&gt;

&lt;pre class="code"&gt;language = &lt;span style="color: #a31515"&gt;'zh'&lt;/span&gt;

site_url =&lt;span style="color: #a31515"&gt; 'http://www.infoq.com/cn/'&lt;/span&gt;

title_prefix =&lt;span style="color: #a31515"&gt; 'InfoQ中国站'&lt;/span&gt;

date_regexes = [
    &lt;span style="color: #a31515"&gt;r'一月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'二月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'三月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'四月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'五月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'六月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'七月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'八月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'九月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'十月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'十一月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;,
    &lt;span style="color: #a31515"&gt;r'十二月\s+(?P&amp;lt;day&amp;gt;\d{2}),\s+(?P&amp;lt;year&amp;gt;\d{4})'&lt;/span&gt;
]&lt;/pre&gt;

&lt;p&gt;再接下来则是配置网站中哪些部分的内容是需要抓取的，目前InfoQ有三个主要的文字部分，分别是“新闻（news）”，“文章（articles）”和”访谈（interviews）“，您可以只保留需要抓取的部分，每个部分会作为这本书的一个“章节”来对待。&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: green"&gt;# sections to download&lt;/span&gt;
sections = [ &lt;span style="color: #a31515"&gt;'news'&lt;/span&gt;, &lt;span style="color: #a31515"&gt;'articles'&lt;/span&gt;, &lt;span style="color: #a31515"&gt;'interviews'&lt;/span&gt; ]&lt;/pre&gt;

&lt;p&gt;最后则是每个部分所需要抓取的时间范围，每个时间范围均为一个二元tuple，表示起始日期和终止日期，方便起见均为“闭区间”，换句话说假如您要抓取当天的内容，则使用&lt;code&gt;(date.today(), date.today())&lt;/code&gt;即可。除了统一的时间范围之外，您还可以为不同的部分指定不同的时间范围：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: green"&gt;# the range of date (both inclusive) to download&lt;/span&gt;
date_range = (date(2013, 6, 20), date(2013, 6, 22))

# the range of date to override for sections
section_date_ranges = {
    &lt;span style="color: green"&gt;# 'news: (date(2013, 6, 21), date(2013, 6, 22)),&lt;/span&gt;
    &lt;span style="color: green"&gt;# 'articles': (date(2013, 6, 5), date(2013, 6, 10)),&lt;/span&gt;
    &lt;span style="color: green"&gt;# 'interviews': (date(2013, 1, 1), date(2013, 3, 1))&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;至于剩下的部分，我就不多解释了，总之就是分析页面，获取每一篇文章的基本数据，生成索引脚本calibre的框架即可。还有一部分代码是用来从一张页面的DOM信息中挑选出可读的部分，顺便我必须吐槽，InfoQ改版后的HTML还是那么糟糕，对Readability的支持还是很差，只能由我进行自定义分析了，且分析起来也很麻烦。总之，假如您不知道这些代码在作什么，建议您不要轻易改动。当然，代码其实很简单，感兴趣的话也不妨试着理解一下那是最好的了。&lt;/p&gt;

&lt;p&gt;我是这么用这个脚本的：首先，我抓取了最近半年来所有的内容放着慢慢回顾，当然只仔细看那些感兴趣的部分，大部分时间是刷刷地翻，这比直接阅读InfoQ网页效率高出何止一星半点。然后，保留一个脚本，每天早上定时抓取前一天发布的内容（使用&lt;code&gt;date.today() - timedelta(days = 1)&lt;/code&gt;作为时间范围的上下限），并使用Amazon的文档服务推送到Kindle设备上阅读。&lt;/p&gt;

&lt;p&gt;我抓取了两个mobi格式的示例文档（中英文各一），感兴趣的朋友可以&lt;a href="http://files.zhaojie.me/infoq-calibre.zip"&gt;下载来看看&lt;/a&gt;，可以直接用PC/Mac/iOS/Android上的Kindle阅读器打开，也可以使用calibre自带的或其他mobi文档阅读器，这里我只贴出Kindle Paperwhite的截图。&lt;/p&gt;

&lt;p&gt;主索引：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/main-index-en-0.png"&gt;&lt;img alt="Main Index" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/main-index-en-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/main-index-zh-0.png"&gt;&lt;img alt="主索引" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/main-index-zh-0.png" width="250" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;块状索引：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-en-0.png"&gt;&lt;img alt="Block Index (0)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-en-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-en-1.png"&gt;&lt;img alt="Block Index (1)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-en-1.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-zh-0.png"&gt;&lt;img alt="块状索引（0）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-zh-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-zh-1.png"&gt;&lt;img alt="块状索引（1）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/block-index-zh-1.png" width="250" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;列式索引：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/list-index-en-0.png"&gt;&lt;img alt="List Index" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/list-index-en-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/list-index-zh-0.png"&gt;&lt;img alt="列式索引" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/list-index-zh-0.png" width="250" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;新闻内容：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-en-0.png"&gt;&lt;img alt="News Content (0)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-en-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-en-1.png"&gt;&lt;img alt="News Content (1)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-en-1.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-zh-0.png"&gt;&lt;img alt="新闻内容（0）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-zh-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-zh-1.png"&gt;&lt;img alt="新闻内容（1）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/news-content-zh-1.png" width="250" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;访谈内容：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-en-0.png"&gt;&lt;img alt="Interview Content (0)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-en-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-en-1.png"&gt;&lt;img alt="Interview Content (1)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-en-1.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-en-2.png"&gt;&lt;img alt="Interview Content (2)" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-en-2.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-zh-0.png"&gt;&lt;img alt="访谈内容（0）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-zh-0.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-zh-1.png"&gt;&lt;img alt="访谈内容（1）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-zh-1.png" width="250" /&gt;&lt;/a&gt; &lt;a href="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-zh-2.png"&gt;&lt;img alt="访谈内容（2）" src="http://img.zhaojie.me/blog/calibre-recipe-infoq/interview-content-zh-2.png" width="250" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kindle Paperwhite实在是个好东西，绝对推荐大家购买。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/06/calibre-recipe-infoq.html#comments</comments>
      <pubDate>Sun, 30 Jun 2013 23:11:02 GMT</pubDate>
      <lastBuildDate>Sun, 30 Jun 2013 23:18:37 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/reading/">阅读相关</category>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <title>使用calibre抓取2013年的MSDN Magazine</title>
      <link>http://blog.zhaojie.me/2013/06/calibre-recipe-for-msdn-magazine-2013.html</link>
      <guid>http://blog.zhaojie.me/2013/06/calibre-recipe-for-msdn-magazine-2013.html</guid>
      <description>&lt;p&gt;前段时间入手&lt;a href="http://www.amazon.cn/gp/product/B007OZO03M/"&gt;Kindle Paperwhite&lt;/a&gt;，这已经是我第三个Kindle设备了。想当年我花了四五千块钱，在亚马逊美国站上跟着老美预定，可谓是全世界第一批Kindle DX（大屏幕的那款阅读器）用户，不过用着用着后来还是去玩平板了。这次Kindle Paperwhite出了国行设备，才849元，顿觉实在是太便宜了，立即下单，第二天就拿到了这台设备。&lt;/p&gt;

&lt;p&gt;有了设备自然要用，除了官方书店里买的书以外，第三方的内容自然也必不可少，毕竟目前国内的Kindle电子书还太少（尤其是计算机方面的），还好之前也从国外买了不少mobi电子书，可以直接看。更重要的是，我发现可以使用&lt;a href="http://calibre-ebook.com/"&gt;calibre&lt;/a&gt;这个电子书管理神器来&lt;a href="http://manual.calibre-ebook.com/news.html"&gt;抓取网络上的内容&lt;/a&gt;，生成一本电子期刊，甚至可以利用亚马逊提供的&lt;a href="http://www.amazon.cn/gp/help/customer/display.html?nodeId=200899590#pdocs"&gt;邮箱推送服务&lt;/a&gt;来传送到Kindle设备上。&lt;/p&gt;

&lt;p&gt;calibre可以通过一个RSS链接经过简单设置转化为电子书，是为“基本模式”，与此相对的“高级模式”便是自己编写Python脚本来抓取内容了，这样的抓取脚本被称为“recipe”。calibre为此提供了一个&lt;a href="http://manual.calibre-ebook.com/news_recipe.html"&gt;抓取框架&lt;/a&gt;，让我们覆盖一些方法，提供一些基本信息，就会去自动下载网页内容了。其实calibre也已经内置许多新闻源的抓取脚本了，但自带的MSDN Magazine脚本只能通过RSS来获取最新的内容，而我的目标是将某个月的内容抓取成一本书，要实现这一点只能自己动手丰衣足食了。&lt;/p&gt;

&lt;p&gt;本来我还想看看是否能够使用一个脚本来抓取历史上所有的内容，结果发现这个基本很难。我猜&lt;a href="http://msdn.microsoft.com/en-us/magazine/default.aspx"&gt;MSDN Magazine&lt;/a&gt;的编辑们也是一群不懂技术的人，甚至是交给第三方公司在维护，用了一款很土鳖的CMS系统，生成的HTML格式很差。还好，每一年的版式似乎还是相同的，那我至少可以用同一份脚本来抓取2013年里每个月的内容。尽管如此，要获取所有文章的栏目，标题以及简介还是一份挺麻烦的工作，因为HTML使用地不规则好么！&lt;/p&gt;

&lt;p&gt;至于calibre抓取框架本身，要说复杂倒也还好，只不过文档实在讲的有些不清不楚，又难以调试，所以开发起来只得不断尝试，效率很低。这个框架用到了&lt;a href="http://www.crummy.com/software/BeautifulSoup/"&gt;Beautiful Soup&lt;/a&gt;，但我&lt;a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/"&gt;根据它的文档&lt;/a&gt;却发现好多地方不太一样，后来才发现calibre集成的是其&lt;a href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html"&gt;旧版&lt;/a&gt;。更坑爹的是，根据Beautiful Soup文档中的包引入方式：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;from&lt;/span&gt; BeautifulSoup &lt;span style="color: blue"&gt;import&lt;/span&gt; BeautifulSoup, NavigableString&lt;/pre&gt;

&lt;p&gt;这么做不会出错，也能正确调用其API，但却无法与框架中的soup对象配合使用，例如使用&lt;code&gt;isinstance&lt;/code&gt;来判断其中的文本节点是否是&lt;code&gt;NavigableString&lt;/code&gt;类型的对象，居然会返回&lt;code&gt;False&lt;/code&gt;！后来才发现，原来在calibre中需要这么做才行：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;from&lt;/span&gt; calibre.ebooks.BeautifulSoup &lt;span style="color: blue"&gt;import&lt;/span&gt; BeautifulSoup, NavigableString&lt;/pre&gt;

&lt;p&gt;发现了没？框架中使用的是&lt;code&gt;calibre.ebooks.BeautifulSoup&lt;/code&gt;包，而不是&lt;code&gt;BeautifulSoup&lt;/code&gt;。既然如此，那为什么还要让它引入成功？为什么我将一个&lt;code&gt;BeautifulSoup&lt;/code&gt;节点添加到框架的DOM树中时，既没有报错也不生效？总之，这些坑浪费了我许多时间，真是岂有此理。&lt;/p&gt;

&lt;p&gt;2013年MSDN Magazine的抓取脚本我已经&lt;a href="https://github.com/JeffreyZhao/calibre-recipes/blob/master/MsdnMagazine2013.py"&gt;上传到了GitHub上&lt;/a&gt;，欢迎随意使用。最近我还打算写几个脚本用来抓取其他一些内容，例如每日的InfoQ新闻等等。InfoQ的RSS只输出摘要，令人不爽，但这对于calibre来说完全不成问题——反正内容是去网页上抓下来的。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/06/calibre-recipe-for-msdn-magazine-2013.html#comments</comments>
      <pubDate>Tue, 18 Jun 2013 23:11:38 GMT</pubDate>
      <lastBuildDate>Tue, 18 Jun 2013 23:21:41 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <title>防止装箱落实到底，只做一半也是失败</title>
      <link>http://blog.zhaojie.me/2013/04/dont-go-half-way-of-preventing-boxing.html</link>
      <guid>http://blog.zhaojie.me/2013/04/dont-go-half-way-of-preventing-boxing.html</guid>
      <description>&lt;p&gt;.NET提供struct类型，正确使用可以减少对象数量，从而降低GC压力，提高性能。不过有时候我会发现，某些同学有这方面的意识，但是有时候一疏忽一偷懒，就没有得到相应的效果了。这里举一个真实的例子：假设我们要将一对&lt;code&gt;int&lt;/code&gt;作为字典的键，用于映射到某些数据，那么你会怎么做？当然我们可以直接使用&lt;code&gt;Tuple&amp;lt;int, int&amp;gt;&lt;/code&gt;，但这样就可能产生大量的对象。于是我们打算使用自定义的值类型：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;private struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyKey &lt;/span&gt;{
    &lt;span style="color: blue"&gt;private readonly int &lt;/span&gt;_a;
    &lt;span style="color: blue"&gt;private readonly int &lt;/span&gt;_b;

    &lt;span style="color: blue"&gt;public &lt;/span&gt;MyKey(&lt;span style="color: blue"&gt;int &lt;/span&gt;a, &lt;span style="color: blue"&gt;int &lt;/span&gt;b) {
        _a = a;
        _b = b;
    }
}&lt;/pre&gt;

&lt;p&gt;这么做正确吗？假如你做一下测试，会发现它已经可以“正确使用”了，但实际上还是错误的。我们用它来做字典的键，会依赖&lt;code&gt;GetHashCode&lt;/code&gt;和&lt;code&gt;Equals&lt;/code&gt;两个方法，由于&lt;code&gt;MyKey&lt;/code&gt;没有提供这两个方法，就会自动使用&lt;code&gt;System.ValueType&lt;/code&gt;里的实现，这便引起了装箱。&lt;/p&gt;

&lt;p&gt;好吧，那么我们就来实现一下：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;private struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyKey &lt;/span&gt;{
    &lt;span style="color: green"&gt;// ...

    &lt;/span&gt;&lt;span style="color: blue"&gt;public override int &lt;/span&gt;GetHashCode() {
        &lt;span style="color: green"&gt;// ...
    &lt;/span&gt;}

    &lt;span style="color: blue"&gt;public override bool &lt;/span&gt;Equals(&lt;span style="color: blue"&gt;object &lt;/span&gt;that) {
        &lt;span style="color: green"&gt;// ...
    &lt;/span&gt;}
}&lt;/pre&gt;

&lt;p&gt;那么现在呢？可能现在您就会比较容易意识到，即便&lt;code&gt;GetHashCode&lt;/code&gt;已经没有问题了，但是&lt;code&gt;Equals&lt;/code&gt;方法还是会引起装箱，因为&lt;code&gt;that&lt;/code&gt;参数依然是&lt;code&gt;object&lt;/code&gt;类型。&lt;/p&gt;

&lt;p&gt;怎么破？当然有办法，因为像&lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt;或是&lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt;集合其实都不会直接调用&lt;code&gt;GetHashCode&lt;/code&gt;和&lt;code&gt;Equals&lt;/code&gt;方法，都是通过一个&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;对象来委托调用的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af"&gt;IEqualityComparer&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;in &lt;/span&gt;T&amp;gt; {
    &lt;span style="color: blue"&gt;bool &lt;/span&gt;Equals(T x, T y);
    &lt;span style="color: blue"&gt;int &lt;/span&gt;GetHashCode(T obj);
}&lt;/pre&gt;

&lt;p&gt;假如在创建集合的时候没有提供比较器，则会使用默认的&lt;code&gt;EqualityComparer&amp;lt;T&amp;gt;.Default&lt;/code&gt;对象，它的构造方法是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;private static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt; CreateComparer&amp;lt;T&amp;gt;() {
    &lt;span style="color: #2b91af"&gt;Contract&lt;/span&gt;.Ensures(&lt;span style="color: #2b91af"&gt;Contract&lt;/span&gt;.Result&amp;lt;&lt;span style="color: #2b91af"&gt;EqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt;&amp;gt;() != &lt;span style="color: blue"&gt;null&lt;/span&gt;);

    &lt;span style="color: #2b91af"&gt;RuntimeType &lt;/span&gt;t = (&lt;span style="color: #2b91af"&gt;RuntimeType&lt;/span&gt;)&lt;span style="color: blue"&gt;typeof&lt;/span&gt;(T);
    &lt;span style="color: green"&gt;// Specialize type byte for performance reasons 
    &lt;/span&gt;&lt;span style="color: blue"&gt;if &lt;/span&gt;(t == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: blue"&gt;byte&lt;/span&gt;)) {
        &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;EqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt;)(&lt;span style="color: blue"&gt;object&lt;/span&gt;)(&lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ByteEqualityComparer&lt;/span&gt;());
    }

    &lt;span style="color: green"&gt;// If T implements IEquatable&amp;lt;T&amp;gt; return a GenericEqualityComparer&amp;lt;T&amp;gt;
    &lt;/span&gt;&lt;span style="color: blue"&gt;if &lt;/span&gt;(&lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;IEquatable&lt;/span&gt;&amp;lt;T&amp;gt;).IsAssignableFrom(t)) {
        &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;EqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt;)&lt;span style="color: #2b91af"&gt;RuntimeTypeHandle&lt;/span&gt;.CreateInstanceForAnotherGenericParameter(
                (&lt;span style="color: #2b91af"&gt;RuntimeType&lt;/span&gt;)&lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;GenericEqualityComparer&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;), t);
    }

    &lt;span style="color: green"&gt;// If T is a Nullable&amp;lt;U&amp;gt; where U implements IEquatable&amp;lt;U&amp;gt; return a NullableEqualityComparer&amp;lt;U&amp;gt;
    &lt;/span&gt;&lt;span style="color: blue"&gt;if &lt;/span&gt;(t.IsGenericType &amp;amp;&amp;amp; t.GetGenericTypeDefinition() == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Nullable&lt;/span&gt;&amp;lt;&amp;gt;)) {
        &lt;span style="color: #2b91af"&gt;RuntimeType &lt;/span&gt;u = (&lt;span style="color: #2b91af"&gt;RuntimeType&lt;/span&gt;)t.GetGenericArguments()[0];
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(&lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;IEquatable&lt;/span&gt;&amp;lt;&amp;gt;).MakeGenericType(u).IsAssignableFrom(u)) {
            &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;EqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt;)&lt;span style="color: #2b91af"&gt;RuntimeTypeHandle&lt;/span&gt;.CreateInstanceForAnotherGenericParameter(
                    (&lt;span style="color: #2b91af"&gt;RuntimeType&lt;/span&gt;)&lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;NullableEqualityComparer&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;), u);
        }
    }

    &lt;span style="color: green"&gt;// If T is an int-based Enum, return an EnumEqualityComparer&amp;lt;T&amp;gt;
    // See the METHOD__JIT_HELPERS__UNSAFE_ENUM_CAST and METHOD__JIT_HELPERS__UNSAFE_ENUM_CAST_LONG cases in getILIntrinsicImplementation 
    &lt;/span&gt;&lt;span style="color: blue"&gt;if &lt;/span&gt;(t.IsEnum &amp;amp;&amp;amp; &lt;span style="color: #2b91af"&gt;Enum&lt;/span&gt;.GetUnderlyingType(t) == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: blue"&gt;int&lt;/span&gt;)) {
        &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;EqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt;)&lt;span style="color: #2b91af"&gt;RuntimeTypeHandle&lt;/span&gt;.CreateInstanceForAnotherGenericParameter(
                (&lt;span style="color: #2b91af"&gt;RuntimeType&lt;/span&gt;)&lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;EnumEqualityComparer&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;), t);
    }

    &lt;span style="color: green"&gt;// Otherwise return an ObjectEqualityComparer&amp;lt;T&amp;gt; 
    &lt;/span&gt;&lt;span style="color: blue"&gt;return new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ObjectEqualityComparer&lt;/span&gt;&amp;lt;T&amp;gt;();
}&lt;/pre&gt;

&lt;p&gt;可以看出，根据不同的情况它会使用各式不同的比较器。其中最适合我们的自然就是实现&lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt;接口的分支了。于是我们可以这么做：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyKey &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;IEquatable&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyKey&lt;/span&gt;&amp;gt; {
    &lt;span style="color: green"&gt;// ...

    &lt;/span&gt;&lt;span style="color: blue"&gt;public bool &lt;/span&gt;Equals(&lt;span style="color: #2b91af"&gt;MyKey &lt;/span&gt;that) {
        &lt;span style="color: green"&gt;// ...
    &lt;/span&gt;}
}&lt;/pre&gt;

&lt;p&gt;这才是最终符合我们要求的做法。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/04/dont-go-half-way-of-preventing-boxing.html#comments</comments>
      <pubDate>Wed, 10 Apr 2013 22:21:32 GMT</pubDate>
      <lastBuildDate>Wed, 10 Apr 2013 22:22:04 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <title>为什么我不喜欢Go语言式的接口（即Structural Typing）</title>
      <link>http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html</link>
      <guid>http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html</guid>
      <description>&lt;p&gt;所谓Go语言式的接口，就是不用显示声明类型&lt;code&gt;T&lt;/code&gt;实现了接口&lt;code&gt;I&lt;/code&gt;，只要类型&lt;code&gt;T&lt;/code&gt;的公开方法完全满足接口&lt;code&gt;I&lt;/code&gt;的要求，就可以把类型&lt;code&gt;T&lt;/code&gt;的对象用在需要接口&lt;code&gt;I&lt;/code&gt;的地方。这种做法的学名叫做&lt;a href="http://en.wikipedia.org/wiki/Structural_type_system"&gt;Structural Typing&lt;/a&gt;，有人也把它看作是一种静态的Duck Typing。除了Go的接口以外，类似的东西也有比如Scala里的Traits等等。有人觉得这个特性很好，但我个人并不喜欢这种做法，所以在这里谈谈它的缺点。当然这跟动态语言静态语言的讨论类似，不能简单粗暴的下一个“好”或“不好”的结论。&lt;/p&gt;

&lt;p&gt;那么就从头谈起：什么是接口。其实通俗地讲，接口就是一个协议，规定了一组成员，例如.NET里的&lt;code&gt;ICollection&lt;/code&gt;接口：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;ICollection&lt;/span&gt; {
    &lt;span style="color: blue"&gt;int&lt;/span&gt; Count { &lt;span style="color: blue"&gt;get&lt;/span&gt;; }
    &lt;span style="color: blue"&gt;object&lt;/span&gt; SyncRoot { &lt;span style="color: blue"&gt;get&lt;/span&gt;; }
    &lt;span style="color: blue"&gt;bool&lt;/span&gt; IsSynchronized { &lt;span style="color: blue"&gt;get&lt;/span&gt;; }
    &lt;span style="color: blue"&gt;void&lt;/span&gt; CopyTo(&lt;span style="color: #2b91af"&gt;Array&lt;/span&gt; array, &lt;span style="color: blue"&gt;int&lt;/span&gt; index);
}&lt;/pre&gt;

&lt;p&gt;这就是一个协议的全部了吗？事实并非如此，其实接口还规定了每个行为的“特征”。打个比方，这个接口的&lt;code&gt;Count&lt;/code&gt;除了需要返回集合内元素的数目以外，还隐含了它需要在O(1)时间内返回这个要求。这样一个使用了&lt;code&gt;ICollection&lt;/code&gt;接口的方法才能放心地使用&lt;code&gt;Count&lt;/code&gt;属性来获取集合大小，才能在知道这些特征的情况下选用正确的算法来编写程序，而不用担心带来性能问题，这才能实现所谓的“面向接口编程”。当然这种“特征”并不单指“性能”上的，例如&lt;code&gt;Count&lt;/code&gt;还包含了“不修改集合内容”这种看似十分自然的隐藏要求，这都是&lt;code&gt;ICollection&lt;/code&gt;协议的一部分。&lt;/p&gt;

&lt;p&gt;由此我们还可以解释另外一些问题，例如为什么.NET里的&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;不叫做&lt;code&gt;ArrayList&amp;lt;T&amp;gt;&lt;/code&gt;（当然这些都只是我的推测）。我的想法是，由于&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;与&lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;接口是配套出现的，而像&lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;的某些方法，例如索引器要求能够快速获取元素，这样使用&lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;接口的方法才能放心地使用下标进行访问，而满足这种特征的数据结构就基本与数组难以割舍了，于是名字里的Array就显得有些多余。&lt;/p&gt;

&lt;p&gt;假如&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;改名为&lt;code&gt;ArrayList&amp;lt;T&amp;gt;&lt;/code&gt;，那么似乎就暗示着&lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;可以有其他实现，难道是&lt;code&gt;LinkedList&amp;lt;T&amp;gt;&lt;/code&gt;吗？事实上，&lt;code&gt;LinkedList&amp;lt;T&amp;gt;&lt;/code&gt;根本与&lt;code&gt;IList&amp;lt;T&amp;gt;&lt;/code&gt;没有任何关系，因为它的特征和&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;相差太多，它有的尽是些&lt;code&gt;AddFirst&lt;/code&gt;、&lt;code&gt;InsertBefore&lt;/code&gt;方法等等。当然，&lt;code&gt;LinkedList&amp;lt;T&amp;gt;&lt;/code&gt;与&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;都是&lt;code&gt;ICollection&amp;lt;T&amp;gt;&lt;/code&gt;，所以我们可以放心地使用其中一小部分成员，它们的行为特征是明确的。&lt;/p&gt;

&lt;p&gt;这方面的反面案例之一便是Java了。在Java类库中，&lt;code&gt;ArrayList&lt;/code&gt;和&lt;code&gt;LinkedList&lt;/code&gt;都实现了&lt;code&gt;List&lt;/code&gt;接口，它们都有&lt;code&gt;get&lt;/code&gt;方法，传入一个下标，返回那个位置的元素，但是这两种实现中前者耗时O(1)后者耗时O(N)，两者大相近庭。那么好，我现在要实现一个方法，它要求从第一个元素开始，返回每隔P个位置的元素，我们还能面向&lt;code&gt;List&lt;/code&gt;接口编程么？假如我们依赖下标访问，则外部一不小心传入&lt;code&gt;LinkedList&lt;/code&gt;的时候，算法的时间复杂度就从期望的O(N/P)变成了O(N&lt;sup&gt;2&lt;/sup&gt;/P)。假如我们选择遍历整个列表，则即便是&lt;code&gt;ArrayList&lt;/code&gt;我们也只能得到O(N)的效率。话说回来，Java类库的&lt;code&gt;List&lt;/code&gt;接口就是个笑话，连&lt;code&gt;Stack&lt;/code&gt;类都实现了&lt;code&gt;List&lt;/code&gt;，真不知道当年的设计者是怎么想的。&lt;/p&gt;

&lt;p&gt;简单地说，假如接口不能保证行为特征，则“面向接口编程”没有意义。&lt;/p&gt;

&lt;p&gt;而Go语言式的接口也有类似的问题，因为Structural Typing都只是从表面（成员名，参数数量和类型等等）去理解一个接口，并不关注接口的规则和含义，也没法检查。忘了是Coursera里哪个课程中提到这么一个例子：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;IPainter&lt;/span&gt; {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; Draw();
}

&lt;span style="color: blue"&gt;interface&lt;/span&gt; &lt;span style="color: #2b91af"&gt;ICowBoy&lt;/span&gt; {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; Draw();
}&lt;/pre&gt;

&lt;p&gt;在英语中Draw同时具有“画画”和“拔枪”的含义，因此对于画家（Painter）和牛仔（Cow Boy）都可以有Draw这个行为，但是两者的含义截然不同。假如我们实现了一个“小明”类型，他明明只是一个画家，但是我们却让他去跟其他牛仔决斗，这样就等于让他去送死嘛。另一方面，“小王”也可以既是一个“画家”也是个“牛仔”，他两种Draw都会，在C#里面我们就可以把他实现为：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;class&lt;/span&gt; &lt;span style="color: #2b91af"&gt;XiaoWang&lt;/span&gt; : &lt;span style="color: #2b91af"&gt;IPainter&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;ICowBoy&lt;/span&gt; {
    &lt;span style="color: blue"&gt;void&lt;/span&gt; &lt;span style="color: #2b91af"&gt;IPainter&lt;/span&gt;.Draw() {
        &lt;span style="color: green"&gt;// 画画&lt;/span&gt;
    }

    &lt;span style="color: blue"&gt;void&lt;/span&gt; &lt;span style="color: #2b91af"&gt;ICowBoy&lt;/span&gt;.Draw() {
        &lt;span style="color: green"&gt;// 掏枪&lt;/span&gt;
    }
}&lt;/pre&gt;

&lt;p&gt;因此我也一直不理解Java的取舍标准。你说这样一门强调面向对象强调接口强调设计的语言，还要求强制异常，怎么就不支持接口的显示实现呢？&lt;/p&gt;

&lt;p&gt;这就是我更倾向于Java和C#中显式标注异常的原因。因为程序是人写的，完全不会因为一个类只是因为存在某些成员，就会被当做某些接口去使用，一切都是经过“设计”而不是自然发生的。就好像我们&lt;del&gt;在泰国&lt;/del&gt;不会因为一个人看上去是美女就把它当做女人，这年头的化妆和PS技术太可怕了。&lt;/p&gt;

&lt;p&gt;我这里再小人之心一把：我估计有人看到这里会说我只是酸葡萄心理，因为C#中没有这特性所以说它不好。还真不是这样，早在当年我还没听说Structural Typing这学名的时候就考虑过这个问题。我写了一个辅助方法，它可以将任意类型转化为某种接口，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: #2b91af"&gt;XiaoMing&lt;/span&gt; xm = &lt;span style="color: blue"&gt;new&lt;/span&gt; &lt;span style="color: #2b91af"&gt;XiaoMing&lt;/span&gt;();
&lt;span style="color: #2b91af"&gt;ICowBoy&lt;/span&gt; cb = &lt;span style="color: #2b91af"&gt;StructuralTyping&lt;/span&gt;.From(xm).To&amp;lt;&lt;span style="color: #2b91af"&gt;ICowBoy&lt;/span&gt;&amp;gt;();&lt;/pre&gt;

&lt;p&gt;于是，我们就很快乐地将只懂画画的小明送去决斗了。其内部实现原理很简单，只是使用Emit在运行时动态生成一个封装类而已。此外，我还在编译后使用&lt;a href="http://www.mono-project.com/Cecil"&gt;Mono.Cecil&lt;/a&gt;分析程序集，检查&lt;code&gt;From&lt;/code&gt;与&lt;code&gt;To&lt;/code&gt;的泛型参数是否匹配，这样也等于提供了编译期的静态检查。此外，我还支持了协变逆变，还可以让不需要返回值的接口方法兼容带有返回值的方法（现在甚至还可以为其查找扩展方法），这可比简单通过名称和参数类型判断要强大多了。&lt;/p&gt;

&lt;p&gt;有了多种选择，我才放心地说我喜欢哪个。JavaScript中只能用回调编写代码，于是很多人说它是JavaScript的优点，说回调多么多么美妙我会深不以为然——只是没法反抗开始享受罢了嘛……&lt;/p&gt;

&lt;p&gt;这篇文章好像吐槽有点多？不过这小文章还挺爽的。 &lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/04/why-i-dont-like-go-style-interface-or-structural-typing.html#comments</comments>
      <pubDate>Wed, 10 Apr 2013 18:37:49 GMT</pubDate>
      <lastBuildDate>Thu, 11 Apr 2013 00:13:25 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/cutting-edge/">技术尝鲜</category>
      <category domain="http://blog.zhaojie.me/parallel/">并行处理</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <title>为什么我认为goroutine和channel是把别的平台上类库的功能内置在语言里</title>
      <link>http://blog.zhaojie.me/2013/04/why-channel-and-goroutine-in-golang-are-buildin-libraries-for-other-platforms.html</link>
      <guid>http://blog.zhaojie.me/2013/04/why-channel-and-goroutine-in-golang-are-buildin-libraries-for-other-platforms.html</guid>
      <description>&lt;p&gt;这几天看了《&lt;a href="http://www.ituring.com.cn/book/967"&gt;Go语言编程&lt;/a&gt;》这本书，感觉一般，具体可见&lt;a href="http://www.ituring.com.cn/article/37015"&gt;这篇书评&lt;/a&gt;。书评里面我提到“Go语言的goroutine和channel其实是把别的语言/平台上类库的功能内置到语言里”，这句话当然单单这么说出来是没什么价值的，于是我也就趁热把它说得再详细一些。我的看法简而言之是：由goroutine和channel所带来的主要编程范式、设计思路等等，其实基本都可以在其他一些平台中配合特定的类库来实现。&lt;/p&gt;

&lt;p&gt;我们知道，操作系统的最小调度单元是“线程”，要执行任何一段代码，都必须落实到“线程”上。可惜线程太重，资源占用太高，频繁创建销毁会带来比较严重的性能问题，于是又诞生出线程池之类的常见使用模式。也是类似的原因，“阻塞”一个线程往往不是一个好主意，因为线程虽然暂停了，但是它所占用的资源还在。线程的暂停和继续对于调度器都会带来压力，而且线程越多，调度时的开销便越大，这其中的平衡很难把握。&lt;/p&gt;

&lt;p&gt;正因为如此，也有人提出并实现了&lt;a href="http://en.wikipedia.org/wiki/Fiber_(computer_science)"&gt;fiber&lt;/a&gt;或&lt;a href="http://en.wikipedia.org/wiki/Coroutine"&gt;coroutine&lt;/a&gt;这样的东西，所谓fiber便是一个比线程更小的代码执行单位，假如说“线程”是用来计算的“物理”资源，那么fiber就可以认为是计算的“逻辑”资源了。从理念上说，goroutine和&lt;a href="http://en.wikipedia.org/wiki/Web_worker"&gt;WebWorker&lt;/a&gt;都是类似fiber或coroutine这样的概念（所以叫做goroutine）：它们都是执行逻辑的计算单元，我们可以创建大量此类单元而不用担心占用过多资源，自有调度器来使用一个或多个线程来执行它们的逻辑。&lt;/p&gt;

&lt;p&gt;Go语言使用&lt;code&gt;go&lt;/code&gt;关键字来将任意一条语句放到一个coroutine上去运行。假如只是简单地执行一段逻辑，那么这和丢一段代码去线程池里执行可以说没有任何区别。但关键就在于，由于一个coroutine几乎就是个普通的对象，因此我们往往可以放心地阻塞它的逻辑，一旦阻塞调度器可以让当前线程立即去执行其他fiber上的代码。这里的阻塞往往就是通过Go语言中的channel带来的，一般来说会发生在“读”和“写”的时候：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color: #7f0055"&gt;func&lt;/span&gt; DoSomething(ch &lt;span style="font-weight: bold; color: #7f0055"&gt;chan int&lt;/span&gt;) {
    ch &amp;lt;- 1
    &lt;span style="font-weight: bold; color: #7f0055"&gt;var&lt;/span&gt; i = &amp;lt;-ch
}&lt;/pre&gt;

&lt;p&gt;上面代码中的&lt;code&gt;ch&lt;/code&gt;就是一个用来保存&lt;code&gt;int&lt;/code&gt;类型数据的channel。第一行代码是向其写入数据，可能在channel写满的时候阻塞。第二行则是从中获取数据，在channel为空的时候阻塞。可以看出，所谓channel其实就是一个再简单不过的容器而已。假如要类比.NET类库，则可以认为它是一个实现了&lt;code&gt;ITargetBlock&lt;/code&gt;和&lt;code&gt;ISourceBlock&lt;/code&gt;的对象（例如一个&lt;code&gt;BufferBlock&lt;/code&gt;）：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static async void &lt;/span&gt;DoSomething&amp;lt;T&amp;gt;(T block) &lt;span style="color: blue"&gt;where &lt;/span&gt;T : &lt;span style="color: #2b91af"&gt;ISourceBlock&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;ITargetBlock&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt; {
    &lt;span style="color: blue"&gt;await &lt;/span&gt;block.SendAsync(1);
    &lt;span style="color: blue"&gt;var &lt;/span&gt;i = &lt;span style="color: blue"&gt;await &lt;/span&gt;block.ReceiveAsync();
}&lt;/pre&gt;

&lt;p&gt;类似Go语言中的超时等特性自然也一应俱全。当然，这里还并不能完全说是“类库”，毕竟还用到了C# 5里的async/await特性。我相信假如您对async/await有所了解的话，肯定也会听到一些它跟coroutine相关或类比的声音。它们在概念和效果上的确十分相似，当然背后的实现是有很大不同的。假如你一定要用coroutine，那还是免不了由语言或运行时提供支持。不过基于goroutine和channel的编程模式几乎完全可以由类库来实现。&lt;/p&gt;

&lt;p&gt;在Go语言中，基于goroutine和channel的编程模式往往是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color: #7f0055"&gt;func&lt;/span&gt; (ch &lt;span style="font-weight: bold; color: #7f0055"&gt;chan int&lt;/span&gt;) {
    &lt;span style="font-weight: bold; color: #7f0055"&gt;for&lt;/span&gt; { // 死循环
        &lt;span style="font-weight: bold; color: #7f0055"&gt;var&lt;/span&gt; msg = &amp;lt;-ch

        Process(msg)
    }
}&lt;/pre&gt;

&lt;p&gt;这样的“代码编写模式”是基于阻塞的，这需要coroutine支持。不过假如我们把需求分析到最基础的部分，它其实仅仅是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以创建大量队列，每个队列可以保存大量任务。 &lt;/li&gt;

  &lt;li&gt;单个队列中的任务严格串行。 &lt;/li&gt;

  &lt;li&gt;尽可能高效地（自然可以并行）处理系统中所有队列里的任务。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就完全是类库能实现的功能了，各个平台上的此类成熟类库并不少见：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;iOS上的&lt;a href="http://en.wikipedia.org/wiki/Grand_Central_Dispatch"&gt;GCD&lt;/a&gt;，或者说libdispatch。 &lt;/li&gt;

  &lt;li&gt;Java平台上与GCD理念相同的&lt;a href="http://hawtdispatch.fusesource.org/"&gt;HawtDispatch&lt;/a&gt;类库。 &lt;/li&gt;

  &lt;li&gt;与Scala语言关系更为密切的&lt;a href="http://akka.io/"&gt;Akka&lt;/a&gt;类库。 &lt;/li&gt;

  &lt;li&gt;.NET中的&lt;a href="http://msdn.microsoft.com/en-us/library/hh228603.aspx"&gt;TPL Dataflow&lt;/a&gt;（之前提到的&lt;code&gt;BufferBlock&lt;/code&gt;的出处）。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些类库与Go语言中基于goroutine和channel的开发方式有着相似的基础，也完全有能力使用同样的方式来架构系统。基于这些类库，我们只需要提交大量的任务，至于这些任务什么时候被执行则是内部实现所关心的问题，类库自身将会把这些任务调度到物理线程上执行，用一种最高效，代价最低的方式。当然，我们也可以对这些队列进行一些配置，这甚至比Go或Erlang中直接由语言运行时来提供的调度支持有更细致的控制粒度。&lt;/p&gt;

&lt;p&gt;我在工作中用过HawtDispatch和TPL Dataflow，也深刻体会到它们的价值。尤其是后者，我用TPL Dataflow实现的业务更为复杂，简直可以说大大改善了我的工作品质，拿它来模仿之前的编程模式则可以是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;block = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ActionBlock&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;(Process);&lt;/pre&gt;

&lt;p&gt;往这个&lt;code&gt;block&lt;/code&gt;对象里塞入的任何对象都会使用&lt;code&gt;Process&lt;/code&gt;方法进行处理。当然TPL Dataflow的功能不止如此，它有着大量的高级功能，例如&lt;code&gt;TransformBlock&lt;/code&gt;可以在保证顺序的情况下进行一对多的数据转换，十分好用。具体内容可以参考&lt;a href="http://www.microsoft.com/en-us/download/details.aspx?id=14782"&gt;这篇说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然，像Go与Erlang这种对coroutine和并发直接提供支持的语言还可以有其他一些做法，例如Go可以做到先从channel A中获取数据，然后在一个逻辑分支中再从channel B中获取数据。这对于只提供任务队列的类库来说做起来就麻烦一些了（对于C#和Scala这类语言来说依然不成问题），不过在我的经验里这个限制似乎并不会成为严重的阻碍，我们依然可以实现相同消息架构。&lt;/p&gt;

&lt;p&gt;说起Erlang，其实在我看来它比Go的channel要好用不少。原因在于Erlang是动态类型语言，它的&lt;code&gt;receive&lt;/code&gt;操作可以用来匹配当前队列（在Erlang里叫做mailbox）中不同模式的元组，筛选出符合特定模式的消息。与此相反，Go是静态类型语言，它总是从一个channel中依次获取类型相同的元素，这就完全类似于Java或C#中的泛型集合了。当然，这也不会是个影响系统设计的大问题。&lt;/p&gt;

&lt;p&gt;说实话，我觉得这篇文章描述过多，但缺乏案例。其实我本来想通过改写《Go语言编程》中的范例来说明问题，但后来发现书中关于channel和goroutine的例子实在太简单了，没法体现出一个这个特性所带来“架构设计”。所以，示例什么的找机会再说吧。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/04/why-channel-and-goroutine-in-golang-are-buildin-libraries-for-other-platforms.html#comments</comments>
      <pubDate>Tue, 09 Apr 2013 13:52:47 GMT</pubDate>
      <lastBuildDate>Tue, 09 Apr 2013 15:33:30 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>如何在不装箱的前提下调用“显式”实现的接口方法？（答案）</title>
      <link>http://blog.zhaojie.me/2013/04/how-to-call-explicitly-implemented-interface-method-without-boxing-answer.html</link>
      <guid>http://blog.zhaojie.me/2013/04/how-to-call-explicitly-implemented-interface-method-without-boxing-answer.html</guid>
      <description>&lt;p&gt;&lt;a href="http://blog.zhaojie.me/2013/03/using-on-disposable-struct-will-box-or-not.html"&gt;之前的问题&lt;/a&gt;是：假如一个struct实现了某个接口，却“显式”实现了其中的成员，那么我们又该如何访问这些成员？其实已经有不少同学抓住了关键，那就是使用泛型，例如有人提出了这样的辅助方法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static void &lt;/span&gt;Dispose&amp;lt;T&amp;gt;(T obj) &lt;span style="color: blue"&gt;where &lt;/span&gt;&lt;span&gt;T : &lt;span style="color: #2b91af"&gt;IDisposable&lt;/span&gt; {
    obj.Dispose();
}&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;我们没有进行类型转化，只是让运行时可以“认识到”类型T实现了&lt;code&gt;IDisposable&lt;/code&gt;接口，这自然可以在不装箱的情况下调用其成员。可惜的是，这种做法的“意识”到位了，却是错误的，原因在于忽视了值类型传参的特点：复制所有内容。换句话说，这个辅助方法内部所使用的&lt;code&gt;obj&lt;/code&gt;其实是一个副本，而不是原来的参数对象。假如被调用的成员会修改自身状态——尽管这对于值类型来说是一种极差的设计——这便会产生问题。所以正确的方法应该是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static void &lt;/span&gt;Dispose&amp;lt;T&amp;gt;(&lt;span style="color: blue"&gt;ref &lt;/span&gt;T obj) &lt;span style="color: blue"&gt;where &lt;/span&gt;&lt;span&gt;T : &lt;span style="color: #2b91af"&gt;IDisposable&lt;/span&gt; {
    obj.Dispose();
}&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;有了&lt;code&gt;ref&lt;/code&gt;关键字修饰&lt;code&gt;obj&lt;/code&gt;参数，在传递参数的时候，我们传递的是这个参数的“位置”，因此最终&lt;code&gt;Dispose&lt;/code&gt;方法是调用在传入的参数对象上的。此外，我们还可以用.NET 4.0中的&lt;code&gt;AggressiveInlining&lt;/code&gt;标注该方法，这样它会被确保内联，一是减少调用开销，二是避免运行时为每个不同的struct类型各自生成一份代码。这个方法的IL代码如下：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color: green"&gt;.method&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;private&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;hidebysig&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;static&lt;/span&gt; 
    &lt;span style="font-weight: bold; color: blue"&gt;void&lt;/span&gt; Dispose&amp;lt;([mscorlib]System.IDisposable) T&amp;gt; (
        !!T&amp;amp; obj
    ) &lt;span style="font-weight: bold; color: blue"&gt;cil&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;managed&lt;/span&gt; flag(0100) 
{
    &lt;span style="color: green"&gt;// Method begins at RVA 0x266b
    // Code size 13 (0xd)&lt;/span&gt;
    &lt;span style="font-weight: bold; color: green"&gt;.maxstack&lt;/span&gt; 8

    IL_0000: &lt;span style="color: blue"&gt;ldarg.0&lt;/span&gt;
    IL_0001: constrained. !!T
    IL_0007: &lt;span style="color: blue"&gt;callvirt&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;instance&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;void&lt;/span&gt; [mscorlib]System.IDisposable::Dispose()
    IL_000c: &lt;span style="color: blue"&gt;ret&lt;/span&gt;
} &lt;span style="color: green"&gt;// end of method Program::Dispose&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;根据我们&lt;a href="http://blog.zhaojie.me/2013/03/using-on-disposable-struct-will-box-or-not.html"&gt;之前的分析&lt;/a&gt;，这里的代码意味着不会产生装箱。当然，这还是“不那么能说明情况”，所以还是来看看汇编代码更为直接。首先，准备这么一些简单代码：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;IDisposable &lt;/span&gt;{
    &lt;span style="color: blue"&gt;private readonly int &lt;/span&gt;_i, _j;

    [&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
    &lt;span style="color: blue"&gt;public &lt;/span&gt;DisposableStruct(&lt;span style="color: blue"&gt;int &lt;/span&gt;i, &lt;span style="color: blue"&gt;int &lt;/span&gt;j) {
        _i = i;
        _j = j;
    }

    [&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
    &lt;span style="color: blue"&gt;public void &lt;/span&gt;Dispose() {
        &lt;span style="color: #2b91af"&gt;Console&lt;/span&gt;.WriteLine(_i + _j);
    }
}

[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.AggressiveInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;DisposeRef&amp;lt;T&amp;gt;(&lt;span style="color: blue"&gt;ref &lt;/span&gt;T obj) &lt;span style="color: blue"&gt;where &lt;/span&gt;T : &lt;span style="color: #2b91af"&gt;IDisposable &lt;/span&gt;{
    obj.Dispose();
}

[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.AggressiveInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;DisposeNoRef&amp;lt;T&amp;gt;(T obj) &lt;span style="color: blue"&gt;where &lt;/span&gt;T : &lt;span style="color: #2b91af"&gt;IDisposable &lt;/span&gt;{
    obj.Dispose();
}

[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;Test() {                        &lt;span style="color: green"&gt;// Line 40
    &lt;/span&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;ds = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct&lt;/span&gt;(1, 2);    &lt;span style="color: green"&gt;// Line 41
    &lt;/span&gt;ds.Dispose();                           &lt;span style="color: green"&gt;// Line 42
&lt;/span&gt;}                                           &lt;span style="color: green"&gt;// Line 43

&lt;/span&gt;[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;TestNoRef() {                   &lt;span style="color: green"&gt;// Line 46
    &lt;/span&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;ds = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct&lt;/span&gt;(1, 2);    &lt;span style="color: green"&gt;// Line 47
    &lt;/span&gt;DisposeNoRef(ds);                       &lt;span style="color: green"&gt;// Line 48
&lt;/span&gt;}                                           &lt;span style="color: green"&gt;// Line 49

&lt;/span&gt;[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;TestRef() {                     &lt;span style="color: green"&gt;// Line 52
    &lt;/span&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;ds = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct&lt;/span&gt;(1, 2);    &lt;span style="color: green"&gt;// Line 53
    &lt;/span&gt;DisposeRef(&lt;span style="color: blue"&gt;ref &lt;/span&gt;ds);                     &lt;span style="color: green"&gt;// Line 54
&lt;/span&gt;}                                           &lt;span style="color: green"&gt;// Line 55&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;注意这里我们对于&lt;code&gt;AggressiveInlining&lt;/code&gt;与&lt;code&gt;NoInlining&lt;/code&gt;的精心标注，包括构造函数，因为这样才能清晰地展现出问题来。先看&lt;code&gt;Test&lt;/code&gt;方法的代码（所有地址省去高位的&lt;code&gt;000007fd&lt;/code&gt;，下同）：&lt;/p&gt;

&lt;pre class="code"&gt;Normal JIT generated code
Program.Test()
Begin &lt;span style="color: blue"&gt;03670120&lt;/span&gt;, size 32

...\Program.cs @ 41:
&lt;span style="color: blue"&gt;03670120&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;sub&lt;/span&gt;     rsp,38h
&lt;span style="color: blue"&gt;03670124&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+20h],0
&lt;span style="color: blue"&gt;0367012d&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     r8d,2
&lt;span style="color: blue"&gt;03670133&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     edx,1
&lt;span style="color: blue"&gt;03670138&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rsp+20h]
&lt;span style="color: blue"&gt;0367013d&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;0355c098&lt;/span&gt; (DisposableStruct..ctor(Int32, Int32), ...)

...\Program.cs @ 42:
&lt;span style="color: blue"&gt;03670142&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rsp+20h]
&lt;span style="color: blue"&gt;03670147&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;0355c0a8&lt;/span&gt; (DisposableStruct.Dispose(), ...)
&lt;span style="color: blue"&gt;0367014c&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;nop&lt;/span&gt;
&lt;span style="color: blue"&gt;0367014d&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;add&lt;/span&gt;     rsp,38h
&lt;span style="color: blue"&gt;03670151&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;ret&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;对比&lt;code&gt;TestNoRef&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre class="code"&gt;Normal JIT generated code
Program.TestNoRef()
Begin &lt;span style="color: blue"&gt;03670220&lt;/span&gt;, size 45

...\Program.cs @ 47:
&lt;span style="color: blue"&gt;03670220&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;sub&lt;/span&gt;     rsp,38h
&lt;span style="color: blue"&gt;03670224&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+28h],0
&lt;span style="color: blue"&gt;0367022d&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+20h],0
&lt;span style="color: blue"&gt;03670236&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     r8d,2
&lt;span style="color: blue"&gt;0367023c&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     edx,1
&lt;span style="color: blue"&gt;03670241&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rsp+28h]
&lt;span style="color: blue"&gt;03670246&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;03670170&lt;/span&gt; (DisposableStruct..ctor(Int32, Int32), ...)

...\Program.cs @ 48:
&lt;span style="color: blue"&gt;0367024b&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     r11,qword ptr [rsp+28h]
&lt;span style="color: blue"&gt;03670250&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+20h],r11
&lt;span style="color: blue"&gt;03670255&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rsp+20h]
&lt;span style="color: blue"&gt;0367025a&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;03670190&lt;/span&gt; (DisposableStruct.Dispose(), ...)
&lt;span style="color: blue"&gt;0367025f&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;nop&lt;/span&gt;
&lt;span style="color: blue"&gt;03670260&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;add&lt;/span&gt;     rsp,38h
&lt;span style="color: blue"&gt;03670264&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;ret&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;可以清晰的看到，&lt;code&gt;DisposableStruct&lt;/code&gt;对象分配在&lt;code&gt;[rsp+28h]&lt;/code&gt;上，但在调用&lt;code&gt;Dispose&lt;/code&gt;方法前复制了一份到&lt;code&gt;[rsp+20h]&lt;/code&gt;（&lt;code&gt;DisposableStruct&lt;/code&gt;恰好8字节），把它作为&lt;code&gt;Dispose&lt;/code&gt;方法的参数。前两个方法很容易明白，但&lt;code&gt;TestRef&lt;/code&gt;则显得“奇怪”了一些：&lt;/p&gt;

&lt;pre class="code"&gt;Normal JIT generated code
Program.TestRef()
Begin &lt;span style="color: blue"&gt;036701c0&lt;/span&gt;, size 48

...\Program.cs @ 53:
&lt;span style="color: blue"&gt;036701c0&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;push&lt;/span&gt;    rbx
&lt;span style="color: blue"&gt;036701c1&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;sub&lt;/span&gt;     rsp,30h
&lt;span style="color: blue"&gt;036701c5&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+28h],0
&lt;span style="color: blue"&gt;036701ce&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rbx,[rsp+28h]
&lt;span style="color: blue"&gt;036701d3&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+20h],0
&lt;span style="color: blue"&gt;036701dc&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     r8d,2
&lt;span style="color: blue"&gt;036701e2&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     edx,1
&lt;span style="color: blue"&gt;036701e7&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rsp+20h]
&lt;span style="color: blue"&gt;036701ec&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;03670170&lt;/span&gt; (DisposableStruct..ctor(Int32, Int32), ...)

...\Program.cs @ 54
&lt;span style="color: blue"&gt;036701f1&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     rax,qword ptr [rsp+20h]
&lt;span style="color: blue"&gt;036701f6&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rbx],rax
&lt;span style="color: blue"&gt;036701f9&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     rcx,rbx
&lt;span style="color: blue"&gt;036701fc&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;03670190&lt;/span&gt; (DisposableStruct.Dispose(), ...)
&lt;span style="color: blue"&gt;03670201&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;nop&lt;/span&gt;
&lt;span style="color: blue"&gt;03670202&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;add&lt;/span&gt;     rsp,30h
&lt;span style="color: blue"&gt;03670206&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;pop&lt;/span&gt;     rbx
&lt;span style="color: blue"&gt;03670207&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;ret&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;其实我挺没有想到&lt;code&gt;TestRef&lt;/code&gt;的方法需要这么多指令，最理想的情况其实应该和&lt;code&gt;Test&lt;/code&gt;方法一模一样，不是么？这里虽然没有装箱，也没有复制对象，但是做的事情太多了，居然还在栈上保留&lt;code&gt;rbx&lt;/code&gt;，要知道这可是64位机。当然，我想这也是因为我们强制禁止了JIT内联&lt;code&gt;DisposableStruct&lt;/code&gt;构造函数的缘故吧，感兴趣的朋友可以再自行尝试一下。&lt;/p&gt;

&lt;p&gt;毕竟，我们现在只是想确认这里不会产生装箱。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/04/how-to-call-explicitly-implemented-interface-method-without-boxing-answer.html#comments</comments>
      <pubDate>Sun, 07 Apr 2013 13:51:57 GMT</pubDate>
      <lastBuildDate>Sun, 07 Apr 2013 14:04:29 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>如何在不装箱的前提下调用“显式实现”的接口方法？</title>
      <link>http://blog.zhaojie.me/2013/03/how-to-call-explicitly-implemented-interface-method-without-boxing.html</link>
      <guid>http://blog.zhaojie.me/2013/03/how-to-call-explicitly-implemented-interface-method-without-boxing.html</guid>
      <description>&lt;p&gt;&lt;a href="http://blog.zhaojie.me/2013/03/using-on-disposable-struct-will-box-or-not.html"&gt;上篇文章&lt;/a&gt;谈了针对一个struct对象使用&lt;code&gt;using&lt;/code&gt;语句的时候是否会装箱的问题，结论是“不会”。尽管&lt;code&gt;using&lt;/code&gt;语句是针对&lt;code&gt;IDisposable&lt;/code&gt;接口的，但我们在调用的时候其实已经明确了目标方法，因此根本不需要装箱（或查找虚函数表）了。后来有同学在微博上提出，这点在《CLR via C#》这本书里提到过，于是我去翻了翻，原来是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;internal struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Point &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;IComparable &lt;/span&gt;{
    &lt;span style="color: blue"&gt;private readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Int32 &lt;/span&gt;m_x, m_y;

    &lt;span style="color: green"&gt;// Constructor to easily initialize the fields
    &lt;/span&gt;&lt;span style="color: blue"&gt;public &lt;/span&gt;Point(&lt;span style="color: #2b91af"&gt;Int32 &lt;/span&gt;x, &lt;span style="color: #2b91af"&gt;Int32 &lt;/span&gt;y) {
        m_x = x;
        m_y = y;
    }

    &lt;span style="color: green"&gt;// Implementation of type-safe CompareTo method
    &lt;/span&gt;&lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Int32 &lt;/span&gt;CompareTo(&lt;span style="color: #2b91af"&gt;Point &lt;/span&gt;other) {
        &lt;span style="color: green"&gt;// Use the Pythagorean Theorem to calculate
        // which point is farther from the origin (0, 0)
        &lt;/span&gt;&lt;span style="color: blue"&gt;return &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Math&lt;/span&gt;.Sign(&lt;span style="color: #2b91af"&gt;Math&lt;/span&gt;.Sqrt(m_x * m_x + m_y * m_y));
    }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Int32 &lt;/span&gt;CompareTo(&lt;span style="color: #2b91af"&gt;Object &lt;/span&gt;o) {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(GetType() != o.GetType()) {
            &lt;span style="color: blue"&gt;throw new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ArgumentException&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;quot;o is not a Point&amp;quot;&lt;/span&gt;);
        }

        &lt;span style="color: green"&gt;// Call type-safe CompareTo method
        &lt;/span&gt;&lt;span style="color: blue"&gt;return &lt;/span&gt;CompareTo((&lt;span style="color: #2b91af"&gt;Point&lt;/span&gt;)o);
    }
}

&lt;span style="color: blue"&gt;public static class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Program &lt;/span&gt;{
    &lt;span style="color: blue"&gt;public static void &lt;/span&gt;Main() {
        &lt;span style="color: green"&gt;// Create two Point instances on the stack.
        &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Point &lt;/span&gt;p1 = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Point&lt;/span&gt;(10, 10);
        &lt;span style="color: #2b91af"&gt;Point &lt;/span&gt;p2 = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Point&lt;/span&gt;(20, 20);

        &lt;span style="color: green"&gt;// p1 does NOT get boxed to call CompareTo.
        // p2 does NOT get boxed because CompareTo(Point) is called.
        &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Console&lt;/span&gt;.WriteLine(p1.CompareTo(p2)); &lt;span style="color: green"&gt;// &amp;quot;-1&amp;quot;

        // p1 DOES get boxed, and the reference is placed in c.
        &lt;/span&gt;&lt;span style="color: #2b91af"&gt;IComparable &lt;/span&gt;c = p1;
        ...
    }
}&lt;/pre&gt;

&lt;p&gt;我参考的是其第四版电子版，这段代码出现在第5章，133页开始。那位同学说，你看这里在调用&lt;code&gt;CompareTo&lt;/code&gt;方法的时候，书上写的很明白没有装箱嘛。我看了之后表示这跟前一篇谈的内容其实并没有太多联系。假如从IL上看，这次调用是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color: green"&gt;.method&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;public&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;hidebysig&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;static&lt;/span&gt; 
    &lt;span style="font-weight: bold; color: blue"&gt;void&lt;/span&gt; Main () &lt;span style="font-weight: bold; color: blue"&gt;cil&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;managed&lt;/span&gt; 
{
    &lt;span style="color: green"&gt;// Method begins at RVA 0x26b8
    // Code size 36 (0x24)&lt;/span&gt;
    &lt;span style="font-weight: bold; color: green"&gt;.maxstack&lt;/span&gt; 3
    &lt;span style="font-weight: bold; color: green"&gt;.locals&lt;/span&gt; &lt;span style="font-weight: bold; color: green"&gt;init&lt;/span&gt; (
        [0] &lt;span style="font-weight: bold; color: blue"&gt;valuetype&lt;/span&gt; Point p1,
        [1] &lt;span style="font-weight: bold; color: blue"&gt;valuetype&lt;/span&gt; Point p2
    )

    IL_0000: &lt;span style="color: blue"&gt;ldloca.s&lt;/span&gt; p1
    IL_0002: &lt;span style="color: blue"&gt;ldc.i4.s&lt;/span&gt; 10
    IL_0004: &lt;span style="color: blue"&gt;ldc.i4.s&lt;/span&gt; 10
    IL_0006: &lt;span style="color: blue"&gt;call&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;instance&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;void&lt;/span&gt; Point::&lt;span style="font-weight: bold; color: blue"&gt;.ctor&lt;/span&gt;(&lt;span style="font-weight: bold; color: blue"&gt;int32&lt;/span&gt;, &lt;span style="font-weight: bold; color: blue"&gt;int32&lt;/span&gt;)
    IL_000b: &lt;span style="color: blue"&gt;ldloca.s&lt;/span&gt; p2
    IL_000d: &lt;span style="color: blue"&gt;ldc.i4.s&lt;/span&gt; 20
    IL_000f: &lt;span style="color: blue"&gt;ldc.i4.s&lt;/span&gt; 20
    IL_0011: &lt;span style="color: blue"&gt;call&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;instance&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;void&lt;/span&gt; Point::&lt;span style="font-weight: bold; color: blue"&gt;.ctor&lt;/span&gt;(&lt;span style="font-weight: bold; color: blue"&gt;int32&lt;/span&gt;, &lt;span style="font-weight: bold; color: blue"&gt;int32&lt;/span&gt;)
    IL_0016: &lt;span style="color: blue"&gt;ldloca.s&lt;/span&gt; p1
    IL_0018: &lt;span style="color: blue"&gt;ldloc.1&lt;/span&gt;
    IL_0019: &lt;span style="color: blue"&gt;call&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;instance&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;int32&lt;/span&gt; Point::CompareTo(&lt;span style="font-weight: bold; color: blue"&gt;valuetype&lt;/span&gt; Point)
    IL_001e: &lt;span style="color: blue"&gt;call&lt;/span&gt; &lt;span style="font-weight: bold; color: blue"&gt;void&lt;/span&gt; [mscorlib]System.Console::WriteLine(&lt;span style="font-weight: bold; color: blue"&gt;int32&lt;/span&gt;)
    IL_0023: &lt;span style="color: blue"&gt;ret&lt;/span&gt;
} &lt;span style="color: green"&gt;// end of method Program::Main&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;请注意IL_0019，它明确地指出此次&lt;code&gt;call&lt;/code&gt;指令的目标是&lt;code&gt;Point&lt;/code&gt;类型的&lt;code&gt;CompareTo&lt;/code&gt;，与&lt;code&gt;IComparable&lt;/code&gt;接口没有任何关系。我们可以从&lt;code&gt;Point&lt;/code&gt;定义中删除这个接口，这都不影响此次调用。而假如您返回上一篇文章，就会发现&lt;code&gt;using&lt;/code&gt;语句生成的IL会查找&lt;code&gt;IDisposable&lt;/code&gt;上的方法：&lt;/p&gt;

&lt;pre class="code"&gt;IL_0017: &lt;span style="color: blue"&gt;constrained.&lt;/span&gt; .DisposableStruct
IL_001d: &lt;span style="color: blue"&gt;callvirt &lt;span style="font-weight: bold"&gt;instance&lt;/span&gt; &lt;span style="font-weight: bold"&gt;void&lt;/span&gt;&lt;/span&gt; [mscorlib]System.IDisposable::Dispose()&lt;/pre&gt;

&lt;p&gt;我们都知道，把一个struct对象赋值到&lt;code&gt;IDisposable&lt;/code&gt;引用上之后会产生装箱，这才是上一篇文章中“疑惑”的由来。假如我们只是要直接调用&lt;code&gt;Dispose&lt;/code&gt;方法，自然就不会想这么多了。我又粗略翻了翻《CLR via C#》相关内容，发现它没有提到过这一点，看来我也算弥补一个空白了，表示略为开心。&lt;/p&gt;

&lt;p&gt;不过话又说回来，假如有一个类型，它是这么实现的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;IDisposable &lt;/span&gt;{
    &lt;span style="color: blue"&gt;void &lt;/span&gt;&lt;span style="color: #2b91af"&gt;IDisposable&lt;/span&gt;.Dispose() { }
}&lt;/pre&gt;


&lt;p&gt;换句话说，这个struct并没有定义一个&lt;code&gt;Dispose&lt;/code&gt;方法，而是显式实现了某个接口方法（不仅限于&lt;code&gt;IDisposable&lt;/code&gt;接口）。在这个情况下，您有什么办法在C#里调用这个接口方法呢？当然，调用时不能在堆上产生任何对象。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/03/how-to-call-explicitly-implemented-interface-method-without-boxing.html#comments</comments>
      <pubDate>Sun, 24 Mar 2013 21:45:56 GMT</pubDate>
      <lastBuildDate>Mon, 25 Mar 2013 18:34:01 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <title>针对struct对象使用using关键字是否会引起装箱？</title>
      <link>http://blog.zhaojie.me/2013/03/using-on-disposable-struct-will-box-or-not.html</link>
      <guid>http://blog.zhaojie.me/2013/03/using-on-disposable-struct-will-box-or-not.html</guid>
      <description>&lt;p&gt;说起来这是个很简单的问题，我以前肯定可以给出确切地答复，但是前几天想到这点的时候突然楞住了。把这个问题发到微博上去之后，很多人说是“会”，但要么是猜的，或是给出的原因明显不靠谱。最后我只能自己简单研究一下了，最后得到的结果是“不会”装箱。请注意，这个问题是指，对于一个实现了&lt;code&gt;IDisposable&lt;/code&gt;接口的值类型对象使用&lt;code&gt;using&lt;/code&gt;语句，而不是将它直接复制给一个&lt;code&gt;IDisposable&lt;/code&gt;引用——后者显然是会装箱的，会对性能产生一定负面影响。&lt;/p&gt;

&lt;p&gt;首先我们来写一小段测试代码：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;internal struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;IDisposable &lt;/span&gt;{
    [&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
    &lt;span style="color: blue"&gt;public void &lt;/span&gt;Dispose() { }
}

[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;DoSomething(&lt;span style="color: blue"&gt;object &lt;/span&gt;args) { }

[&lt;span style="color: #2b91af"&gt;MethodImpl&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;MethodImplOptions&lt;/span&gt;.NoInlining)]
&lt;span style="color: blue"&gt;static void &lt;/span&gt;UsingStruct() {                    &lt;span style="color: green"&gt;// Line 31
    &lt;/span&gt;&lt;span style="color: blue"&gt;using &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;ds = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DisposableStruct&lt;/span&gt;()) {  &lt;span style="color: green"&gt;// Line 32
        &lt;/span&gt;DoSomething(ds);                       &lt;span style="color: green"&gt;// Line 33
    &lt;/span&gt;}                                          &lt;span style="color: green"&gt;// Line 34
&lt;/span&gt;}                                              &lt;span style="color: green"&gt;// Line 35&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;编译之后使用ILSpy查看其IL，则能得出这样的结果：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: green"&gt;.method&lt;/span&gt; &lt;span style="color: blue"&gt;&lt;span style="font-weight: bold"&gt;private&lt;/span&gt; &lt;span style="font-weight: bold"&gt;hidebysig&lt;/span&gt; &lt;span style="font-weight: bold"&gt;static&lt;/span&gt; 
    &lt;span style="font-weight: bold"&gt;void&lt;/span&gt;&lt;/span&gt; UsingStruct () &lt;span style="color: blue"&gt;&lt;span style="font-weight: bold"&gt;cil&lt;/span&gt; &lt;span style="font-weight: bold"&gt;managed&lt;/span&gt; &lt;span style="font-weight: bold"&gt;noinlining&lt;/span&gt;&lt;/span&gt;
{
    &lt;span style="color: green"&gt;// Method begins at RVA 0x26a0
    // Code size 36 (0x24)
    &lt;span style="font-weight: bold"&gt;.maxstack&lt;/span&gt;&lt;/span&gt; 1
    &lt;span style="font-weight: bold; color: green"&gt;.locals init&lt;/span&gt; (
        [0] &lt;span style="font-weight: bold; color: blue"&gt;valuetype&lt;/span&gt; .DisposableStruct ds
    )

    IL_0000: &lt;span style="color: blue"&gt;ldloca.s&lt;/span&gt; ds
    IL_0002: &lt;span style="color: blue"&gt;initobj&lt;/span&gt; .DisposableStruct
    &lt;span style="color: green"&gt;.try&lt;/span&gt;
    {
        IL_0008: &lt;span style="color: blue"&gt;ldloc.0&lt;/span&gt;
        IL_0009: &lt;span style="color: blue"&gt;box&lt;/span&gt; .DisposableStruct
        IL_000e: &lt;span style="color: blue"&gt;call &lt;span style="font-weight: bold"&gt;void&lt;/span&gt;&lt;/span&gt; .Program::DoSomething(&lt;span style="font-weight: bold; color: blue"&gt;object&lt;/span&gt;)
        IL_0013: &lt;span style="color: blue"&gt;leave.s&lt;/span&gt; IL_0023
    } &lt;span style="color: green"&gt;// end .try&lt;/span&gt;
    &lt;span style="font-weight: bold; color: blue"&gt;finally&lt;/span&gt;
    {
        IL_0015: &lt;span style="color: blue"&gt;ldloca.s&lt;/span&gt; ds
        IL_0017: &lt;span style="color: blue"&gt;constrained.&lt;/span&gt; .DisposableStruct
        IL_001d: &lt;span style="color: blue"&gt;callvirt &lt;span style="font-weight: bold"&gt;instance&lt;/span&gt; &lt;span style="font-weight: bold"&gt;void&lt;/span&gt;&lt;/span&gt; [mscorlib]System.IDisposable::Dispose()
        IL_0022: &lt;span style="color: blue"&gt;endfinally&lt;/span&gt;
    } &lt;span style="color: green"&gt;// end handler&lt;/span&gt;

    IL_0023: &lt;span style="color: blue"&gt;ret&lt;/span&gt;
} &lt;span style="color: green"&gt;// end of method Program::UsingStruct&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;从IL上看，在&lt;code&gt;IL_0009&lt;/code&gt;处有一条&lt;code&gt;box&lt;/code&gt;指令，但那是为了&lt;code&gt;DoSomething&lt;/code&gt;调用，而不是为了&lt;code&gt;finally&lt;/code&gt;中的&lt;code&gt;Dispose&lt;/code&gt;调用，而在&lt;code&gt;IL_001d&lt;/code&gt;处的&lt;code&gt;Dispose&lt;/code&gt;方法调用却只是使用了&lt;code&gt;callvirt&lt;/code&gt;指令。尽管没有显式的装箱操作，但&lt;code&gt;callvirt&lt;/code&gt;指令按理说是需要查找虚方法表的——非对象似乎是没有虚方法表的啊？此外，上面一行的&lt;code&gt;constrained&lt;/code&gt;又是什么呢？看了&lt;a href="http://msdn.microsoft.com/library/system.reflection.emit.opcodes.constrained.aspx"&gt;MSDN上的说明&lt;/a&gt;才发现它才是这个问题的关键：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;table cellspacing="0" cellpadding="5" border="1"&gt;&lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;Format &lt;/th&gt;

        &lt;th&gt;Assembly Format &lt;/th&gt;

        &lt;th&gt;Description &lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;&lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;FE 16 &amp;lt; T &amp;gt; &lt;/td&gt;

        &lt;td&gt;constrained. &lt;code&gt;thisType&lt;/code&gt; &lt;/td&gt;

        &lt;td&gt;Call a virtual method on a type constrained to be type T. &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;&lt;/table&gt;

  &lt;p&gt;The &lt;code&gt;constrained&lt;/code&gt; prefix is designed to allow &lt;code&gt;callvirt&lt;/code&gt; instructions to be made in a uniform way independent of whether &lt;code&gt;thisType&lt;/code&gt; is a value type or a reference type.&lt;/p&gt;

  &lt;p&gt;When a &lt;code&gt;callvirt&lt;/code&gt; method instruction has been prefixed by &lt;code&gt;constrained thisType&lt;/code&gt;, the instruction is executed as follows:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;If &lt;code&gt;thisType&lt;/code&gt; is a reference type (as opposed to a value type) then &lt;code&gt;ptr&lt;/code&gt; is dereferenced and passed as the 'this' pointer to the &lt;code&gt;callvirt&lt;/code&gt; of method.&lt;/p&gt;
    &lt;/li&gt;

    &lt;li&gt;
      &lt;p&gt;If &lt;code&gt;thisType&lt;/code&gt; is a value type and &lt;code&gt;thisType&lt;/code&gt; implements method then &lt;code&gt;ptr&lt;/code&gt; is passed unmodified as the 'this' pointer to a &lt;code&gt;call&lt;/code&gt; method instruction, for the implementation of method by &lt;code&gt;thisType&lt;/code&gt;.&lt;/p&gt;
    &lt;/li&gt;

    &lt;li&gt;
      &lt;p&gt;If &lt;code&gt;thisType&lt;/code&gt; is a value type and &lt;code&gt;thisType&lt;/code&gt; does not implement method then &lt;code&gt;ptr&lt;/code&gt; is dereferenced, boxed, and passed as the 'this' pointer to the &lt;code&gt;callvirt&lt;/code&gt; method instruction.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;This last case can occur only when method was defined on &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;ValueType&lt;/code&gt;, or &lt;code&gt;Enum&lt;/code&gt; and not overridden by &lt;code&gt;thisType&lt;/code&gt;. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;ValueType&lt;/code&gt;, and &lt;code&gt;Enum&lt;/code&gt; modify the state of the object, this fact cannot be detected.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这里可以看出，&lt;code&gt;constrained&lt;/code&gt;是为了修饰&lt;code&gt;callvirt&lt;/code&gt;指令，最终表现会由具体的类型以及调用的方法来决定。假如这里要产生装箱，则必须满足第3点：针对值类型，调用定义在&lt;code&gt;Object&lt;/code&gt;等“基类”中的方法，例如最典型的&lt;code&gt;ToString&lt;/code&gt;或&lt;code&gt;GetHashCode&lt;/code&gt;，而我们这里要调用的&lt;code&gt;Dispose&lt;/code&gt;方法显然不在此列。马后炮地想想也是，不就是调用一个现成的方法嘛，值类型又不能继承，它的方法入口都是确定的，又何必装箱，又何必查找虚方法表？&lt;/p&gt;

&lt;p&gt;后来我又一不小心搜到了&lt;a href="http://stackoverflow.com/questions/1330571/when-does-a-using-statement-box-its-argument-when-its-a-struct"&gt;StackOverflow上&lt;/a&gt;与&lt;a href="http://haacked.com/archive/2006/08/11/TheUsingStatementAndDisposableValueTypes.aspx"&gt;Phil Hacck博客上&lt;/a&gt;的明确说法。这让我有些郁闷，假如我早点知道这在网上有答案，我就不用花实现去调查，甚至已经开始准备这篇文章了。还好中间我还走过一些“弯路”，也算是给世界增加一点新资料吧。由于之前我不知道这里的关键在于&lt;code&gt;constrained&lt;/code&gt;指令，我还把这个方法JIT后的代码打印了出来（所有地址都省去了高位的&lt;code&gt;000007fe&lt;/code&gt;）：&lt;/p&gt;

&lt;pre class="code"&gt;Normal JIT generated code
Program.UsingStruct()
Begin &lt;span style="color: blue"&gt;87d40120&lt;/span&gt;, size 63

...\Program.cs @ 32:
&lt;span style="color: blue"&gt;87d40120&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;push&lt;/span&gt;    rbp
&lt;span style="color: blue"&gt;87d40121&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;sub&lt;/span&gt;     rsp,30h
&lt;span style="color: blue"&gt;87d40125&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rbp,[rsp+20h]
&lt;span style="color: blue"&gt;87d4012a&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rbp],rsp
&lt;span style="color: blue"&gt;87d4012e&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     byte ptr [rbp+8],0 &lt;span style="color: green"&gt;// 初始化DisposableStruct对象&lt;/span&gt;
&lt;span style="color: blue"&gt;87d40132&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     byte ptr [rbp+8],0

...\Program.cs @ 33:
&lt;span style="color: blue"&gt;87d40136&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[&lt;span style="color: blue"&gt;87c248b0&lt;/span&gt;]
&lt;span style="color: blue"&gt;87d4013d&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rdx,[rbp+8] &lt;span style="color: green"&gt;// 准备装箱的值类型对象&lt;/span&gt;
&lt;span style="color: blue"&gt;87d40141&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    clr+0x2670 (&lt;span style="color: blue"&gt;e7392670&lt;/span&gt;) &lt;span style="color: green"&gt;(JitHelp: CORINFO_HELP_BOX)&lt;/span&gt;
&lt;span style="color: blue"&gt;87d40146&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     rcx,rax &lt;span style="color: green"&gt;// 装箱操作的返回值赋值给rcx作为参数&lt;/span&gt;
&lt;span style="color: blue"&gt;87d40149&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;87c2c020&lt;/span&gt; &lt;span style="color: green"&gt;(Program.DoSomething(System.Object), ...)&lt;/span&gt;
&lt;span style="color: blue"&gt;87d4014e&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;xchg&lt;/span&gt;    ax,ax
&lt;span style="color: blue"&gt;87d40150&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;nop&lt;/span&gt;

...\Program.cs @ 35:
&lt;span style="color: blue"&gt;87d40151&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rbp+8] &lt;span style="color: green"&gt;// 准备调用Dispose的值类型对象作为参数&lt;/span&gt;
&lt;span style="color: blue"&gt;87d40155&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;87c2c0e0&lt;/span&gt; &lt;span style="color: green"&gt;(DisposableStruct.Dispose(), ...)&lt;/span&gt;
&lt;span style="color: blue"&gt;87d4015a&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;nop&lt;/span&gt;
&lt;span style="color: blue"&gt;87d4015b&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rsp,[rbp+10h]
&lt;span style="color: blue"&gt;87d4015f&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;pop&lt;/span&gt;     rbp
&lt;span style="color: blue"&gt;87d40160&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;ret&lt;/span&gt;

...\Program.cs @ 32:
&lt;span style="color: blue"&gt;87d40161&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;push&lt;/span&gt;    rbp
&lt;span style="color: blue"&gt;87d40162&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;sub&lt;/span&gt;     rsp,30h
&lt;span style="color: blue"&gt;87d40166&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     rbp,qword ptr [rcx+20h]
&lt;span style="color: blue"&gt;87d4016a&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;mov&lt;/span&gt;     qword ptr [rsp+20h],rbp
&lt;span style="color: blue"&gt;87d4016f&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rbp,[rbp+20h]

...\Program.cs @ 35:
&lt;span style="color: blue"&gt;87d40173&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;lea&lt;/span&gt;     rcx,[rbp+8]
&lt;span style="color: blue"&gt;87d40177&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;call&lt;/span&gt;    &lt;span style="color: blue"&gt;87c2c0e0&lt;/span&gt; &lt;span style="color: green"&gt;(DisposableStruct.Dispose(), ...)&lt;/span&gt;
&lt;span style="color: blue"&gt;87d4017c&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;nop&lt;/span&gt;
&lt;span style="color: blue"&gt;87d4017d&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;add&lt;/span&gt;     rsp,30h
&lt;span style="color: blue"&gt;87d40181&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;pop&lt;/span&gt;     rbp
&lt;span style="color: blue"&gt;87d40182&lt;/span&gt;    &lt;span style="font-weight: bold; color: #800000"&gt;ret&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;从上方的汇编指令可以看出，调用&lt;code&gt;DoSomething&lt;/code&gt;之前的确存在一次装箱操作，但在调用&lt;code&gt;Dispose&lt;/code&gt;方法时却没有装箱。从中我们还可以顺便得知，假如没有异常出现，代码会顺利地从头执行到&lt;code&gt;87d40160&lt;/code&gt;处返回，不会对性能产生负面影响。换句话说，“捕获”异常会让程序运行缓慢，但使用&lt;code&gt;try...catch&lt;/code&gt;本身却不会。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/03/using-on-disposable-struct-will-box-or-not.html#comments</comments>
      <pubDate>Fri, 22 Mar 2013 00:06:03 GMT</pubDate>
      <lastBuildDate>Sun, 24 Mar 2013 20:54:10 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <title>串与绳（1）：.NET与Java里的String类型</title>
      <link>http://blog.zhaojie.me/2013/03/string-and-rope-1-string-in-dotnet-and-java.html</link>
      <guid>http://blog.zhaojie.me/2013/03/string-and-rope-1-string-in-dotnet-and-java.html</guid>
      <description>&lt;p&gt;话说“字符串”是我们平时最常用的数据类型之一，它表示一个字符序列。在大部分的语言中，字符串还是一个不可变（Immutable）的数据类型。“不可变”意味着要改变则只能生成新的字符串，无论是连接两个字符串，获取或是替换字符串的一部分，这对于内存和CPU都是不可避免的开销。在一般情况下，只要使用合理这些开销都不会构成大问题。不过对于某些类型的应用，例如我前段时间在工作中涉及到的编辑器（IDE那种），就会带来较多麻烦，于是便用到了一个名为Rope的数据结构。Rope其实是一种很简单，很符合直觉的树状数据结构，也常用于表达一个字符序列，不过更适合需要大量修改的场景。不过，我们还是先来回顾一下.NET与Java中的&lt;code&gt;String&lt;/code&gt;类型吧。&lt;/p&gt;

&lt;h1&gt;.NET中的String类型&lt;/h1&gt;

&lt;p&gt;.NET中的字符串是个最简单的包含了一个“长度”与“首字母”的结构。&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;String &lt;/span&gt;{
    &lt;span style="color: blue"&gt;private int &lt;/span&gt;m_stringLength;
    &lt;span style="color: blue"&gt;private char &lt;/span&gt;m_firstChar;
}&lt;/pre&gt;

&lt;p&gt;严格来说，字符串是一个与运行时紧密结合的“特殊类型”，它的&lt;code&gt;m_firstChar&lt;/code&gt;其实只是标记了第一个字符的地址。从源代码中可以看出，&lt;code&gt;String&lt;/code&gt;类型的构造函数全是&lt;code&gt;extern&lt;/code&gt;方法，它的辅助方法几乎都离不开&lt;code&gt;unsafe&lt;/code&gt;代码，例如最简单的字符串连接操作：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;internal extern static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;String &lt;/span&gt;FastAllocateString(&lt;span style="color: blue"&gt;int &lt;/span&gt;length);

&lt;span style="color: blue"&gt;internal static unsafe void &lt;/span&gt;wstrcpy(&lt;span style="color: blue"&gt;char&lt;/span&gt;* dmem, &lt;span style="color: blue"&gt;char&lt;/span&gt;* smem, &lt;span style="color: blue"&gt;int &lt;/span&gt;charCount) {
    &lt;span style="color: green"&gt;// memory copy...
&lt;/span&gt;}

&lt;span style="color: blue"&gt;private static unsafe void &lt;/span&gt;FillStringChecked(&lt;span style="color: #2b91af"&gt;String &lt;/span&gt;dest, &lt;span style="color: blue"&gt;int &lt;/span&gt;destPos, &lt;span style="color: #2b91af"&gt;String &lt;/span&gt;src) {
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(src.Length &amp;gt; dest.Length - destPos) {
        &lt;span style="color: blue"&gt;throw new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;IndexOutOfRangeException&lt;/span&gt;();
    }

    &lt;span style="color: blue"&gt;fixed &lt;/span&gt;(&lt;span style="color: blue"&gt;char&lt;/span&gt;* pDest = &amp;amp;dest.m_firstChar)
    &lt;span style="color: blue"&gt;fixed &lt;/span&gt;(&lt;span style="color: blue"&gt;char&lt;/span&gt;* pSrc = &amp;amp;src.m_firstChar) {
        wstrcpy(pDest + destPos, pSrc, src.Length);
    }
}

&lt;span style="color: blue"&gt;public static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;String &lt;/span&gt;Concat(&lt;span style="color: #2b91af"&gt;String &lt;/span&gt;str0, &lt;span style="color: #2b91af"&gt;String &lt;/span&gt;str1) {
    &lt;span style="color: green"&gt;// return String.Empty if both null or empty

    &lt;/span&gt;&lt;span style="color: blue"&gt;int &lt;/span&gt;str0Length = str0.Length;

    &lt;span style="color: #2b91af"&gt;String &lt;/span&gt;result = FastAllocateString(str0Length + str1.Length);

    FillStringChecked(result, 0, str0);
    FillStringChecked(result, str0Length, str1);

    &lt;span style="color: blue"&gt;return &lt;/span&gt;result;
}&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;wstrcpy&lt;/code&gt;做的只是简单的内存复制工作，但它的实现却有将近300行代码。原因在于，假如要获得最好的性能，不同平台（x86/x64/IA64/ARM），当前地址是否对齐，每次复制多少字节等等，都是需要考虑的因素，因此这个方法用到了大量条件编译选项。事实上整个&lt;code&gt;String&lt;/code&gt;类型都是这样，对于这种被大量使用的底层类库，.NET内部可谓进行了不遗余力的优化。&lt;/p&gt;

&lt;p&gt;还有个例子便是取字符串的&lt;code&gt;Substring&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;private unsafe string &lt;/span&gt;InternalSubString(&lt;span style="color: blue"&gt;int &lt;/span&gt;startIndex, &lt;span style="color: blue"&gt;int &lt;/span&gt;length, &lt;span style="color: blue"&gt;bool &lt;/span&gt;fAlwaysCopy) {
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(startIndex == 0 &amp;amp;&amp;amp; length == &lt;span style="color: blue"&gt;this&lt;/span&gt;.Length &amp;amp;&amp;amp; !fAlwaysCopy) {
        &lt;span style="color: blue"&gt;return this&lt;/span&gt;;
    }

    &lt;span style="color: #2b91af"&gt;String &lt;/span&gt;result = FastAllocateString(length);

    &lt;span style="color: blue"&gt;fixed &lt;/span&gt;(&lt;span style="color: blue"&gt;char&lt;/span&gt;* dest = &amp;amp;result.m_firstChar)
    &lt;span style="color: blue"&gt;fixed &lt;/span&gt;(&lt;span style="color: blue"&gt;char&lt;/span&gt;* src = &amp;amp;&lt;span style="color: blue"&gt;this&lt;/span&gt;.m_firstChar) {
        wstrcpy(dest, src + startIndex, length);
    }

    &lt;span style="color: blue"&gt;return &lt;/span&gt;result;
}&lt;/pre&gt;

&lt;p&gt;从中可以看出，无论是字符串连接还是取部分字符串，CPU和内存的消耗都与目标字符串的长度线性相关。换句话说，字符串越长，代价越高，假如要反复大量地操作一个大型的字符串，则会对性能产生很大影响。&lt;/p&gt;

&lt;p&gt;这些应该都是每个.NET程序员都了若指掌的基础。&lt;/p&gt;

&lt;h1&gt;Java中的String类型&lt;/h1&gt;

&lt;p&gt;严格来说，“Java”是一个标准，而没有限制特定的实现方式，我们这里分析的是使用最广泛的OpenJDK实现。例如在OpenJDK 7里&lt;code&gt;String&lt;/code&gt;类型是&lt;a href="http://hg.openjdk.java.net/jdk7/jdk7-gate/jdk/file/9b8c96f96a0f/src/share/classes/java/lang/String.java"&gt;这样定义&lt;/a&gt;的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color:#7f0055"&gt;public&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;final&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;class&lt;/span&gt; String {
    &lt;span style="color:#2040a0"&gt;/** The value is used for character storage. */&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;private&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;final&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;char&lt;/span&gt; value[];

    &lt;span style="color:#2040a0"&gt;/** The offset is the first index of the storage that is used. */&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;private&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;final&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; offset;

    &lt;span style="color:#2040a0"&gt;/** The count is the number of characters in the String. */&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;private&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;final&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; count;
}&lt;/pre&gt;

&lt;p&gt;此外还有一个&lt;code&gt;hash&lt;/code&gt;字段，这样单个字符串的哈希值只需计算一次即可。这里我们可以看出OpenJDK 7与.NET的不同，后者是直接包含字符序列的内容，而前者则是保留一个字符数组，并记录起始位置及其偏移量。这么做最大的好处是&lt;code&gt;substring&lt;/code&gt;方法无需复制内存，而完全可以重用内部的字符数组：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:#3f7f5f"&gt;// Package private constructor which shares value array for speed.
&lt;/span&gt;String(&lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; offset, &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; count, &lt;span style="font-weight: bold; color:#7f0055"&gt;char&lt;/span&gt; value[]) {
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.value = value;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.offset = offset;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.count = count;
}

&lt;span style="font-weight: bold; color:#7f0055"&gt;public&lt;/span&gt; String substring(&lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; beginIndex, &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; endIndex) {
    &lt;span style="color:#3f7f5f"&gt;// throw IndexOutOfBoundsException if necessary
&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;return&lt;/span&gt; ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == count)) ? &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt; :
        &lt;span style="font-weight: bold; color:#7f0055"&gt;new&lt;/span&gt; String(offset + beginIndex, endIndex - beginIndex, value);
}&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;类包含有一个package访问级别的构造函数，用于共享字符数组以提高性能。此外还有一个公有的构造函数：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color:#7f0055"&gt;public&lt;/span&gt; String(&lt;span style="font-weight: bold; color:#7f0055"&gt;char&lt;/span&gt; value[], &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; offset, &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; count) {
    &lt;span style="color:#3f7f5f"&gt;// throw StringIndexOutOfBoundsException if necessary
&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.offset = 0;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.count = count;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.value = Arrays.copyOfRange(value, offset, offset + count);
}&lt;/pre&gt;

&lt;p&gt;公有的构造函数会重新复制一份字符数组，这样就杜绝了外部修改的可能性。&lt;/p&gt;

&lt;p&gt;共享字符数组的优势显而易见，而劣势便是成为了Java程序中最常见的内存泄露原因&lt;del&gt;之一&lt;/del&gt;。说起来我到十八摸以后写的第一个程序便遇到了这个问题：从服务器端得到一个长长的字符串形式的数据，经过一个内部解析类库获得一小个片段（可能只是记录个ID）并保存在内存中。不过后来发现内存的占用量上升的很快，且稳定后比预想地要高的多，通过Memory Profiling发现原来是这一小段字符串还持有原来完整的内容。知道了原因之后自然容易解决，用以下的构造函数重新生成一个新的字符串即可：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color:#7f0055"&gt;public&lt;/span&gt; String(String original) {
    &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; size = original.count;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;char&lt;/span&gt;[] originalValue = original.value;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;char&lt;/span&gt;[] v;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;if&lt;/span&gt; (originalValue.length &amp;gt; size) {
        &lt;span style="color:#3f7f5f"&gt;// The array representing the String is bigger than the new
&lt;/span&gt;        &lt;span style="color:#3f7f5f"&gt;// String itself.  Perhaps this constructor is being called
&lt;/span&gt;        &lt;span style="color:#3f7f5f"&gt;// in order to trim the baggage, so make a copy of the array.
&lt;/span&gt;        &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; off = original.offset;
        v = Arrays.copyOfRange(originalValue, off, off+size);
    } &lt;span style="font-weight: bold; color:#7f0055"&gt;else&lt;/span&gt; {
        &lt;span style="color:#3f7f5f"&gt;// The array representing the String is the same
&lt;/span&gt;        &lt;span style="color:#3f7f5f"&gt;// size as the String, so no point in making a copy.
&lt;/span&gt;        v = originalValue;
    }
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.offset = 0;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.count = size;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;.value = v;
}&lt;/pre&gt;

&lt;p&gt;有意思的是，在未来的OpenJDK 8里，&lt;code&gt;String&lt;/code&gt;类的&lt;a href="http://hg.openjdk.java.net/jdk8/jdk8-gate/jdk/file/758db1c4c65c/src/share/classes/java/lang/String.java"&gt;这方面表现已经改变了&lt;/a&gt;：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color:#7f0055"&gt;public&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;final&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;class&lt;/span&gt; String  {
    &lt;span style="color:#2040a0"&gt;/** The value is used for character storage. */&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;private&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;final&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;char&lt;/span&gt; value[];
}&lt;/pre&gt;

&lt;p&gt;OpenJDK 8放弃了保留了近二十年的设计，让&lt;code&gt;String&lt;/code&gt;对象使用各自独立的字符数组，就跟.NET一贯以来的做法一样。这样，它的相关方法如&lt;code&gt;substring&lt;/code&gt;也有了相应改变：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="font-weight: bold; color:#7f0055"&gt;public&lt;/span&gt; String substring(&lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; beginIndex, &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; endIndex) {
    &lt;span style="color:#3f7f5f"&gt;// throw StringIndexOutOfBoundsException if necessary
&lt;/span&gt;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;int&lt;/span&gt; subLen = endIndex - beginIndex;
    &lt;span style="font-weight: bold; color:#7f0055"&gt;if&lt;/span&gt; (subLen &amp;lt; 0) {
        &lt;span style="font-weight: bold; color:#7f0055"&gt;throw&lt;/span&gt; &lt;span style="font-weight: bold; color:#7f0055"&gt;new&lt;/span&gt; StringIndexOutOfBoundsException(subLen);
    }
    &lt;span style="font-weight: bold; color:#7f0055"&gt;return&lt;/span&gt; ((beginIndex == 0) &amp;amp;&amp;amp; (endIndex == value.length)) ? &lt;span style="font-weight: bold; color:#7f0055"&gt;this&lt;/span&gt;
            : &lt;span style="font-weight: bold; color:#7f0055"&gt;new&lt;/span&gt; String(value, beginIndex, subLen);
}&lt;/pre&gt;

&lt;p&gt;这里直接调用的已经是之前列举过的，会复制字符数组内容的公有构造函数了。所以说，“Java”只是一个标准，可以有各种实现。从外部表现看来，OpenJDK 8的&lt;code&gt;String&lt;/code&gt;类相对于之前没有任何变化。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;可以看出，无论是在.NET还是Java中，字符串操作往往都涉及大量的内存复制，而Rope数据结构便是为了规避这一点而设计出来的。正如文章开头所讲的那样，Rope是一种树状的数据结构，同样用于表现一个字符序列。Rope很简单，也很符合直觉，&lt;a href="http://libra.msra.cn/Publication/12947/ropes-an-alternative-to-strings"&gt;一篇简单的论文&lt;/a&gt;即可说清，&lt;a href="http://en.wikipedia.org/wiki/Rope_(data_structure)"&gt;Wikipedia上也有部分描述&lt;/a&gt;。下篇文章里我会简单描述Rope这个数据结构，包括它的特点和常见操作的基本算法等等。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/03/string-and-rope-1-string-in-dotnet-and-java.html#comments</comments>
      <pubDate>Tue, 12 Mar 2013 23:29:27 GMT</pubDate>
      <lastBuildDate>Fri, 22 Mar 2013 11:52:56 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <category domain="http://blog.zhaojie.me/reading/">阅读相关</category>
      <title>Everpage：将Evernote的笔记展现在页面上</title>
      <link>http://blog.zhaojie.me/2013/03/everpage-load-and-display-notes-from-evernote-on-the-page.html</link>
      <guid>http://blog.zhaojie.me/2013/03/everpage-load-and-display-notes-from-evernote-on-the-page.html</guid>
      <description>&lt;p&gt;我这人尤其强调阅读体验，无论是作为&lt;a href="http://blog.zhaojie.me/2010/08/get-a-better-style-for-reading.html"&gt;文章的读者&lt;/a&gt;还是&lt;a href="http://blog.zhaojie.me/2010/08/my-view-of-good-blogging-theme.html"&gt;作者&lt;/a&gt;。假如遇到一篇格式糟糕的文章，我会完全没有耐心读完它。我对于阅读工具的展现格式也是各种挑剔，例如字不能太小，内容不能太宽或太窄，段落间距必须大过行间距等等，例如OS X上著名的RSS阅读器&lt;a href="http://reederapp.com/mac/"&gt;Reeder&lt;/a&gt;无法自定义样式，我甚至钻进其App内部修改其CSS文件。Evernote也是一样，无论是其网页版还是客户端，其阅读体验在我看来都比较糟糕，于是我在愤而花了差不多半天的时间打造了&lt;a href="http://everpage.zhaojie.me/"&gt;Everpage&lt;/a&gt;这个小玩意儿。简单来说，就是把一篇Evernote笔记显示在页面上。&lt;/p&gt;

&lt;p&gt;就拿Evernote客户端来说，它无法放大字体——我不是说设置文字的大小，我是指“展现时”的默认大小。小而密集的文字容易让人疲惫，换行时也容易丢失视线。而Evernote网页版虽然可以用浏览器放大字体功能，但是现在的浏览器都是以“域名”为单位记录当前缩放尺寸，这导致整个Evernote网站的文字都放大了，而我只需要“正文”放大。更何况，Evernote网页版显示的代码片段和后续文字之间的间距过窄，这更不是调整文字大小能解决的问题了，如图：&lt;/p&gt;

&lt;p&gt;&lt;a data-popup="image" data-popup-width="666" href="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/1.png"&gt;
    &lt;img width="500" alt="Code on Evernote Web" src="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/1.png" /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我一直搞不懂为什么Evernote都已经这么久了还有阅读体验上的问题，尽管它有一个&lt;a href="http://evernote.com/clearly/"&gt;Evernote Clearly&lt;/a&gt;的浏览器插件，可以像&lt;a href="http://www.readability.com/"&gt;Readability&lt;/a&gt;那样可以提取页面正文并进行格式化展现，但它最终只提供了“存入”笔记的功能，并不能“取出”笔记来读。有意思的是，Evernote网页版上的笔记并不能用Clearly来改善阅读体验，因为它会将笔记内容用AJAX加载出来并显示在iframe里，而目前各种正文格式化插件都不支持iframe。&lt;/p&gt;

&lt;p&gt;其实网页版上的一些格式化问题可以用&lt;a href="https://addons.mozilla.org/en-US/firefox/addon/stylish/"&gt;Stylish&lt;/a&gt;或&lt;a href="https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/"&gt;Greasemonkey&lt;/a&gt;来“定向处理”，但最终我还是选择了创建一个简单的网页版的笔记显示功能，这样便可以用Clearly或Readability做进一步的处理了。&lt;/p&gt;

&lt;p&gt;我本来想用Node.js来做这个简单的功能，但发现&lt;a href="http://dev.evernote.com/documentation/cloud/"&gt;Evernote的Cloud API&lt;/a&gt;并&lt;a href="http://dev.evernote.com/start/guides/"&gt;没有提供Node.js的SDK&lt;/a&gt;。Evernote的Cloud API并非使用简单的Restful接口，而是使用了Thrift框架，因此假如没有一个现成的Node.js代码生成器，我们很难调用其API（就跟调用SOAP一个道理），因此最终我还是选择使用ASP.NET（.NET 4 + ASP.NET MVC 3）开发了Everpage。&lt;/p&gt;

&lt;p&gt;后来我又发现，假如Everpage要接入用户认证，则需要实现OAuth，而且还要像Evernote提交申请才能获得生产环境的&lt;a href="http://dev.evernote.com/start/core/permissions.php"&gt;API Key&lt;/a&gt;。我又不是想认真做一个功能完整应用，才不想搞那么多（还要SSL等等），而且这就无法在几个小时内完成了。还好，Evernote允许每个用户申请自身的&lt;a href="http://dev.evernote.com/start/core/authentication.php#devtoken"&gt;Developer Token&lt;/a&gt;，使用Dev Token则可以访问自己账户下的信息，这对我来说就已经足够了。因此，假如您要使用Everpage，则最好是去&lt;a href="https://www.evernote.com/api/DeveloperToken.action"&gt;申请一个自己的Dev Token&lt;/a&gt;，如下：&lt;/p&gt;

&lt;p&gt;&lt;a data-popup="image" data-popup-width="933" href="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/2.png"&gt;
    &lt;img width="500" alt="Developer Token" src="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/2.png" /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个Token有效期为一年，中途也可以随时销毁或重新申请。有了Auth Token之后，就可以提供需要加载的笔记“标示符”了。例如所谓的&lt;a href="http://dev.evernote.com/documentation/cloud/chapters/note_links.php"&gt;笔记链接&lt;/a&gt;，也就是以“evernote:///”开始的一个字符串，在客户端里我们可以对笔记点击右键，并选择“Copy Note Link”：&lt;/p&gt;

&lt;p&gt;&lt;img width="289" alt="Copy Note Link" src="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/3.png" /&gt;&lt;/p&gt;

&lt;p&gt;您也可以从中剥取出笔记的GUID，当然一般来说没有这么做的必要。此外，我发现在Evernote的Web版里似乎较难获得笔记链接，不过我们可以在新窗口里打开笔记，并且复制出新窗口的浏览器地址：&lt;/p&gt;

&lt;p&gt;&lt;img width="483" alt="Note in Separate Window" src="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/4.png" /&gt;&lt;/p&gt;

&lt;p&gt;这样Everpage便能将笔记内容显示在页面上了，配合Clearly即可获得很好的阅读体验：&lt;/p&gt;

&lt;p&gt;&lt;a data-popup="image" data-popup-width="944" href="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/5.png"&gt;
    &lt;img width="500" alt="Read with Clearly" src="http://img.zhaojie.me/blog/everpage-load-and-display-notes-from-evernote-on-the-page/5.png" /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;假如笔记中的图片显示不出来，则可能是您没有登陆的缘故，打开另一个浏览器窗口（标签）登陆您的Evernote Web版即可。建议勾选“Remember me for a week”，这样一周内均可反复使用Everpage，无需重新登陆。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/JeffreyZhao/everpage"&gt;Everpage的源代码都放在GitHub上了&lt;/a&gt;，您可以自由查看，需要的话尽管拿去，反正也没几行代码。&lt;a href="https://github.com/JeffreyZhao/everpage/blob/master/src/Everpage/index.html"&gt;首页前端&lt;/a&gt;有些耗费精力，别看这么简单，测试笔记标示符的正则表达式花了不少时间的，不过最花时间的还是将笔记内容中的&lt;code&gt;&amp;lt;en-media /&amp;gt;&lt;/code&gt;标签替换为&lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt;的部分了，找了点资料才了解到具体是怎么回事。当然整个开发才花了3、4个小时，所以其实也没多少事情。&lt;/p&gt;

&lt;p&gt;假如您相信我不会偷您的笔记资料，也可以试着直接使用线上的&lt;a href="http://everpage.zhaojie.me/"&gt;Everpage页面&lt;/a&gt;。网站部署在Linode东京机房的虚拟机上，操作系统为Ubuntu Server，Web服务器是Apache，并基于Mono 2.10和mod_mono模块。可惜周日为了升级Mono而搞坏了一些配置，还顺手更新了一些前端插件，因此文章拖到到现在才发布。当然，每次打开笔记时都要直接去Evernote读取资料，因此速度总有些慢，一般也要花费2、3秒左右的时间才能打开一份稍长的笔记，在本地测试时更是需要20秒左右，将就着用吧。&lt;/p&gt;

&lt;p&gt;对了，Everpage目前不支持Evernote China（&lt;a href="http://www.yinxiang.com/"&gt;印象笔记&lt;/a&gt;），尽管似乎也就需要替换个URL就行了，但是我不想支持，建议您也别用。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/03/everpage-load-and-display-notes-from-evernote-on-the-page.html#comments</comments>
      <pubDate>Thu, 07 Mar 2013 01:00:08 GMT</pubDate>
      <lastBuildDate>Mon, 01 Jul 2013 21:51:07 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/essential/">重中之重</category>
      <title>真是O(1)吗？想清楚了没？</title>
      <link>http://blog.zhaojie.me/2013/01/think-in-detail-why-its-o-1.html</link>
      <guid>http://blog.zhaojie.me/2013/01/think-in-detail-why-its-o-1.html</guid>
      <description>&lt;p&gt;当然标题里这个O(1)可以换成任何复杂度。&lt;/p&gt;

&lt;p&gt;话说写程序的时候我们会用到各种数据结构，但十有八九不会由我们自己从头写起，都会直接拿来用。于是很多人就会记住，譬如&lt;code&gt;HashMap&lt;/code&gt;或&lt;code&gt;Dictionary&lt;/code&gt;的存取是O(1)的操作，二分查找什么的则是O(log(N))。不过，我们在实践中直接把这些类拿来用的时候，最好也留个心眼，知道这些类内部到底做了些什么，为什么它们能够达到O(1)之类的时间复杂度。&lt;/p&gt;

&lt;p&gt;例如，我们都知道&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;的&lt;code&gt;Add&lt;/code&gt;是O(1)的操作，但之所以它是O(1)，是因为它的“扩容”操作被均摊了（amortized），但每次扩容时其实还是需要复制所有元素，次数越少越好，于是实践中在可行的情况下我们往往应该给它指定一个初始容量——用&lt;code&gt;StringBuilder&lt;/code&gt;的时候也是一样。&lt;/p&gt;

&lt;p&gt;我这里还可以再举一个更为复杂的例子，例如&lt;code&gt;HashSet&lt;/code&gt;和&lt;code&gt;SortedSet&lt;/code&gt;，我们要向其中添加N个元素（如字符串），哪个会更快一些？从文档上可以知道，&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;Add&lt;/code&gt;方法是O(1)的操作，而&lt;code&gt;SortedSet&lt;/code&gt;内部是用了&lt;a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree"&gt;红黑树&lt;/a&gt;，它的&lt;code&gt;Add&lt;/code&gt;方法是O(log(N))的操作（但它能顺序输出元素）。显然，从时间复杂度上来讲，&lt;code&gt;SortedSet&lt;/code&gt;的性能要落后于&lt;code&gt;HashSet&lt;/code&gt;，不过我们能否设计一个用例，让&lt;code&gt;HashSet&lt;/code&gt;慢于&lt;code&gt;SortedSet&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;当然可以，例如以前那个&lt;a href="http://www.ocert.org/advisories/ocert-2011-003.html"&gt;由哈希碰撞引起的DoS安全漏洞&lt;/a&gt;，其实就是设计了一些Hash Code相同，但具体内容不同的字符串，让Dictionary（原理与&lt;code&gt;HashSet&lt;/code&gt;相同）&lt;code&gt;Add&lt;/code&gt;/&lt;code&gt;Remove&lt;/code&gt;操作的时间复杂度从O(1)退化为O(N)，这显然低于O(log(N))。不过如今的BCL中的实现已经对碰撞次数设置了阈值，超过这个阈值则会对哈希函数进行随机化，因此这种做法已经很难生效了。所以这里我们可以设计出另一个案例，且看代码：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static string&lt;/span&gt;[] GetRandomStrings(&lt;span style="color: blue"&gt;int &lt;/span&gt;number, &lt;span style="color: blue"&gt;int &lt;/span&gt;length) {
    &lt;span style="color: blue"&gt;var &lt;/span&gt;random = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Random&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;DateTime&lt;/span&gt;.Now.Millisecond);
    &lt;span style="color: blue"&gt;var &lt;/span&gt;array = &lt;span style="color: blue"&gt;new string&lt;/span&gt;[number];
    &lt;span style="color: blue"&gt;var &lt;/span&gt;buffer = &lt;span style="color: blue"&gt;new char&lt;/span&gt;[length];

    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = 0; i &amp;lt; array.Length; i++) {
        &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;j = 0; j &amp;lt; buffer.Length; j++) {
            buffer[j] = (&lt;span style="color: blue"&gt;char&lt;/span&gt;)(random.Next(&lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;.MinValue, &lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;.MaxValue) + 1);
        }

        array[i] = &lt;span style="color: blue"&gt;new string&lt;/span&gt;(buffer);
    }

    &lt;span style="color: #2b91af"&gt;Console&lt;/span&gt;.WriteLine(&lt;span style="color: #a31515"&gt;&amp;quot;Generated&amp;quot;&lt;/span&gt;);

    &lt;span style="color: blue"&gt;return &lt;/span&gt;array;
}

&lt;span style="color: blue"&gt;static void &lt;/span&gt;CollectGarbage() {
    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = 0; i &amp;lt; 10; i++) {
        &lt;span style="color: #2b91af"&gt;GC&lt;/span&gt;.Collect();
        &lt;span style="color: #2b91af"&gt;GC&lt;/span&gt;.WaitForPendingFinalizers();
    }
}

&lt;span style="color: blue"&gt;static void &lt;/span&gt;AddToSetTime(&lt;span style="color: blue"&gt;string &lt;/span&gt;name, &lt;span style="color: #2b91af"&gt;ISet&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;string&lt;/span&gt;&amp;gt; set, &lt;span style="color: blue"&gt;string&lt;/span&gt;[] array) {
    CollectGarbage();

    &lt;span style="color: blue"&gt;var &lt;/span&gt;watch = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Stopwatch&lt;/span&gt;();
    watch.Start();

    &lt;span style="color: blue"&gt;foreach &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;s &lt;span style="color: blue"&gt;in &lt;/span&gt;array) {
        set.Add(s);
    }

    &lt;span style="color: #2b91af"&gt;Console&lt;/span&gt;.WriteLine(name + &lt;span style="color: #a31515"&gt;&amp;quot;: &amp;quot; &lt;/span&gt;+ watch.ElapsedMilliseconds);
}

&lt;span style="color: blue"&gt;static void &lt;/span&gt;Main() {
    &lt;span style="color: blue"&gt;var &lt;/span&gt;array = GetRandomStrings(5000, 50000);

    AddToSetTime(&lt;span style="color: #a31515"&gt;&amp;quot;HashSet&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;HashSet&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;string&lt;/span&gt;&amp;gt;(), array);
    AddToSetTime(&lt;span style="color: #a31515"&gt;&amp;quot;SortedSet&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;SortedSet&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;string&lt;/span&gt;&amp;gt;(), array);
}&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GetRandomStrings&lt;/code&gt;方法用于生成一系列的随机字符串，我们会将这些字符串使用&lt;code&gt;AddToSetTime&lt;/code&gt;方法放入一个集合类中，并输出耗时。这段程序在我的机器上输出：&lt;/p&gt;

&lt;pre class="code"&gt;Generated
HashSet: 165
SortedSet: 17&lt;/pre&gt;

&lt;p&gt;您可以自己尝试一下，具体数值可能不同，但&lt;code&gt;HashSet&lt;/code&gt;显著慢于&lt;code&gt;SortedSet&lt;/code&gt;则基本是确定的。为什么会这样？O(1)为什么完败于O(log(N))？难道&lt;code&gt;HashSet&lt;/code&gt;的常数就那么大么？其实原因很简单，我们只需想想&lt;code&gt;HashSet&lt;/code&gt;和&lt;code&gt;SortedSet&lt;/code&gt;分别是怎么实现的就行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;HashSet&lt;/code&gt;：调用元素的&lt;code&gt;GetHashCode&lt;/code&gt;方法获得Hash Code，算出该元素放在哪个Bucket中，然后顺着链表使用&lt;code&gt;Equals&lt;/code&gt;方法依次比较Hash Code的相同元素。由于Hash Code散列程度较高，相同Bucket中重复元素极少，因此时间复杂度近似为O(1)。 &lt;/li&gt;

  &lt;li&gt;&lt;code&gt;SortedSet&lt;/code&gt;：使用&lt;code&gt;CompareTo&lt;/code&gt;方法比较新元素与红黑树里的元素，以此决定元素的树中的“走向”，需要时再进行“平衡”操作。由于一颗平衡二叉树的高度为log(N)，因此添加一个元素要进行大约log(N)次比较（以及最多log(N)次O(1)的平衡操作），其时间复杂度大约为O(log(N))。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看起来很正常嘛，但是其中还隐含一些“假设”，那就是&lt;code&gt;GetHashCode&lt;/code&gt;、&lt;code&gt;Equals&lt;/code&gt;还有&lt;code&gt;CompareTo&lt;/code&gt;方法都是O(1)的操作，但事实真是如此吗？针对以上代码生成的随机字符串来说，&lt;code&gt;Equals&lt;/code&gt;和&lt;code&gt;CompareTo&lt;/code&gt;方法都可以几乎瞬间返回（比较第一个字符即可）。不过&lt;code&gt;GetHashCode&lt;/code&gt;便麻烦一些了，便顺手从BCL的代码里摘抄出来吧：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;namespace &lt;/span&gt;System {

    &lt;span style="color:blue;"&gt;public sealed class&lt;/span&gt; &lt;span style="color:#2b91af"&gt;String&lt;/span&gt; {

        &lt;span style="color: blue"&gt;public override int &lt;/span&gt;GetHashCode() {

&lt;span style="color: blue"&gt;#if &lt;/span&gt;FEATURE_RANDOMIZED_STRING_HASHING
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;HashHelpers&lt;/span&gt;.s_UseRandomizedStringHashing) {
                &lt;span style="color: blue"&gt;return &lt;/span&gt;InternalMarvin32HashString(&lt;span style="color: blue"&gt;this&lt;/span&gt;, &lt;span style="color: blue"&gt;this&lt;/span&gt;.Length, 0);
            }
&lt;span style="color: blue"&gt;#endif&lt;/span&gt; &lt;span style="color: green"&gt;// FEATURE_RANDOMIZED_STRING_HASHING&lt;/span&gt;

            &lt;span style="color: blue"&gt;unsafe &lt;/span&gt;{
                &lt;span style="color: blue"&gt;fixed &lt;/span&gt;(&lt;span style="color: blue"&gt;char&lt;/span&gt;* src = &lt;span style="color: blue"&gt;this&lt;/span&gt;) {
                    &lt;span style="color: #2b91af"&gt;Contract&lt;/span&gt;.Assert(src[Length] == &lt;span style="color: #a31515"&gt;'\0'&lt;/span&gt;, &lt;span style="color: #a31515"&gt;&amp;quot;src[this.Length] == '\\0'&amp;quot;&lt;/span&gt;);
                    &lt;span style="color: #2b91af"&gt;Contract&lt;/span&gt;.Assert(((&lt;span style="color: blue"&gt;int&lt;/span&gt;)src) % 4 == 0, &lt;span style="color: #a31515"&gt;&amp;quot;Managed string should start at 4 bytes boundary&amp;quot;&lt;/span&gt;);

&lt;span style="color: blue"&gt;#if &lt;/span&gt;WIN32
                    &lt;span style="color: blue"&gt;int &lt;/span&gt;hash1 = (5381 &amp;lt;&amp;lt; 16) + 5381;
&lt;span style="color: blue"&gt;#else&lt;/span&gt;
                    &lt;span style="color: blue"&gt;int &lt;/span&gt;hash1 = 5381;
&lt;span style="color: blue"&gt;#endif
                    int &lt;/span&gt;hash2 = hash1;

&lt;span style="color: blue"&gt;#if &lt;/span&gt;WIN32
                    &lt;span style="color: green"&gt;// 32 bit machines. 
                    &lt;/span&gt;&lt;span style="color: blue"&gt;int&lt;/span&gt;* pint = (&lt;span style="color: blue"&gt;int&lt;/span&gt;*)src;
                    &lt;span style="color: blue"&gt;int &lt;/span&gt;len = Length;
                    &lt;span style="color: blue"&gt;while &lt;/span&gt;(len &amp;gt; 2) {
                        hash1 = ((hash1 &amp;lt;&amp;lt; 5) + hash1 + (hash1 &amp;gt;&amp;gt; 27)) ^ pint[0];
                        hash2 = ((hash2 &amp;lt;&amp;lt; 5) + hash2 + (hash2 &amp;gt;&amp;gt; 27)) ^ pint[1];
                        pint += 2;
                        len -= 4;
                    }

                    &lt;span style="color: blue"&gt;if &lt;/span&gt;(len &amp;gt; 0) {
                        hash1 = ((hash1 &amp;lt;&amp;lt; 5) + hash1 + (hash1 &amp;gt;&amp;gt; 27)) ^ pint[0];
                    }
&lt;span style="color: blue"&gt;#else&lt;/span&gt;
                    &lt;span style="color: blue"&gt;int &lt;/span&gt;c;
                    &lt;span style="color: blue"&gt;char&lt;/span&gt;* s = src;
                    &lt;span style="color: blue"&gt;while &lt;/span&gt;((c = s[0]) != 0) {
                        hash1 = ((hash1 &amp;lt;&amp;lt; 5) + hash1) ^ c;
                        c = s[1];
                        &lt;span style="color: blue"&gt;if &lt;/span&gt;(c == 0)
                            &lt;span style="color: blue"&gt;break&lt;/span&gt;;
                        hash2 = ((hash2 &amp;lt;&amp;lt; 5) + hash2) ^ c;
                        s += 2;
                    }
&lt;span style="color: blue"&gt;#endif

#if &lt;/span&gt;DEBUG
                    &lt;span style="color: green"&gt;// We want to ensure we can change our hash function daily.
                    // This is perfectly fine as long as you don't persist the 
                    // value from GetHashCode to disk or count on String A 
                    // hashing before string B.  Those are bugs in your code.
                    &lt;/span&gt;hash1 ^= &lt;span style="color: #2b91af"&gt;ThisAssembly&lt;/span&gt;.DailyBuildNumber;
&lt;span style="color: blue"&gt;#endif

                    return &lt;/span&gt;hash1 + (hash2 * 1566083941);
                }
            }
        }
    }
}&lt;/pre&gt;

&lt;p&gt;从代码里可以看出，撇开最先的&lt;code&gt;InternalMarvin32HashString&lt;/code&gt;这个不谈，其他分支下的哈希算法都是与字符串的长度呈线性关系。至于Marvin32这个神秘的哈希算法，我只知道可用于避免哈希碰撞攻击，但搜索了半天都找不到它的具体信息，只有一个“疑似”的&lt;a href="https://github.com/floodyberry/Marvin32"&gt;简化实现&lt;/a&gt;。目前，我们还是用简单的测试来验证字符串长度与&lt;code&gt;GetHashCode&lt;/code&gt;方法耗时的关系：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;static void &lt;/span&gt;GetHashCodeTime(&lt;span style="color:blue;"&gt;string &lt;/span&gt;name, &lt;span style="color:blue;"&gt;string &lt;/span&gt;str, &lt;span style="color:blue;"&gt;int &lt;/span&gt;iteration) {
    CollectGarbage();

    str.GetHashCode(); &lt;span style="color:green;"&gt;// warm up

    &lt;/span&gt;&lt;span style="color:blue;"&gt;var &lt;/span&gt;watch = &lt;span style="color:blue;"&gt;new &lt;/span&gt;&lt;span style="color:#2b91af;"&gt;Stopwatch&lt;/span&gt;();
    watch.Start();

    &lt;span style="color:blue;"&gt;for &lt;/span&gt;(&lt;span style="color:blue;"&gt;var &lt;/span&gt;i = 0; i &amp;lt; iteration; i++) {
        str.GetHashCode();
    }

    &lt;span style="color:#2b91af;"&gt;Console&lt;/span&gt;.WriteLine(name + &lt;span style="color:#a31515;"&gt;": " &lt;/span&gt;+ watch.ElapsedMilliseconds);
}

&lt;span style="color:blue;"&gt;static void &lt;/span&gt;Main() {
    &lt;span style="color:blue;"&gt;var &lt;/span&gt;shortStr = &lt;span style="color:blue;"&gt;new string&lt;/span&gt;(&lt;span style="color:#a31515;"&gt;'a'&lt;/span&gt;, 100);
    &lt;span style="color:blue;"&gt;var &lt;/span&gt;longStr = &lt;span style="color:blue;"&gt;new string&lt;/span&gt;(&lt;span style="color:#a31515;"&gt;'a'&lt;/span&gt;, 10000);

    &lt;span style="color:blue;"&gt;var &lt;/span&gt;iteration = 1000000;

    GetHashCodeTime(&lt;span style="color:#a31515;"&gt;"Short"&lt;/span&gt;, shortStr, iteration);
    GetHashCodeTime(&lt;span style="color:#a31515;"&gt;"Long"&lt;/span&gt;, longStr, iteration);
}&lt;/pre&gt;

&lt;p&gt;我们创建了长度相差百倍的字符串，并比较其&lt;code&gt;GetHashCode&lt;/code&gt;方法的耗时。我们可以&lt;a href="http://msdn.microsoft.com/en-us/library/jj152924.aspx"&gt;开启随机化的字符串哈希算法（即使用Marvin32哈希算法）&lt;/a&gt;，例如打开之后在我的机器上执行结果是：&lt;/p&gt;

&lt;pre class="code"&gt;Short: 114
Long: 9142&lt;/pre&gt;

&lt;p&gt;耗时与长度基本呈线性关系。关闭“随机化哈希”之后执行速度略有提高，但耗时与长度的关系依然不变，其实从代码上也已经能够看出这点。&lt;/p&gt;

&lt;p&gt;再回到最早针对&lt;code&gt;HashSet&lt;/code&gt;和&lt;code&gt;SortedSet&lt;/code&gt;的实验，由于我故意生成了长度高达5w的字符串，因此&lt;code&gt;HashSet&lt;/code&gt;时间复杂度为O(1)又如何？单次&lt;code&gt;GetHashCode&lt;/code&gt;方法调用的耗时，就已经远远超过许多次&lt;code&gt;CompareTo&lt;/code&gt;方法了。从中我们也可以看出，假如我们用字符串作为字典的键，其效率会较&lt;code&gt;int&lt;/code&gt;或是普通未重载过&lt;code&gt;GetHashCode&lt;/code&gt;和&lt;code&gt;Equals&lt;/code&gt;方法的类型为低。话说回来，其实用一个最普通的类作为字典的键效率很高，因为它的&lt;code&gt;GetHashCode&lt;/code&gt;可以直接返回它的初始地址，而&lt;code&gt;Equals&lt;/code&gt;方法则直接比较两个对象的引用。&lt;/p&gt;

&lt;p&gt;在实践中，我遇到各种需要以字符串作为键的场景，我都会思考下有没有简单的替代方法，例如使用&lt;code&gt;int&lt;/code&gt;做键，甚至直接使用数组。例如，前段时间&lt;a href="http://weibo.com/haoel"&gt;@左耳朵耗子&lt;/a&gt;提到对一个csv文件里的数据进行排序，我们可以使用一个字典来保存一行数据，其中键为字段名：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:#2b91af;"&gt;List&lt;/span&gt;&amp;lt;&lt;span style="color:#2b91af;"&gt;Dictionary&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;string&lt;/span&gt;, &lt;span style="color:blue;"&gt;string&lt;/span&gt;&amp;gt;&amp;gt; data = ...;
&lt;span style="color:blue;"&gt;var &lt;/span&gt;ordered = data
    .OrderBy(row =&amp;gt; row[&lt;span style="color:#a31515;"&gt;"column0"&lt;/span&gt;]) &lt;span style="color:green;"&gt;// 先以column0排序
    &lt;/span&gt;.ThenBy(row =&amp;gt; row[&lt;span style="color:#a31515;"&gt;"column1"&lt;/span&gt;]); &lt;span style="color:green;"&gt;// 再以column1排序&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;但更有效率（内存使用也更紧凑）的做法是以一个数组来保存一行数据。我们先找出需要排序的列的下标，然后再从数组中找出排序用的字段值：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;string&lt;/span&gt;[] columns = ...;
&lt;span style="color:blue;"&gt;var &lt;/span&gt;index0 = columns.IndexOf(&lt;span style="color:#a31515;"&gt;"column0"&lt;/span&gt;);
&lt;span style="color:blue;"&gt;var &lt;/span&gt;index1 = columns.IndexOf(&lt;span style="color:#a31515;"&gt;"column1"&lt;/span&gt;);

&lt;span style="color:#2b91af;"&gt;List&lt;/span&gt;&amp;lt;&lt;span style="color:blue;"&gt;string&lt;/span&gt;[]&amp;gt; data = ...;
&lt;span style="color:blue;"&gt;var &lt;/span&gt;ordered = data
    .OrderBy(row =&amp;gt; row[index0])
    .ThenBy(row =&amp;gt; row[index1]);&lt;/pre&gt;

&lt;p&gt;从理论上讲，两种做法的时间复杂度一致，但实际上后者比前者会有不少提高。我们在了解“理论”的同时也需要注意实践上的细节，例如，其实在&lt;a href="http://stackoverflow.com/questions/1491795/olog-n-o1-why-not"&gt;实践中O(log(N))其实也是个不比O(1)大多少的时间复杂度&lt;/a&gt;，此时可能也需要考虑下“常数”会对性能造成多大影响。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/01/think-in-detail-why-its-o-1.html#comments</comments>
      <pubDate>Fri, 18 Jan 2013 11:21:54 GMT</pubDate>
      <lastBuildDate>Fri, 18 Jan 2013 20:24:41 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <title>一个最基本的HashedLinkedList</title>
      <link>http://blog.zhaojie.me/2013/01/a-basic-hashed-linked-list.html</link>
      <guid>http://blog.zhaojie.me/2013/01/a-basic-hashed-linked-list.html</guid>
      <description>&lt;p&gt;&lt;a href="https://github.com/JeffreyZhao/Tmc"&gt;Tmc&lt;/a&gt;的初衷是补充一些常用的数据结构，例如&lt;a href="http://blog.zhaojie.me/2012/12/nullablekey-nullable-key-in-dictionary.html"&gt;对&lt;code&gt;null&lt;/code&gt;作为字典键的支持&lt;/a&gt;，以及带有一个&lt;a href="http://blog.zhaojie.me/2013/01/reading-dotnet-source-code.html"&gt;额外&lt;code&gt;Remove&lt;/code&gt;方法的&lt;code&gt;HashDictionary&lt;/code&gt;&lt;/a&gt;。但是，其实我创建Tmc项目的“初衷”却是&lt;code&gt;HashedLinkedList&lt;/code&gt;。.NET BCL中已经有一个&lt;code&gt;LinkedList&lt;/code&gt;，这是一个双向链表。说起来，我之前在面试中经常会提出一系列数据结构的基础问题，其中便包含&lt;code&gt;LinkedList&lt;/code&gt;，我会问各个操作的时间复杂度，以及如何改进它们。例如，如何将它的&lt;code&gt;Remove&lt;/code&gt;操作优化成O(1)的时间复杂度？最容易想到的做法便是使用一个字典来记录元素到特定&lt;code&gt;LinkedListNode&lt;/code&gt;的映射关系。这种模式实在过于常见，所以便有了个特别的名称，叫做&lt;code&gt;HashedLinkedList&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;好吧，其实在&lt;a href="http://www.itu.dk/research/c5/"&gt;C5&lt;/a&gt;中已经有了一个&lt;a href="https://github.com/sestoft/C5/blob/master/C5/linkedlists/HashedLinkedList.cs"&gt;&lt;code&gt;HashedLinkedList&lt;/code&gt;类&lt;/a&gt;，但是有重大缺陷，例如没有暴露出&lt;code&gt;LinkedListNode&lt;/code&gt;这个类型。我们来看下.NET BCL中&lt;code&gt;LinkedList&lt;/code&gt;的一些方法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt;
{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedList&lt;/span&gt;&amp;lt;T&amp;gt; List { &lt;span style="color: blue"&gt;get&lt;/span&gt;; }
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; Next { &lt;span style="color: blue"&gt;get&lt;/span&gt;; }
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; Previous { &lt;span style="color: blue"&gt;get&lt;/span&gt;; }
    &lt;span style="color: blue"&gt;public &lt;/span&gt;T Value { &lt;/span&gt;&lt;span style="color: blue"&gt;get&lt;/span&gt;; &lt;span style="color: blue"&gt;set&lt;/span&gt;; }
}

&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedList&lt;/span&gt;&amp;lt;T&amp;gt;
{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; AddFirst(T value);
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; AddLast(T value);
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; AddBefore(&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; node, T value);
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; AddAfter(&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; node, T value);
    &lt;span style="color: green"&gt;// ...&lt;/span&gt;
}&lt;/pre&gt;

&lt;p&gt;.NET BCL的&lt;code&gt;LinkedList&lt;/code&gt;会暴露出配套的&lt;code&gt;LinkedListNode&lt;/code&gt;，这样我们便可以保留&lt;code&gt;LinkedListNode&lt;/code&gt;对象，并执行O(1)实现复杂度的快速插入。此外，我们还可以根据&lt;code&gt;LinkedListNode&lt;/code&gt;的&lt;code&gt;Next&lt;/code&gt;和&lt;code&gt;Previous&lt;/code&gt;进行前后遍历，这才是真正的“链表”。之前有人问我，为什么&lt;code&gt;LinkedList&lt;/code&gt;不实现&lt;code&gt;IList&lt;/code&gt;接口呢？我的看法就是&lt;code&gt;LinkedList&lt;/code&gt;和&lt;code&gt;List&lt;/code&gt;在表现上的区别实在太大，而&lt;code&gt;IList&lt;/code&gt;的含义是后者，因此就放过&lt;code&gt;LinkedList&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;其实，完全从外部实现一个&lt;code&gt;HashedLinkedList&lt;/code&gt;（的部分功能）也不难，我们只要封装一个&lt;code&gt;LinkedList&lt;/code&gt;和一个&lt;code&gt;Dictionary&lt;/code&gt;即可。例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;HashedLinkedList&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: blue"&gt;private readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedList&lt;/span&gt;&amp;lt;T&amp;gt; _list = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedList&lt;/span&gt;&amp;lt;T&amp;gt;();
    &lt;span style="color: blue"&gt;private readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;T, &lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt;&amp;gt; _nodes = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;T, &lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt;&amp;gt;();

    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; AddLast(T value) {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;node = _list.AddLast(value);
        _nodes.Add(value, node);

        &lt;span style="color: blue"&gt;return &lt;/span&gt;node;
    } 

    &lt;span style="color: blue"&gt;public void &lt;/span&gt;Remove(T value) {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;node = _nodes[value];
        _nodes.Remove(value);
        _list.Remove(node);
    }
}&lt;/pre&gt;

&lt;p&gt;当然，这种“粗制滥造”的&lt;code&gt;HashedLinkedList&lt;/code&gt;类完全不能作为通用的数据结构来使用，但假如是普通项目需要，这么做往往也够了。而且事实上一个“通用”的&lt;code&gt;HashLinkedList&lt;/code&gt;的确也会遇到很多决策问题，例如：是否支持相同元素？我们知道.NET BCL中的&lt;code&gt;LinkedList&lt;/code&gt;是支持相同元素的（事实上&lt;code&gt;LinkedListNode&lt;/code&gt;的&lt;code&gt;Value&lt;/code&gt;属性可读可写），但显然上面这个粗糙的&lt;code&gt;HashedLinkedList&lt;/code&gt;便不支持。&lt;/p&gt;

&lt;p&gt;有人可能会说，支持相同元素很容易呀，只要用&lt;code&gt;Dictionary&amp;lt;T, List&amp;lt;LinkedListNode&amp;gt;&amp;gt;&lt;/code&gt;或类似的结构，将一个值映射到多个&lt;code&gt;LinkedListNode&lt;/code&gt;就行了。这可能会解决一部分问题，但事情远没有那么简单。例如.NET BCL的&lt;code&gt;LinkedList&lt;/code&gt;还有&lt;code&gt;Find(T value)&lt;/code&gt;和&lt;code&gt;FindLast(T value)&lt;/code&gt;这两个方法，分别用来找出“第一个”和“最后一个”与&lt;code&gt;value&lt;/code&gt;相等的&lt;code&gt;LinkedListNode&lt;/code&gt;。没错，&lt;code&gt;LinkedList&lt;/code&gt;是有顺序的，假如我们要保留&lt;code&gt;Find&lt;/code&gt;和&lt;code&gt;FindLast&lt;/code&gt;的语义不变，就没法提供O(1)的时间复杂度的实现——不信你试试看？&lt;/p&gt;

&lt;p&gt;假如我们还是用遍历的方法来实现&lt;code&gt;Find&lt;/code&gt;和&lt;code&gt;FindLast&lt;/code&gt;，这便失去了&lt;code&gt;HashedLinkedList&lt;/code&gt;的意义。但是反过来说，在很多时候，我们可以确定不需要其支持相同元素，或者无所谓&lt;code&gt;Find&lt;/code&gt;得到的是其中的哪个节点呐。我估计这也是.NET BCL中不提供&lt;code&gt;HashedLinkedList&lt;/code&gt;的缘故吧，既然没法“通用”，那么就由开发人员自己根据需要来组合吧。&lt;/p&gt;

&lt;p&gt;目前在Tmc中的&lt;a href="https://github.com/JeffreyZhao/Tmc/blob/2e451733fe20bc57ea1c194ceba6323c4c3d4671/src/Tmc/HashedLinkedList.cs"&gt;&lt;code&gt;HashedLinkedList&lt;/code&gt;&lt;/a&gt;便不支持保存相同元素，它只是将.NET BCL的&lt;code&gt;LinkedList&lt;/code&gt;几乎原封不动地复制过来，然后增加一些简单的功能。.NET BCL的&lt;code&gt;LinkedList&lt;/code&gt;的实现为“双向循环链表”，不同于某些数据结构书上使用&lt;code&gt;head&lt;/code&gt;和&lt;code&gt;tail&lt;/code&gt;来保存首尾节点，“双向循环列表”只需要记录头节点，而尾节点只需要简单的访问“头节点”的“前一个节点”即可：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;private &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; _head;

&lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; Last
{
    &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;_head == &lt;span style="color: blue"&gt;null &lt;/span&gt;? &lt;span style="color: blue"&gt;null &lt;/span&gt;: _head._prev; }
}&lt;/pre&gt;

&lt;p&gt;使用“双向循环列表”的好处在于实现特别简单，各种修改操作都能统一为三个方法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;private void &lt;/span&gt;InsertNodeBefore(&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; node, &lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; newNode);
&lt;span style="color: blue"&gt;private void &lt;/span&gt;InsertNodeToEmptyList(&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; newNode);
&lt;span style="color: blue"&gt;private void &lt;/span&gt;RemoveNode(&lt;span style="color: #2b91af"&gt;LinkedListNode&lt;/span&gt;&amp;lt;T&amp;gt; node);&lt;/pre&gt;

&lt;p&gt;因此，在此基础上实现的&lt;code&gt;HashedLinkedList&lt;/code&gt;也只需要修改这三个方法即可，几乎是瞬间的事情。当然，假如只是这样的&lt;code&gt;HashedLinkedList&lt;/code&gt;，我将其放入Tmc项目的意义也不大。因此，不久的将来我会删除这个类，并提供额外的数据结构来应对不同的需求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不支持相同元素。 &lt;/li&gt;

  &lt;li&gt;支持相同元素，但不保证顺序，效率比前者略低。 &lt;/li&gt;

  &lt;li&gt;支持相同元素，并保证顺序，效率比前两者低，但肯定要高于.NET BCL中自带的&lt;code&gt;LinkedList&lt;/code&gt;。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种数据结构（亦或是三种？），我就称之为&lt;code&gt;IndexedLinkedList&lt;/code&gt;吧。假如是你，你会怎么做呢？&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/01/a-basic-hashed-linked-list.html#comments</comments>
      <pubDate>Mon, 07 Jan 2013 23:52:50 GMT</pubDate>
      <lastBuildDate>Thu, 17 Jan 2013 16:59:16 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>阅读.NET源代码那些事</title>
      <link>http://blog.zhaojie.me/2013/01/reading-dotnet-source-code.html</link>
      <guid>http://blog.zhaojie.me/2013/01/reading-dotnet-source-code.html</guid>
      <description>&lt;p&gt;谁都知道.NET（的大部分组件）是不开源的，但是我不止在一个场合不止一次地强调过，“不开源”不代表你没法看代码，不代表你没法知道里面发生了什么。这里我不是在说&lt;a href="http://www.reflector.net/"&gt;.NET Reflector&lt;/a&gt;或是&lt;a href="http://ilspy.net/"&gt;ILSpy&lt;/a&gt;这类反编译工具，当然它们在平时开发中也起到了很大的作用，不过很多时候更直接的方式便是阅读代码本身，尤其是当你像我一样时不时要“抄”点代码的时候。由于最近我在Tmc中“大张旗鼓”地使用.NET中BCL的代码，因此也再次强调一下这部分经验。&lt;/p&gt;

&lt;p&gt;在.NET最初的几年里，要从框架内部抄写一些代码只能使用.NET Reflector将程序集反编译为C#。不过随着C#引入一些相对复杂的语法糖，例如&lt;a href="http://msdn.microsoft.com/en-us/library/vstudio/9k7k7cf0.aspx"&gt;yield&lt;/a&gt;，反编译的结果往往就不尽如人意了。而且很显然的是，编译结果本身会丧失许多实现细节，例如最常见的“局部变量名”肯定就完全丢失了。当然更重要的是一些注释，例如下面这段：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: green"&gt;/*
  Implementation Notes:
  The generic Dictionary was copied from Hashtable's source - any bug 
  fixes here probably need to be made to the generic Dictionary as well.

  This Hashtable uses double hashing.  There are hashsize buckets in the 
  table, and each bucket can contain 0 or 1 element.  We a bit to mark
  whether there's been a collision when we inserted multiple elements 
  (ie, an inserted item was hashed at least a second time and we probed
  this bucket, but it was already in use).  Using the collision bit, we
  can terminate lookups &amp;amp; removes for elements that aren't in the hash
  table more quickly.  We steal the most significant bit from the hash code 
  to store the collision bit.

  Our hash function is of the following form: 

  h(key, n) = h1(key) + n*h2(key) 

  where n is the number of times we've hit a collided bucket and rehashed
  (on this particular lookup).  Here are our hash functions:

  h1(key) = GetHash(key);  // default implementation calls key.GetHashCode();
  h2(key) = 1 + (((h1(key) &amp;gt;&amp;gt; 5) + 1) % (hashsize - 1)); 

  The h1 can return any number.  h2 must return a number between 1 and
  hashsize - 1 that is relatively prime to hashsize (not a problem if 
  hashsize is prime).  (Knuth's Art of Computer Programming, Vol. 3, p. 528-9)
  If this is true, then we are guaranteed to visit every bucket in exactly
  hashsize probes, since the least common multiple of hashsize and h2(key)
  will be hashsize * h2(key).  (This is the first number where adding h2 to 
  h1 mod hashsize will be 0 and we will search the same bucket twice).

  We previously used a different h2(key, n) that was not constant.  That is a 
  horrifically bad idea, unless you can prove that series will never produce
  any identical numbers that overlap when you mod them by hashsize, for all 
  subranges from i to i+hashsize, for all i.  It's not worth investigating,
  since there was no clear benefit from using that hash function, and it was
  broken.

  For efficiency reasons, we've implemented this by storing h1 and h2 in a
  temporary, and setting a variable called seed equal to h1.  We do a probe, 
  and if we collided, we simply add h2 to seed each time through the loop. 

  A good test for h2() is to subclass Hashtable, provide your own implementation 
  of GetHash() that returns a constant, then add many items to the hash table.
  Make sure Count equals the number of items you inserted.

  Note that when we remove an item from the hash table, we set the key 
  equal to buckets, if there was a collision in this bucket.  Otherwise
  we'd either wipe out the collision bit, or we'd still have an item in 
  the hash table. 

   -- 
*/&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;上面这一大段注释出自BCL中Hashtable的实现代码，这种真实代码中的描述才能反映出.NET在开发过程中的实现意图和思路，无论是参考还是学习都大有裨益。微软从好几年前就&lt;a href="http://referencesource.microsoft.com/Default.aspx"&gt;公开了.NET的源代码&lt;/a&gt;，主要目的之一是便于.NET内部的调试，微软也一直保持&lt;a href="http://blogs.msdn.com/b/dotnet/archive/2012/08/15/announcing-the-release-of-net-framework-4-5-rtm-product-and-source-code.aspx"&gt;.NET版本和代码的同步更新&lt;/a&gt;。通过这些源代码，我们可以了解.NET本身在开发过程中的各种细节，包括但不仅限于代码规范，条件编译选项等等。从代码阅读上我也获得了许多经验，几乎无法一一列举。&lt;/p&gt;

&lt;p&gt;例如，你知道&lt;code&gt;Dictionary&lt;/code&gt;内部会对字符串做键的情况进行随机化吗？&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;namespace &lt;/span&gt;System.Collections.Generics {

    &lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;TKey, TValue&amp;gt; {

       &lt;span style="color: blue"&gt;private void &lt;/span&gt;Insert(TKey key, TValue value, &lt;span style="color: blue"&gt;bool &lt;/span&gt;add) {
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(key == &lt;span style="color: blue"&gt;null&lt;/span&gt;) {
                &lt;span style="color: #2b91af"&gt;ThrowHelper&lt;/span&gt;.ThrowArgumentNullException(&lt;span style="color: #2b91af"&gt;ExceptionArgument&lt;/span&gt;.key);
            }

            &lt;span style="color: blue"&gt;if &lt;/span&gt;(buckets == &lt;span style="color: blue"&gt;null&lt;/span&gt;) Initialize(0);
            &lt;span style="color: blue"&gt;int &lt;/span&gt;hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF;
            &lt;span style="color: blue"&gt;int &lt;/span&gt;targetBucket = hashCode % buckets.Length;

&lt;span style="color: blue"&gt;#if &lt;/span&gt;FEATURE_RANDOMIZED_STRING_HASHING
            &lt;span style="color: blue"&gt;int &lt;/span&gt;collisionCount = 0;
&lt;span style="color: blue"&gt;#endif

            for &lt;/span&gt;(&lt;span style="color: blue"&gt;int &lt;/span&gt;i = buckets[targetBucket]; i &amp;gt;= 0; i = entries[i].next) {
                &lt;span style="color: blue"&gt;if &lt;/span&gt;(entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) {
                    &lt;span style="color: blue"&gt;if &lt;/span&gt;(add) {
                        &lt;span style="color: #2b91af"&gt;ThrowHelper&lt;/span&gt;.ThrowArgumentException(&lt;span style="color: #2b91af"&gt;ExceptionResource&lt;/span&gt;.Argument_AddingDuplicate);
                    }
                    entries[i].value = value;
                    version++;
                    &lt;span style="color: blue"&gt;return&lt;/span&gt;;
                }

&lt;span style="color: blue"&gt;#if &lt;/span&gt;FEATURE_RANDOMIZED_STRING_HASHING
                collisionCount++;
&lt;span style="color: blue"&gt;#endif&lt;/span&gt;
            }

            &lt;span style="color: blue"&gt;int &lt;/span&gt;index;
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(freeCount &amp;gt; 0) {
                index = freeList;
                freeList = entries[index].next;
                freeCount--;
            }
            &lt;span style="color: blue"&gt;else &lt;/span&gt;{
                &lt;span style="color: blue"&gt;if &lt;/span&gt;(count == entries.Length) {
                    Resize();
                    targetBucket = hashCode % buckets.Length;
                }
                index = count;
                count++;
            }

            entries[index].hashCode = hashCode;
            entries[index].next = buckets[targetBucket];
            entries[index].key = key;
            entries[index].value = value;
            buckets[targetBucket] = index;
            version++;

&lt;span style="color: blue"&gt;#if &lt;/span&gt;FEATURE_RANDOMIZED_STRING_HASHING
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(collisionCount &amp;gt; &lt;span style="color: #2b91af"&gt;HashHelpers&lt;/span&gt;.HashCollisionThreshold &amp;amp;&amp;amp; &lt;span style="color: #2b91af"&gt;HashHelpers&lt;/span&gt;.IsWellKnownEqualityComparer(comparer)) {
                comparer = (&lt;span style="color: #2b91af"&gt;IEqualityComparer&lt;/span&gt;&amp;lt;TKey&amp;gt;)&lt;span style="color: #2b91af"&gt;HashHelpers&lt;/span&gt;.GetRandomizedEqualityComparer(comparer);
                Resize(entries.Length, &lt;span style="color: blue"&gt;true&lt;/span&gt;);
            }
&lt;span style="color: blue"&gt;#endif
        &lt;/span&gt;}
    }
}&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;FEATURE_RANDOMIZED_STRING_HASHING&lt;/code&gt;标记打开的情况下，我们会在插入记录时检查碰撞次数，假如超过一个&lt;code&gt;HashCollisionThreshold&lt;/code&gt;这个阈值，则会将当前的&lt;code&gt;comparer&lt;/code&gt;随机化。虽然我没有仔细比较过不同版本下的.NET源代码，但我相信这是为了应对前段时间出现的，由&lt;a href="http://www.ocert.org/advisories/ocert-2011-003.html"&gt;哈希碰撞所引起的DoS安全漏洞&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不久之前我为&lt;a href="https://github.com/JeffreyZhao/tmc"&gt;Tmc&lt;/a&gt;添加了&lt;code&gt;HashDictionary&lt;/code&gt;，其中大部分的代码与BCL的&lt;code&gt;Dictionary&lt;/code&gt;类相同。当然在搬运过程中我也进行了一定修改和简化，例如修改了一些命名，去除一些非泛型的接口实现等等，还去掉了对序列化的支持。基本上&lt;code&gt;HashDictionary&lt;/code&gt;与&lt;code&gt;Dictionary&lt;/code&gt;唯一的区别便是增加了&lt;code&gt;bool Remove(TKey, out TValue)&lt;/code&gt;这个方法。假如我们使用扩展方法来实现这个功能，则可能会这么做：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public bool &lt;/span&gt;Remove&amp;lt;TKey, TValue&amp;gt;(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;TKey, TValue&amp;gt; dict, TKey key, &lt;span style="color: blue"&gt;out &lt;/span&gt;TValue value)
{
    dict.TryGetValue(key, &lt;span style="color: blue"&gt;out &lt;/span&gt;value);
    &lt;span style="color: blue"&gt;return &lt;/span&gt;dict.Remove(key);
}&lt;/pre&gt;

&lt;p&gt;这个方法用于在删除时获取键所对应的值，这是个很常见的需求，但上述扩展方法显然需要进行两次查询，一次用来获取值，一次用于删除，这是一种浪费。不过在现有代码基础上&lt;a href="https://github.com/JeffreyZhao/Tmc/commit/15864550a339abdebba9b507afddb23d1caf9cb9"&gt;直接添加这么一个方法&lt;/a&gt;却是轻而易举的，何乐而不为？&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2013/01/reading-dotnet-source-code.html#comments</comments>
      <pubDate>Sun, 06 Jan 2013 16:32:53 GMT</pubDate>
      <lastBuildDate>Thu, 17 Jan 2013 23:50:18 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>NullableKey：解决Dictionary中键不能为null的问题</title>
      <link>http://blog.zhaojie.me/2012/12/nullablekey-nullable-key-in-dictionary.html</link>
      <guid>http://blog.zhaojie.me/2012/12/nullablekey-nullable-key-in-dictionary.html</guid>
      <description>&lt;p&gt;众所周知，.NET中&lt;code&gt;Dictionary&lt;/code&gt;的键不能为&lt;code&gt;null&lt;/code&gt;，否则会抛出&lt;code&gt;NullReferenceException&lt;/code&gt;，这在某些时候会显的很麻烦。与此相对的是Java中的&lt;code&gt;HashMap&lt;/code&gt;支持以&lt;code&gt;null&lt;/code&gt;为键，则方便许多。尽管&lt;code&gt;null&lt;/code&gt;的确不是个好东西，但它既然已经存在，既然给我们造成了麻烦，我们就要想办法去解决它。实现一个自己的字典类自然可行，但要精心实现一个高效的字典并不是件容易的事情，例如BCL中的Dictionary.cs就有超过2000行代码。此外另一个容易想到的方法便是实现&lt;code&gt;IDictionary&lt;/code&gt;接口，将大部分实现委托给现成的&lt;code&gt;Dictionary&lt;/code&gt;类来完成。不过，这相比我在这里要提出的方法还是显得太复杂了。&lt;/p&gt;

&lt;p&gt;在编程语言中引入&lt;code&gt;null&lt;/code&gt;其实是件很自然的事情，因为我们都在冯诺依曼机上进行开发，内存的访问方式便是“地址”，于是便有了&lt;code&gt;null&lt;/code&gt;或&lt;code&gt;NIL&lt;/code&gt;等类似的事物来表示一个指针没有指向任何一块地址，但与之相伴的便是各类错误。毕竟&lt;code&gt;null&lt;/code&gt;这玩意儿过于透明，编译器在许多时候没法通过静态分析来检查出问题，所以在一些“非冯模型”的编程语言里都会避免使用&lt;code&gt;null&lt;/code&gt;。例如在Haskell中，就使用&lt;code&gt;&lt;a href="http://www.haskell.org/haskellwiki/Maybe"&gt;Maybe&lt;/a&gt;&lt;/code&gt;这种数据类型来代替&lt;code&gt;null&lt;/code&gt;。假如在C#中来模拟&lt;code&gt;Maybe&lt;/code&gt;的话，其实就类似于：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public abstract class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Maybe&lt;/span&gt;&amp;lt;T&amp;gt; { }

&lt;span style="color: blue"&gt;public sealed class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Nothing&lt;/span&gt;&amp;lt;T&amp;gt; : &lt;span style="color: #2b91af"&gt;Maybe&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: blue"&gt;public static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Nothing&lt;/span&gt;&amp;lt;T&amp;gt; Instance = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Nothing&lt;/span&gt;&amp;lt;T&amp;gt;();

    &lt;span style="color: blue"&gt;private &lt;/span&gt;Nothing() { }
}

&lt;span style="color: blue"&gt;public sealed class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Just&lt;/span&gt;&amp;lt;T&amp;gt; : &lt;span style="color: #2b91af"&gt;Maybe&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: blue"&gt;private readonly &lt;/span&gt;T _value;

    &lt;span style="color: blue"&gt;public &lt;/span&gt;Just(T value) {
        _value = value;
    }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;T Value { &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;_value; } }
}&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Maybe&lt;/code&gt;类型中没有&lt;code&gt;null&lt;/code&gt;，“有值”则是&lt;code&gt;Just&lt;/code&gt;，“无值”则是&lt;code&gt;Nothing&lt;/code&gt;。而&lt;code&gt;T&lt;/code&gt;跟&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;并不兼容，再获取一个&lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt;类型的数据之后，则必须在逻辑分支里对&lt;code&gt;Nothing&lt;/code&gt;和&lt;code&gt;Just&lt;/code&gt;两种情况进行处理，于是就不会出现&lt;code&gt;NullReferenceException&lt;/code&gt;。从理论上说，我们也可以使用这种方式来解决&lt;code&gt;Dictionary&lt;/code&gt;中键不能为&lt;code&gt;null&lt;/code&gt;的问题，只要用&lt;code&gt;Dictionary&amp;lt;Maybe&amp;lt;TKey&amp;gt;, TValue&amp;gt;&lt;/code&gt;来代替&lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt;即可，但实际上这种方式还是有两个缺点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;我们还是可以向字典的键传递&lt;code&gt;null&lt;/code&gt;。不过幸运的是，编译器不会把&lt;code&gt;TKey&lt;/code&gt;的&lt;code&gt;null&lt;/code&gt;当做&lt;code&gt;Maybe&amp;lt;TKey&amp;gt;&lt;/code&gt;的&lt;code&gt;null&lt;/code&gt;来使用，因此更大的问题在于： &lt;/li&gt;

  &lt;li&gt;除了&lt;code&gt;Nothing&lt;/code&gt;以外，我们每次都要创建一个新对象，每个新对象都占用两个额外的字长（即8个或16个字节），这对GC来说会带来压力。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不过以上两个问题的解决办法也是显而易见的，那就是使用&lt;code&gt;struct&lt;/code&gt;来代替&lt;code&gt;class&lt;/code&gt;。在C#中有两个常被忽视，但对于性能有莫大关系的能力，一是unsafe代码，二便是可自定义的&lt;code&gt;struct&lt;/code&gt;类型。&lt;code&gt;struct&lt;/code&gt;不会对GC造成压力，并且不会占用额外的内存，可能唯一的问题便是用作泛型时会生成一份额外的可执行代码，且无法继承了。&lt;/p&gt;

&lt;p&gt;无法继承没有关系，其实我们也不需要严格按照&lt;code&gt;Maybe&lt;/code&gt;的数据模型来实现，只要能够解决问题即可。例如，我们可以使用这么一个&lt;code&gt;NullableKey&lt;/code&gt;类型：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public struct &lt;/span&gt;&lt;span style="color: #2b91af"&gt;NullableKey&lt;/span&gt;&amp;lt;T&amp;gt; {
    &lt;span style="color: blue"&gt;private readonly &lt;/span&gt;T _value;

    &lt;span style="color: blue"&gt;public &lt;/span&gt;NullableKey(T value) {
        _value = value;
    }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;T Value {
        &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;_value; }
    }
}&lt;/pre&gt;

&lt;p&gt;重载了&lt;code&gt;GetHashCode&lt;/code&gt;和&lt;code&gt;Equals&lt;/code&gt;方法以后，我们便可以使用&lt;code&gt;NullableKey&amp;lt;T&amp;gt;&lt;/code&gt;来代替普通的&lt;code&gt;T&lt;/code&gt;作为&lt;code&gt;Dictionary&lt;/code&gt;的键。更有意思的是，我们可以为定义&lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;与&lt;code&gt;T&lt;/code&gt;之间的隐式转换，这样在很多场合下可以方便我们编写代码，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;dict = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;NullableKey&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;string&lt;/span&gt;&amp;gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;();
dict[&lt;span style="color: blue"&gt;null&lt;/span&gt;] = 1;

&lt;span style="color: blue"&gt;foreach &lt;/span&gt;(&lt;span style="color: blue"&gt;string &lt;/span&gt;key &lt;span style="color: blue"&gt;in &lt;/span&gt;dict.Keys) {
    &lt;span style="color: #2b91af"&gt;Console&lt;/span&gt;.WriteLine(key ?? &lt;span style="color: #a31515"&gt;"&amp;lt;null&amp;gt;"&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;Dictionary&lt;/code&gt;还支持使用自定义的&lt;code&gt;IEqualityComparer&lt;/code&gt;类型，因此我也提供了一个配套的&lt;code&gt;NullableKeyEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;类，可以用来封装一个自定义的&lt;code&gt;IEqualityComparer&amp;lt;T&amp;gt;&lt;/code&gt;，并提供&lt;code&gt;IEqualityComparer&amp;lt;NullableKey&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;的功能，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;stringComparer = &lt;span style="color: #2b91af"&gt;StringComparer&lt;/span&gt;.OrdinalIgnoreCase; &lt;span style="color: green"&gt;// IEqualityComparer&amp;lt;string&amp;gt;
&lt;/span&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;keyComparer = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;NullableKeyEqualityComparer&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;string&lt;/span&gt;&amp;gt;(stringComparer);
&lt;span style="color: blue"&gt;var &lt;/span&gt;dict = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;NullableKey&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;string&lt;/span&gt;&amp;gt;, &lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;(keyComparer);&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NullableKey&lt;/code&gt;和&lt;code&gt;NullableKeyEqualityComparer&lt;/code&gt;的代码我已经提交至&lt;a href="https://github.com/JeffreyZhao/Tmc/tree/master/src/Tmc/"&gt;GitHub里的Tmc项目&lt;/a&gt;里。所谓Tmc，即缩写之The Missing Collections，我会放一些平时较为常用的，但BCL以及&lt;a href="http://powercollections.codeplex.com/"&gt;Power Collections&lt;/a&gt;或&lt;a href="http://www.itu.dk/research/c5/"&gt;C5&lt;/a&gt;等常用第三方类库所没有提供的集合。东西不会多（毕竟已经有BCL和第三方类库了），但总比每次都重写要好。也希望大家也可以帮我审阅代码，尤其要着重检查效率方面的问题。毕竟是通用类库，我希望可以在效率方面也有很好的保证。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/12/nullablekey-nullable-key-in-dictionary.html#comments</comments>
      <pubDate>Sat, 29 Dec 2012 02:26:30 GMT</pubDate>
      <lastBuildDate>Sat, 29 Dec 2012 15:30:28 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>不同泛型参数区分的独立类型</title>
      <link>http://blog.zhaojie.me/2012/12/isolated-types-by-different-generic-type-arguments.html</link>
      <guid>http://blog.zhaojie.me/2012/12/isolated-types-by-different-generic-type-arguments.html</guid>
      <description>&lt;p&gt;相对于的Java的“&lt;a href="http://docs.oracle.com/javase/tutorial/java/generics/erasure.html"&gt;类型擦除（Type Erasure）&lt;/a&gt;”来说，.NET中的泛型可谓是真正的泛型，这让我们可以有能力区分运行时所使用的不同的具体类型，大大增强了程序设计的性能和表现能力。&lt;/p&gt;

&lt;p&gt;打个比方，在Java 8中终于引入了Lambda表达式，但是由于它的伪泛型只能是一个“引用类型”而不能是“基础类型”，因此我们没法从&lt;code&gt;int&lt;/code&gt;数组发起函数式操作，最后也没法回到&lt;code&gt;List&amp;lt;char&amp;gt;&lt;/code&gt;这种类型（事实上这种类型在Java中根本不存在）。这除了影响编程体验和表达能力以外，对于内存和性能都有大量额外的开销。试想，谁希望在找出符合条件的一万个&lt;code&gt;int&lt;/code&gt;数值的时候，必须额外创建一万个&lt;code&gt;Integer&lt;/code&gt;对象，导致堆上增加几百上千K的空间，还有一万个对象带来的GC压力？当然，这次我们暂时不谈这方面，还是来谈谈.NET中“真泛型”这一特点所带来的编程便利。&lt;/p&gt;

&lt;p&gt;在.NET中，我们编写一个泛型类型的时候，只会给出一个泛型类型的定义，例如&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;，我们检查&lt;code&gt;typeof(List&amp;lt;&amp;gt;).IsGenericDefinition&lt;/code&gt;也会得到&lt;code&gt;true&lt;/code&gt;。然而，程序在真正运行的时候，使用的都是提供了具体泛型参数的类型，例如&lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;或是&lt;code&gt;List&amp;lt;string&amp;gt;&lt;/code&gt;。我们没法创建一个“泛型定义”的实例或是访问它的静态成员等等，最多使用反射来访问它的信息。&lt;/p&gt;

&lt;p&gt;在运行过程中，.NET运行时会（在第一次使用时）为不同的值类型创建一份不同的代码，而让所有的引用类型共享同一份代码。这是因为，假如&lt;code&gt;T&lt;/code&gt;是值类型，那么生成的代码操作的都是栈上的数据，需要操作的字节数会有所不同，而引用类型都只需要操作16或32字节的地址，是一致的。当然，理论上&lt;code&gt;List&amp;lt;long&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;DateTime&amp;gt;&lt;/code&gt;是可以共享代码的，因为它们其实都只是一个64字节的长整型，但是还是有些情况，尽管都是64字节的长度，如&lt;code&gt;List&amp;lt;long&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;double&amp;gt;&lt;/code&gt;就不能共享代码。因此，运行时就统一为不同的值类型都创建不同的代码了。这的确会带来一定的额外开销，但在我看来，相比“真泛型”带来的便利，这点开销完全是值得的。想要了解更多这方面的内容，可以参考著名的Joe Duffy同学《&lt;a href="http://www.bluebytesoftware.com/blog/2011/10/23/OnGenericsAndSomeOfTheAssociatedOverheads.aspx"&gt;On generics and (some of) the associated overheads&lt;/a&gt;》这篇文章。&lt;/p&gt;

&lt;p&gt;不过无论执行的代码是否共享，不同具体类型参数的类型都是各自独立的，它们各有各的元数据，各有各的需方法表等等，因此它们的静态成员也是各自独立的。之前我也写过这方面的文章，例如它可能会&lt;a href="http://blog.zhaojie.me/2009/09/i-made-a-mistake-can-you-figure-it-out.html"&gt;让人上当&lt;/a&gt;，也可以利用这点&lt;a href="http://blog.zhaojie.me/2009/11/cache-and-object-creation-benchmark.html"&gt;写出高效的实现&lt;/a&gt;。这里我可以举出后者的另一个例子，例如在.NET中的&lt;code&gt;ConcurrentDictionary&lt;/code&gt;实现中需要知道当前&lt;code&gt;TValue&lt;/code&gt;类型的读写操作是否是原子的，它的实现就是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: green"&gt;// Whether TValue is a type that can be written atomically (i.e., with no danger of torn reads)
&lt;/span&gt;&lt;span style="color: blue"&gt;private static readonly bool &lt;/span&gt;s_isValueWriteAtomic = IsValueWriteAtomic();

&lt;span style="color: gray"&gt;/// &amp;lt;summary&amp;gt;
/// &lt;/span&gt;&lt;span style="color: green"&gt;Determines whether type TValue can be written atomically 
&lt;/span&gt;&lt;span style="color: gray"&gt;/// &amp;lt;/summary&amp;gt; 
&lt;/span&gt;&lt;span style="color: blue"&gt;private static bool &lt;/span&gt;IsValueWriteAtomic()
{
    &lt;span style="color: #2b91af"&gt;Type &lt;/span&gt;valueType = &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(TValue);

    &lt;span style="color: green"&gt;//
    // Section 12.6.6 of ECMA CLI explains which types can be read and written atomically without
    // the risk of tearing.
    // 
    // See http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-335.pdf 
    //
    &lt;/span&gt;&lt;span style="color: blue"&gt;bool &lt;/span&gt;isAtomic =
        (valueType.IsClass)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Boolean&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Byte&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;SByte&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Int16&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;UInt16&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Int32&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;UInt32&lt;/span&gt;)
        || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Single&lt;/span&gt;);

    &lt;span style="color: blue"&gt;if &lt;/span&gt;(!isAtomic &amp;amp;&amp;amp; &lt;span style="color: #2b91af"&gt;IntPtr&lt;/span&gt;.Size == 8)
    {
        isAtomic |= valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Double&lt;/span&gt;) || valueType == &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Int64&lt;/span&gt;);
    }

    &lt;span style="color: blue"&gt;return &lt;/span&gt;isAtomic;
}&lt;/pre&gt;

&lt;p&gt;我相信，假如让很多同学来实现这部分逻辑的话，就会创建&lt;code&gt;IsValueWriteAtomic&lt;/code&gt;这样的静态方法，然后在需要的时候反复调用。但事实上，由于不同的泛型参数所带来的具体类型完全独立，因此我们完全可以像.NET那样将这个函数的结果保存在一个静态变量中，然后每次访问即可。&lt;/p&gt;

&lt;p&gt;这个特性有时还可以帮助我们简化一些代码，举个最简单的例子：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;SingletonBase&lt;/span&gt;&amp;lt;T&amp;gt; &lt;span style="color: blue"&gt;where &lt;/span&gt;T : &lt;span style="color: blue"&gt;new&lt;/span&gt;()
{
    &lt;span style="color: blue"&gt;public static readonly &lt;/span&gt;T Instance = &lt;span style="color: blue"&gt;new &lt;/span&gt;T();
}

&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MySingleton1 &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;SingletonBase&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MySingleton1&lt;/span&gt;&amp;gt;
{
    &lt;span style="color: green"&gt;// ...
&lt;/span&gt;}

&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MySingleton2 &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;SingletonBase&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MySingleton2&lt;/span&gt;&amp;gt;
{
    &lt;span style="color: green"&gt;// ...
&lt;/span&gt;}&lt;/pre&gt;

&lt;p&gt;这样我们就可以不用在每个类型中加上一个只读的&lt;code&gt;Instance&lt;/code&gt;静态成员了。当然，这个例子简单地几乎没有实用意义，我们以后会来讨论更有价值的使用案例。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/12/isolated-types-by-different-generic-type-arguments.html#comments</comments>
      <pubDate>Mon, 03 Dec 2012 23:11:09 GMT</pubDate>
      <lastBuildDate>Tue, 04 Dec 2012 16:39:09 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <title>如何生成一段Typoglycemia文本（解答）</title>
      <link>http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text-result.html</link>
      <guid>http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text-result.html</guid>
      <description>&lt;p&gt;关于“&lt;a href="http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text.html"&gt;生成Tygolycemia文本&lt;/a&gt;”这个问题，已经有许多同学给了答案。不过，似乎大部分同学都只是以“完成”作为目标，并没有在解法的效率和内存占用上做过多考虑。其实对于这种非常简单的问题，给出一个解法并没有太大意义，而是要从中获取一些经验，否则就算反复解决这类简单的问题，得到的进步依然十分有限。&lt;/p&gt;

&lt;p&gt;我们很容易想到，解决这个问题只需要从头至尾遍历这个字符串，找到需要重排的单词，并加以处理即可，所以这题的关键在于如何控制内存的占用以及内存复制大小。我们可以举一个最经典的例子：假如我们要将&lt;code&gt;M&lt;/code&gt;个&lt;code&gt;N&lt;/code&gt;字节的字符串拼接为一个&lt;code&gt;M * N&lt;/code&gt;字节的大字符串，则直接使用加号依次进行连接，则会累计开辟及复制&lt;code&gt;2 * N + 3 * N + ... + (M - 1) * N&lt;/code&gt;，即规模在&lt;code&gt;M&lt;sup&gt;2&lt;/sup&gt; * N&lt;/code&gt;的数据（尽管内存会被GC不断回收，但复制是绝对省不下来，而且这对GC来说也是极大负担）。但是，假如我们使用&lt;code&gt;StringBuilder&lt;/code&gt;，并直接开辟&lt;code&gt;M * N&lt;/code&gt;的容量，则只需要额外复制&lt;code&gt;M * N&lt;/code&gt;的数据。更进一步，假如我们使用&lt;code&gt;String.Concat(string[])&lt;/code&gt;来拼接字符串，则一点额外的复制操作都不需要就能得到最终的字符串。可见，完成同样的工作，占用的内存空间以及内存复制大小是天差地远的。&lt;/p&gt;

&lt;p&gt;估计是被强调太多次的缘故，说起此类字符串操作，大部分同学都倾向于使用&lt;code&gt;StringBuilder&lt;/code&gt;，但这真是万能的解决方案吗？其实我很多年前就做过实验（&lt;a href="http://blog.zhaojie.me/2009/11/string-concat-perf-1-benchmark.html"&gt;一&lt;/a&gt;、&lt;a href="http://blog.zhaojie.me/2009/12/string-concat-perf-2-stringbuilder-implementations.html"&gt;二&lt;/a&gt;、&lt;a href="http://blog.zhaojie.me/2009/12/string-concat-perf-3-profiling-analysis.html"&gt;三&lt;/a&gt;），强调了在可以使用&lt;code&gt;String.Concat&lt;/code&gt;的情况下，它的性能会比&lt;code&gt;StringBuilder&lt;/code&gt;更好。&lt;code&gt;StringBuilder&lt;/code&gt;更适合在一些动态的环境里，生成一些长度不固定的字符串。另外，很多同学都不重视&lt;code&gt;StringBuilder&lt;/code&gt;的初始容量（同理还有&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;的初始容量），这都是会影响性能的因素。所以，我们除了要知道&lt;code&gt;StringBuilder&lt;/code&gt;这个东西以外，还应该知道它的适用场景，其实这些结论都很简单，完全不用死记硬背，靠常理推断即可。&lt;/p&gt;

&lt;p&gt;就拿如今的Typoglycemia问题来说，使用一个&lt;code&gt;StringBuilder&lt;/code&gt;并非是一个最好的选择，因为在得到初始字符串的情况下，目标字符串的长度也已经完全可以确定下来，换句话说，我们完全可以直接用一个&lt;code&gt;char[]&lt;/code&gt;来保存内容，进行处理，并直接生成字符串，这样我们只需要一份额外的字符串空间即可。当然，用&lt;code&gt;StringBuilder&lt;/code&gt;时也可以直接指定足够的容量以避免不断扩容，但直接将字符串转为&lt;code&gt;char[]&lt;/code&gt;则意味着一次性的，连续的内存复制，而用&lt;code&gt;StringBuilder&lt;/code&gt;以后便会以小段小段方式复制内存，性能高低一目了然。&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;char[]&lt;/code&gt;进行处理还有额外的好处，便是完全无需生成小段的字符串对象。有的同学处理这个问题的时候直接就用上&lt;code&gt;String.Split&lt;/code&gt;来拆分字符串，这其实只会对性能带来负面影响。&lt;a href="http://www.bluebytesoftware.com/blog/2012/10/31/BewareTheString.aspx"&gt;著名的Joe Duffy最近便写了一篇文章&lt;/a&gt;，谈到字符串处理时别总是为了图省事，以免“将一个IO密集型应用活活变成了CPU密集型”。在这里假如我们用上了&lt;code&gt;StringBuilder&lt;/code&gt;，即便没有动态扩容，也势必会将源字符串拆分为一小段一小段，造成额外的内存复制及GC压力。&lt;/p&gt;

&lt;p&gt;因此，我们的代码其实大致会是这样的结构：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static string &lt;/span&gt;MakeTypoglycemia(&lt;span style="color: blue"&gt;string &lt;/span&gt;text)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;charArray = text.ToCharArray();

    &lt;span style="color: green"&gt;// 处理charArray内容

    &lt;/span&gt;&lt;span style="color: blue"&gt;return new string&lt;/span&gt;(charArray);
}&lt;/pre&gt;


&lt;p&gt;剩下的，便只要找准位置，并打乱即可。我这里采取的策略其实十分简单，只要设定一个下标&lt;code&gt;index&lt;/code&gt;（初始值为0），并重复以下三步即可：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从当前&lt;code&gt;index&lt;/code&gt;开始，向后找到第一个字母，作为单词的起始位置。假如找不到字母，则表明处理完毕。 &lt;/li&gt;

  &lt;li&gt;从当前&lt;code&gt;index&lt;/code&gt;开始，向后寻找单词的分隔字符（空白字符），并随时记录最后一个字母的位置&lt;code&gt;lastLetterIndex&lt;/code&gt;（因为空白符前面可能是标点符号）。 &lt;/li&gt;

  &lt;li&gt;&lt;code&gt;index&lt;/code&gt;和&lt;code&gt;lastLetterIndex&lt;/code&gt;之间便是需要打乱的单词。打乱后，将&lt;code&gt;index&lt;/code&gt;设为分隔字符的下一个位置。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是&lt;code&gt;MakeTypoglycemia&lt;/code&gt;方法的代码便呼之欲出了：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static string &lt;/span&gt;MakeTypoglycemia(&lt;span style="color: blue"&gt;string &lt;/span&gt;text)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;charArray = text.ToCharArray();

    &lt;span style="color: blue"&gt;var &lt;/span&gt;index = 0;
    &lt;span style="color: blue"&gt;do
    &lt;/span&gt;{
        index = FindLetter(charArray, index);
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(index &amp;gt;= charArray.Length) &lt;span style="color: blue"&gt;break&lt;/span&gt;;

        &lt;span style="color: blue"&gt;int &lt;/span&gt;lastLetterIndex;
        &lt;span style="color: blue"&gt;var &lt;/span&gt;spaceIndex = FindSeparator(charArray, index + 1, &lt;span style="color: blue"&gt;out &lt;/span&gt;lastLetterIndex);

        &lt;span style="color: blue"&gt;if &lt;/span&gt;(lastLetterIndex - index &amp;gt; 2)
        {
            Shuffle(charArray, index + 1, lastLetterIndex - 1);
        }

        index = spaceIndex + 1;

    } &lt;span style="color: blue"&gt;while &lt;/span&gt;(index &amp;lt; charArray.Length);

    &lt;span style="color: blue"&gt;return new string&lt;/span&gt;(charArray);
}&lt;/pre&gt;

&lt;p&gt;其中用到两个辅助方法&lt;code&gt;FindLetter&lt;/code&gt;及&lt;code&gt;FindSeparator&lt;/code&gt;，都十分简单：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static int &lt;/span&gt;FindLetter(&lt;span style="color: blue"&gt;char&lt;/span&gt;[] charArray, &lt;span style="color: blue"&gt;int &lt;/span&gt;startIndex)
{
    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = startIndex; i &amp;lt; charArray.Length; i++)
    {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;.IsLetter(charArray[i])) &lt;span style="color: blue"&gt;return &lt;/span&gt;i;
    }

    &lt;span style="color: blue"&gt;return &lt;/span&gt;charArray.Length;
}

&lt;span style="color: blue"&gt;static int &lt;/span&gt;FindSeparator(&lt;span style="color: blue"&gt;char&lt;/span&gt;[] charArray, &lt;span style="color: blue"&gt;int &lt;/span&gt;startIndex, &lt;span style="color: blue"&gt;out int &lt;/span&gt;lastLetterIndex)
{
    lastLetterIndex = -1;

    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = startIndex; i &amp;lt; charArray.Length; i++)
    {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;ch = charArray[i];

        &lt;span style="color: blue"&gt;if &lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;quot; \t\r\n&amp;quot;&lt;/span&gt;.IndexOf(ch) &amp;gt;= 0) &lt;span style="color: blue"&gt;return &lt;/span&gt;i;

        &lt;span style="color: blue"&gt;if &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;.IsLetter(ch)) lastLetterIndex = i;
    }

    &lt;span style="color: blue"&gt;return &lt;/span&gt;charArray.Length;
}&lt;/pre&gt;

&lt;p&gt;这里还用到一个&lt;code&gt;Shuffle&lt;/code&gt;方法就不多解释了，一个传统的数组随机化的实现而已，只是需要跳过非字母的字符（用于处理“couldn't”这种情况）：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Random &lt;/span&gt;Random = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Random&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;DateTime&lt;/span&gt;.Now.Millisecond);

&lt;span style="color: blue"&gt;static void &lt;/span&gt;Shuffle(&lt;span style="color: blue"&gt;char&lt;/span&gt;[] charArray, &lt;span style="color: blue"&gt;int &lt;/span&gt;startIndex, &lt;span style="color: blue"&gt;int &lt;/span&gt;endIndex)
{
    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = startIndex; i &amp;lt;= endIndex; i++)
    {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(!&lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;.IsLetter(charArray[i])) &lt;span style="color: blue"&gt;continue&lt;/span&gt;;

        &lt;span style="color: blue"&gt;var &lt;/span&gt;index = Random.Next(startIndex, endIndex + 1);
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(!&lt;span style="color: #2b91af"&gt;Char&lt;/span&gt;.IsLetter(charArray[index])) &lt;span style="color: blue"&gt;continue&lt;/span&gt;;

        &lt;span style="color: blue"&gt;var &lt;/span&gt;temp = charArray[index];
        charArray[index] = charArray[i];
        charArray[i] = temp;
    }
}&lt;/pre&gt;

&lt;p&gt;从中可以看出，其实这样一个高效的实现也可以十分清晰而简单，可以说并没有因为追求效率而引入任何复杂度。使用这种做法，我们只用了一份额外的字符串大小的内存（即一个&lt;code&gt;char[]&lt;/code&gt;对象）便得到了目标字符串，那么我们能否把这一份额外的内存开销也省下来呢？答案是肯定的，不过这个问题我们下次再谈。&lt;/p&gt;

&lt;p&gt;最后说个有趣的东西：假如不追求效率，并且假设输入文本完全是用空格分割的字母，这个问题还有更好玩的“一行解法”，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static string &lt;/span&gt;MakeTypoglycemia(&lt;span style="color: blue"&gt;string &lt;/span&gt;text)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;random = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Random&lt;/span&gt;();
    &lt;span style="color: blue"&gt;return &lt;/span&gt;&lt;span style="color: #2b91af"&gt;String&lt;/span&gt;.Join(&lt;span style="color: #a31515"&gt;&amp;quot;&amp;quot;&lt;/span&gt;, text.Split(&lt;span style="color: #a31515"&gt;' '&lt;/span&gt;).Select(s =&amp;gt; s.Length &amp;lt;= 3 ? s : s[0] + &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;String&lt;/span&gt;(s.Substring(1, s.Length - 2).OrderBy(_ =&amp;gt; random.Next()).ToArray()) + s[s.Length - 1]));
}&lt;/pre&gt;

&lt;p&gt;以上代码完全借助.NET中内置的功能，并没有增加任何辅助方法。从效率的角度来说，这种做法当然不值一提。那么，您能否估计一下，这个做法到底会产生多少额外的内存复制？假设这是一个长度为N的字符串，其中所有的单词长度都大于3，并且总共有M个单词。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text-result.html#comments</comments>
      <pubDate>Sun, 11 Nov 2012 23:40:21 GMT</pubDate>
      <lastBuildDate>Mon, 12 Nov 2012 00:32:41 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <title>如何生成一段Typoglycemia文本？</title>
      <link>http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text.html</link>
      <guid>http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text.html</guid>
      <description>&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Typoglycemia"&gt;Typoglycemia&lt;/a&gt;是个新词，描述的是人们识别一段文本时的一个有趣的现象：只要每个单词的首尾字母正确，中间的字母顺序完全打乱也没有关系，照样可以正常理解。例如这么一段文字：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I cdnuol't blveiee taht I cluod aulaclty uesdnatnrd waht I was rdanieg: the phaonmneel pweor of the hmuan mnid. Aoccdrnig to a rseearch taem at Cmabrigde Uinervtisy, it deosn't mttaer in waht oredr the ltteers in a wrod are, the olny iprmoatnt tihng is taht the frist and lsat ltteer be in the rghit pclae. The rset can be a taotl mses and you can sitll raed it wouthit a porbelm. Tihs is bcuseae the huamn mnid deos not raed ervey lteter by istlef, but the wrod as a wlohe. Scuh a cdonition is arppoiatrely cllaed Typoglycemia.&lt;/p&gt;

&lt;p&gt;Amzanig huh? Yaeh and you awlyas thguoht slpeling was ipmorantt.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我们其实可以较为轻松地识别出其原文：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I couldn't believe that I could actually understand what I was reading: the phenomenal power of the human mind. According to a research team at Cambridge University, it doesn't matter in what order the letters in a word are, the only important thing is that the first and last letter be in the right place. The rest can be a total mess and you can still read it without a problem. This is because the human mind does not read every letter by itself, but the word as a whole. Such a condition is appropriately called Typoglycemia.&lt;/p&gt;

&lt;p&gt;Amazing, huh? Yeah and you always thought spelling was important.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;事实上中文也有类似的性质，文字序乱是不响影正阅常读的。&lt;/p&gt;

&lt;p&gt;那么我们可以如何从一段正确的文本（下方）生成一段Typoglycemia文本（上方）呢？这其实是我今天出的一道面试题，简单地说就是要求实现这么一个方法：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color:blue;"&gt;string&lt;/span&gt; MakeTypoglycemia(&lt;span style="color:blue;"&gt;string&lt;/span&gt; text); &lt;/pre&gt;

&lt;p&gt;规则很简单：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;保持所有非字母的字符位置不变。&lt;/li&gt;
&lt;li&gt;保持单词首尾字母不变，中间字符打乱。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;所谓”打乱“，可以随意从网上找一段数组乱序的算法即可，无需保证一定改变（例如某些除去头尾只有两个字母的单词，偶尔保留不变问题也不大）或者每个字符都不在原来的位置上。不过，我们假设这段代码会被大量调用，因此希望可以尽可能地效率高些，内存使用少些。&lt;/p&gt;

&lt;p&gt;要不您也来试下？这题我建议使用C#或Java来实现，因为这两个环境里的内存分配行为比较容易判断。当然您用Ruby，Python或JavaScript等语言问题也不大，效率容易判断，但内存分配方便可能就比较难计较了。&lt;/p&gt;

&lt;p&gt;其实这题还有后续，那就是把目标反一反：从一个前后确定中间乱序的单词，找到其原始的，正确的单词。自然，我们会得到一个长长的单词列表，十万个单词吧，并保证没有两个单词仅仅是中间几个字符的顺序不同。那么，您会如何设计一个数据结构，让我们可以快速的从一个乱序后的单词找到其正确形式呢？&lt;/p&gt;

&lt;p&gt;不过还是那句话：一定要写下代码来，否则思路不谈也罢。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/11/how-to-generate-typoglycemia-text.html#comments</comments>
      <pubDate>Mon, 05 Nov 2012 23:39:22 GMT</pubDate>
      <lastBuildDate>Mon, 05 Nov 2012 23:43:13 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <title>如何让您的事件支持逆变</title>
      <link>http://blog.zhaojie.me/2012/11/how-to-make-your-event-support-contravariance.html</link>
      <guid>http://blog.zhaojie.me/2012/11/how-to-make-your-event-support-contravariance.html</guid>
      <description>&lt;p&gt;在.NET里“事件”是一种无比常见的成员，我在项目里也经常暴露一些事件供其他地方使用。在.NET里定义一个事件会需要一个委托类型，一般来说我们会使用.NET里自带的&lt;code&gt;System.EventHandler&lt;/code&gt;类型，它的签名是：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public delegate void &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;TEventArgs&amp;gt;(&lt;span style="color: blue"&gt;object &lt;/span&gt;sender, TEventArgs e);&lt;/pre&gt;

&lt;p&gt;但这个定义其实有稍许缺陷。例如，如果您在自己的项目中编写了这样的代码，Resharper这样的工具便会提醒您“TEventArgs可以设为逆变”。&lt;a href="http://msdn.microsoft.com/en-us/library/vstudio/dd799517.aspx"&gt;协变和逆变&lt;/a&gt;是C# 4中引入的非常有用的功能，可以在保证类型安全的前提下让代码变的更加好用。因此，我在项目里往往会使用自己的&lt;code&gt;CoEventHandler&lt;/code&gt;委托类型：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public delegate void &lt;/span&gt;&lt;span style="color: #2b91af"&gt;CoEventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;in &lt;/span&gt;TSender, &lt;span style="color: blue"&gt;in &lt;/span&gt;TEventArgs&amp;gt;(TSender sender, TEventArgs args);&lt;/pre&gt;

&lt;p&gt;可以看出，我们只需要为&lt;code&gt;TSender&lt;/code&gt;增加一个&lt;code&gt;in&lt;/code&gt;标记就够了，我们甚至可以连&lt;code&gt;sender&lt;/code&gt;的类型也一并逆变起来。接下来我们自然可以用这个委托类型来定义事件，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyClass
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;public event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;CoEventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyClass&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;List&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;&amp;gt; MyEvent;
}&lt;/pre&gt;

&lt;p&gt;有人可能会说：这不行啊，事件参数怎么可以不是&lt;code&gt;System.EventArgs&lt;/code&gt;的子类呢？我的回应是：谁说事件参数一定要是它的子类？这只是一种常见的“约定”，最多上升为“规范”，但这种限制其实并没有带来额外的好处。事实上.NET框架本身也意识到这种限制是没有什么必要的，因此它在.NET 4.5中也将这一限制去除了。正如文章最初贴出的代码，其实是&lt;a href="http://msdn.microsoft.com/en-us/library/db0etb8x(v=vs.110).aspx"&gt;.NET 4.5中的定义&lt;/a&gt;，而在&lt;a href="http://msdn.microsoft.com/en-us/library/db0etb8x(v=vs.100).aspx"&gt;.NET 4里的定义&lt;/a&gt;却是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public delegate void &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;TEventArgs&amp;gt;(&lt;span style="color: blue"&gt;object &lt;/span&gt;sender, TEventArgs args)
    &lt;span style="color: blue"&gt;where &lt;/span&gt;TEventArgs : System.&lt;span style="color: #2b91af"&gt;EventArgs&lt;/span&gt;;&lt;/pre&gt;

&lt;p&gt;看见没？.NET 4.5将这个没有什么必要的限制去掉了，在以后的文章中我也会描述下这么做的优势。而我们现在只不过更进一步，将两个参数都泛型化，并让它们支持协变而已。于是，我们便可以为事件添加各种兼容的接口了：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static void &lt;/span&gt;StrongTypedHandler(&lt;span style="color: #2b91af"&gt;MyClass &lt;/span&gt;sender, &lt;span style="color: #2b91af"&gt;List&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt; args) { }

&lt;span style="color: blue"&gt;static void &lt;/span&gt;WeakerTypedHandler(&lt;span style="color: blue"&gt;object &lt;/span&gt;sender, &lt;span style="color: #2b91af"&gt;ICollection&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt; args) { }

&lt;span style="color: blue"&gt;static void &lt;/span&gt;Main()
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;myClass = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyClass&lt;/span&gt;();
    myClass.MyEvent += (&lt;span style="color: #2b91af"&gt;CoEventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyClass&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;List&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)StrongTypedHandler;
    myClass.MyEvent += (&lt;span style="color: #2b91af"&gt;CoEventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;object&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;ICollection&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;&amp;gt;)WeakerTypedHandler;
}&lt;/pre&gt;

&lt;p&gt;这段代码完全可以编译通过，但是执行时却会抛出异常：&lt;/p&gt;

&lt;pre class="code"&gt;System.ArgumentException: Delegates must be of the same type.
   at System.MulticastDelegate.CombineImpl(Delegate follow)
   at TestConsole.MyClass.add_MyEvent(CoEventHandler`2 value)
   at TestConsole.Program.Main() in ...&lt;/pre&gt;

&lt;p&gt;还记得我们用上面最普通的方式定义一个事件的时候，C#编译器会帮我们生成什么样的代码吗（不知道的同学请参考CLR via C#）？“自动事件”生成的代码，最终会使用&lt;code&gt;Delegate.Combine&lt;/code&gt;来实现多重委托。不过，尽管C#编译器和运行时支持逆变，但&lt;code&gt;Delegate.Combine&lt;/code&gt;是不支持的，这就导致了运行时异常。因此，假如您定义的事件支持逆变，则完全不能“偷懒”去使用“自动事件”，必须编写代码来手动增删事件处理器。&lt;/p&gt;

&lt;p&gt;当然，事实上这个问题跟“事件”没有必然联系，各种期望使用多重分派委托的地方都会遇到相同的问题，所以我们解决的问题完全可以更泛化一些。我们可以构造一个&lt;code&gt;MulticastDelegateManager&lt;/code&gt;来解决这个问题，定义如下：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MulticastDelegateManager&lt;/span&gt;&amp;lt;TDelegate&amp;gt;
{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;MulticastDelegateManager(&lt;span style="color: blue"&gt;bool &lt;/span&gt;isThreadSafe) { }

    &lt;span style="color: blue"&gt;public void &lt;/span&gt;Add(TDelegate value) { }

    &lt;span style="color: blue"&gt;public void &lt;/span&gt;Remove(TDelegate value) { }

    &lt;span style="color: blue"&gt;public void &lt;/span&gt;Invoke(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;TDelegate&amp;gt; invoke) { }
}&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;Add&lt;/code&gt;和&lt;code&gt;Remove&lt;/code&gt;自然是用于添加和删除一个委托，而&lt;code&gt;Invoke&lt;/code&gt;在执行时则需要传入一个“执行器”，用于执行每个已经添加的委托对象，这样便可以统一。&lt;/p&gt;

&lt;p&gt;构造一个&lt;code&gt;MulticastDelegateManager&lt;/code&gt;对象时，我们可以指明它是否会工作在多线程的环境里。假如我们确定这个事件无需多线程支持，则可以将&lt;code&gt;isThreadSafe&lt;/code&gt;设为&lt;code&gt;false&lt;/code&gt;，于是各类操作将会放弃多线程保护，对效率会有一定好处。反之，则&lt;code&gt;Add&lt;/code&gt;、&lt;code&gt;Remove&lt;/code&gt;以及&lt;code&gt;Invoke&lt;/code&gt;方法都可能在一个并发环境中使用。具体一点便是，&lt;code&gt;Invoke&lt;/code&gt;本身在调用时无法“重入”，每次调用都是互斥的。但是，尽量也让并发度高一些为好。&lt;/p&gt;

&lt;p&gt;此外，传统多重委托在执行时，假如某个委托抛出了异常，测后续的委托便不会执行了。这对于“事件”来说可能会产生较为严重的问题。因此，我希望&lt;code&gt;Invoke&lt;/code&gt;在执行时必须保证每个委托被调用过。当然，我们也不能简单的吞噬异常。&lt;/p&gt;

&lt;p&gt;要不您来试试看写这么一个&lt;code&gt;MulticastDelegateManager&lt;/code&gt;？不过请不要仅仅给出“思路”，千万要写下代码来，否则您的思路不说也罢。这个问题的确简单，但和&lt;a href="http://blog.zhaojie.me/2012/11/add-a-remove-multiple-method-for-list.html"&gt;上次的问题&lt;/a&gt;一样，不仔细考虑的话还是挺容易出现一些问题的。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/11/how-to-make-your-event-support-contravariance.html#comments</comments>
      <pubDate>Sun, 04 Nov 2012 18:56:00 GMT</pubDate>
      <lastBuildDate>Mon, 05 Nov 2012 22:41:30 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>为List&lt;T&gt;内部添加一个“删除多个元素”的方法</title>
      <link>http://blog.zhaojie.me/2012/11/add-a-remove-multiple-method-for-list.html</link>
      <guid>http://blog.zhaojie.me/2012/11/add-a-remove-multiple-method-for-list.html</guid>
      <description>&lt;p&gt;不久前我在微博上提出一个问题：众所周知，.NET中自带的&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;集合类型没有“删除多个元素”的方法，那么假如我们是.NET类库中&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;的实现者，我们该如何添加这么一个方法？例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;namespace &lt;/span&gt;System.Collections.Generic
{
    &lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;List&lt;/span&gt;&amp;lt;T&amp;gt;
    {
        &lt;span style="color: blue"&gt;private &lt;/span&gt;T[] _items;
        &lt;span style="color: blue"&gt;private int &lt;/span&gt;_count;

        &lt;span style="color: blue"&gt;public void &lt;/span&gt;RemoveMultiple(&lt;span style="color: #2b91af"&gt;IEnumerable&lt;/span&gt;&amp;lt;T&amp;gt; itemsToRemove)
        {
            &lt;span style="color: green"&gt;// Replace the implementation here
            &lt;/span&gt;&lt;span style="color: blue"&gt;foreach &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;item &lt;span style="color: blue"&gt;in &lt;/span&gt;itemsToRemove)
            {
                &lt;span style="color: blue"&gt;this&lt;/span&gt;.Remove(item);
            }
        }
    }
}&lt;/pre&gt;

&lt;p&gt;其中元素保存在&lt;code&gt;_items&lt;/code&gt;数组中，而&lt;code&gt;_count&lt;/code&gt;则保存当前元素的个数。我这里给出了一个实现来体现这个方法的含义，但很显然这并不是一个合适的做法。原因有几个，一会儿会提到，但最重要的自然就是效率很低。请注意这里我们是“内部实现者”，因此肯定就是要提供一个高效的，并且尽可能通用的实现。&lt;/p&gt;

&lt;p&gt;有些同学表示如果要高效，则不应该用&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;这种数据结构。这个思路似乎考虑周到，但实际上很让人捉急，因为这还是种代码“消费者”的习惯，而不是代码的“提供者”。记得以前我也提出过一些&lt;a href="http://blog.zhaojie.me/2009/05/1491052.html"&gt;简单的题目&lt;/a&gt;，写明“抛出异常”，但大部分答案依旧在&lt;code&gt;try...catch&lt;/code&gt;，我认为这是同样的原因。在我看来，假如要提高技术水平，一定要把思维观念从技术的“消费者”切换为“提供者”，因为提供者能影响更多人，会让自己对自己编写的代码要求更高。&lt;/p&gt;

&lt;p&gt;其实这道题目没有标准答案，但是很容易判断出某一个实现好不好，对不对，有哪些缺陷等等。这题的确十分简单，但是会有不少细节方面值得考虑，所以我反复强调，光有思路是不够的，一定要写出代码来。&lt;/p&gt;

&lt;p&gt;首先，我想代码判断了参数的合法性，也就是&lt;code&gt;null&lt;/code&gt;与否。其次，您觉得该如何使用&lt;code&gt;itemsToRemove&lt;/code&gt;比较合适？一定要从头枚举吗？这里举一个.NET中自带的例子：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;namespace &lt;/span&gt;System.Linq
{
    &lt;span style="color: blue"&gt;public static class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Enumerable
    &lt;/span&gt;{
        &lt;span style="color: blue"&gt;public static int &lt;/span&gt;Count&amp;lt;TSource&amp;gt;(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;IEnumerable&lt;/span&gt;&amp;lt;TSource&amp;gt; source)
        {
            &lt;span style="color: blue"&gt;checked
            &lt;/span&gt;{
                &lt;span style="color: blue"&gt;if &lt;/span&gt;(source == &lt;span style="color: blue"&gt;null&lt;/span&gt;)
                {
                    &lt;span style="color: blue"&gt;throw new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ArgumentNullException&lt;/span&gt;(&lt;span style="color: #a31515"&gt;&amp;quot;source&amp;quot;&lt;/span&gt;);
                }

                &lt;span style="color: blue"&gt;var &lt;/span&gt;collection = source &lt;span style="color: blue"&gt;as &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ICollection&lt;/span&gt;&amp;lt;TSource&amp;gt;;
                &lt;span style="color: blue"&gt;if &lt;/span&gt;(collection != &lt;span style="color: blue"&gt;null&lt;/span&gt;) &lt;span style="color: blue"&gt;return &lt;/span&gt;collection.Count;

                &lt;span style="color: blue"&gt;var &lt;/span&gt;collection2 = source &lt;span style="color: blue"&gt;as &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ICollection&lt;/span&gt;;
                &lt;span style="color: blue"&gt;if &lt;/span&gt;(collection2 != &lt;span style="color: blue"&gt;null&lt;/span&gt;) &lt;span style="color: blue"&gt;return &lt;/span&gt;collection2.Count;

                &lt;span style="color: blue"&gt;int &lt;/span&gt;num = 0;
                &lt;span style="color: blue"&gt;foreach &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;item &lt;span style="color: blue"&gt;in &lt;/span&gt;source) num++;
                &lt;span style="color: blue"&gt;return &lt;/span&gt;num;
            }
        }
    }
}&lt;/pre&gt;

&lt;p&gt;可见，为了提高效率，有时候我们会考虑使用下标，而不是直接&lt;code&gt;foreach&lt;/code&gt;来进行计算，因为如常见的数组或是&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;这种枚举类型，使用下标访问的速度会比使用枚举器有一定程度的提高。另外，一般来说在使用&lt;code&gt;IEnumerable&lt;T&gt;&lt;/code&gt;的时候切忌多次遍历。&lt;/p&gt;

&lt;p&gt;假如我们使用最传统的&lt;code&gt;foreach&lt;/code&gt;配合现成的&lt;code&gt;Remove&lt;/code&gt;方法来实现&lt;code&gt;RemoveMultiple&lt;/code&gt;方法，其时间复杂度是O(M * N)，其中N是目前&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;中的元素个数，M是&lt;code&gt;itemsToRemove&lt;/code&gt;中的元素数量。这种是最差的时间复杂度，原因是每删除&lt;code&gt;itemsToRemove&lt;/code&gt;中的一个元素，就需要从整个列表的起始位置找起。于是，有些同学想到把被删除的元素放在一个&lt;code&gt;HashSet&lt;/code&gt;中，这样确定单个元素是否需要删除的时间复杂度是O(1)，而构建这个HashSet的时间复杂度是O(M)，于是总共是O(M + N)，这显然比O(M * N)要好太多。&lt;/p&gt;

&lt;p&gt;但问题在于，&lt;code&gt;HashSet&lt;/code&gt;是不够的，因为集合中的元素不可重复，而&lt;code&gt;itemsToRemove&lt;/code&gt;中显然是可能有重复元素的，这意味着要从列表中删除多个相同的元素，这个需求也很正常，因为&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;中本身就有可能重复。于是一个比较容易想到的做法便是建立一个字典，保存某个元素需要被删除的次数。&lt;a href="https://gist.github.com/4000340/0382888254f0e15e5805a1fd2c7837dd85e99f19"&gt;装配脑袋的做法&lt;/a&gt;便是如此：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public void &lt;/span&gt;RemoveMultiple(&lt;span style="color: #2b91af"&gt;IEnumerable&lt;/span&gt;&amp;lt;T&amp;gt; itemsToRemove)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;removingItems = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Dictionary&lt;/span&gt;&amp;lt;T, &lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;();

    &lt;span style="color: blue"&gt;foreach &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;item &lt;span style="color: blue"&gt;in &lt;/span&gt;itemsToRemove)
    {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(removingItems.ContainsKey(item))
        {
            removingItems[item]++;
        }
        &lt;span style="color: blue"&gt;else
        &lt;/span&gt;{
            removingItems[item] = 1;
        }
    }

    &lt;span style="color: blue"&gt;var &lt;/span&gt;setIndex = 0;

    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;getIndex = 0; getIndex &amp;lt; _count; getIndex++)
    {
        &lt;span style="color: blue"&gt;var&lt;/span&gt; current = _items[getIndex];
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(removingItems.ContainsKey(current))
        {
            removingItems[current]--;
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(removingItems[current] == 0)
            {
                removingItems.Remove(current);
            }

            &lt;span style="color: blue"&gt;continue&lt;/span&gt;;
        }

        _items[setIndex++] = _items[getIndex];
    }

    _count = setIndex;
}&lt;/pre&gt;

&lt;p&gt;不过从细节上说，这个做法还是有些改进空间。例如，一次&lt;code&gt;removingItems[item]++&lt;/code&gt;实际上就会访问两次字典，一次取值，一次是加一后设置回去，在此之前还有个&lt;code&gt;ContainsKey&lt;/code&gt;判断。字典的读写操作理论上是O(1)，但实际上在内部会调用每个元素的&lt;code&gt;GetHashCode&lt;/code&gt;方法，以及一次或多次&lt;code&gt;Equals&lt;/code&gt;，这对于没有重载过这两个方法的引用类型，或是&lt;code&gt;int&lt;/code&gt;等基础类型来说比较迅速，但假如T是一个字符串，开销还是会大上好几倍。因此，我们还是希望可以尽量少地访问字典。在我目前工作中的项目里，表示一个属性的可选方式是一个数字下标，这样很多地方就可以直接使用数组来保存与属性有关的映射关系，而不需要用&lt;code&gt;PropertyInfo&lt;/code&gt;甚至更慢的字符串来查找字典。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，最好是编写一个特定的数据结构——但并不“特殊”，因为这就是个典型的&lt;a href="http://en.wikipedia.org/wiki/Set_(abstract_data_type"&gt;Bag（也称为MultiSet）&lt;/a&gt;)，顾名思义，便是允许重复元素的集合。在一个Bag中，相同元素可以被添加或删除多次。&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public void &lt;/span&gt;RemoveMultiple(&lt;span style="color: #2b91af"&gt;IEnumerable&lt;/span&gt;&amp;lt;T&amp;gt; itemsToRemove)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;removingItems = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;HashBag&lt;/span&gt;&amp;lt;T&amp;gt;(itemsToRemove);

    &lt;span style="color: blue"&gt;var &lt;/span&gt;setIndex = 0;

    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;getIndex = 0; getIndex &amp;lt; _count; getIndex++)
    {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;current = _items[getIndex];
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(removingItems.&lt;span   ?&gt;Remove&lt;/span&gt;(current)) &lt;span style="color: blue"&gt;continue&lt;/span&gt;;

        _items[setIndex++] = _items[getIndex];
    }

    _count = setIndex;
}&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;HashBag&lt;/code&gt;内部，我们每次添加和删除元素只需要访问一次代码，便可以增加或删除该元素的计数器。封装一个通用的&lt;code&gt;HashBag&lt;/code&gt;容器之后，连代码都变的简单很多。但是，使用基于哈希容器一般会占用相对比较大的空间，为了提高效率及节省空间，在可行的情况下，我们还可以为在创建&lt;code&gt;HashBag&lt;/code&gt;的时候指定尺寸，或者权衡之下选用二叉树而不是基于哈希的Bag，这样时间复杂度会变成O(log(M) * N)，但空间使用可以节省许多。此外，我们还可以尝试建立一个现有元素至其下标的映射，先找出需要删除的位置，最后进行一次移动。这在不同的M和N大小关系时都是可能的选择。&lt;/p&gt;

&lt;p&gt;但问题是，这就足够了吗？以上这段实现实际上还有错误！请注意，最后我们虽然把&lt;code&gt;setIndex&lt;/code&gt;赋值给&lt;code&gt;_count&lt;/code&gt;，但是&lt;code&gt;setIndex&lt;/code&gt;和旧的&lt;code&gt;_count&lt;/code&gt;之间的元素，我们并没有设成&lt;code&gt;null&lt;/code&gt;（确切地说应该是&lt;code&gt;default(T)&lt;/code&gt;），这就会造成内存泄露。总有同学说托管程序不会出现内存泄露，这我不同意，托管程序还是程序，并不能阻止程序员犯错误嘛。不过话又说回来，我们一定需要将那些位置设为&lt;code&gt;null&lt;/code&gt;吗？答案是否定的，对于像&lt;code&gt;int&lt;/code&gt;等基础类型来说，我们就完全无需实现这点。&lt;/p&gt;

&lt;p&gt;不过话说回来，你会如何判断一个T是否需要设为&lt;code&gt;null&lt;/code&gt;？是在&lt;code&gt;RemoveMultiple&lt;/code&gt;内部每次判断下&lt;code&gt;typeof(T)&lt;/code&gt;吗？答案依旧是否定的，只需要定义一个静态成员即可。要记住，&lt;code&gt;List&amp;lt;int&amp;gt;&lt;/code&gt;和&lt;code&gt;List&amp;lt;string&amp;gt;&lt;/code&gt;是两个不同的类型，它们的静态成员是分开存放的。这&lt;a href="http://blog.zhaojie.me/2009/09/i-made-a-mistake-can-you-figure-it-out.html"&gt;有时候会带来问题&lt;/a&gt;，但&lt;a href="http://blog.zhaojie.me/2009/11/cache-and-object-creation-benchmark.html"&gt;善加利用也会收到很好的效果&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这些都是细节。&lt;/p&gt;

&lt;p&gt;其他还有一些值得考虑的有意思的地方。例如，您的实现如果遇上&lt;code&gt;list.RemoveMultiple(list)&lt;/code&gt;这种用法，会出现什么样的情况？例如，&lt;code&gt;itemsToRemove&lt;/code&gt;的数量假如远大于当前的元素数量，其代价是否过高？例如，假如&lt;code&gt;itemsToRemove&lt;/code&gt;是一个无限长的枚举，但到某一个阶段却可以把所有当前元素删光，那么您的实现能否直接返回？&lt;/p&gt;

&lt;p&gt;这些都是&lt;code&gt;RemoveMultiple&lt;/code&gt;方法可能会遇到的状况。我这里做出的假设是可以修改&lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;的内部实现，因此我们甚至可以开一个新的数组赋值给&lt;code&gt;_items&lt;/code&gt;——假如它再某个情况下有帮助的话。当然，作为一个通用的实现的来说，一个方法应对大部分的情况就够了，我们无法顾及各种环境下的最坏情况。在实际情况下，有时候我们知道更多条件，甚至选择更合适的做法，并且使用反射从外部设置&lt;code&gt;_item&lt;/code&gt;及&lt;code&gt;_count&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;假如我用这道题目来进行面试，以上便是我会考察的一些思路。正像我一开始说的那样，这题没有标准答案，更关键的是对于思路的考察，考察一个程序员考虑问题是否全面。我虽然列举了那么多，但肯定也有我没有想到的地方。&lt;/p&gt;

&lt;p&gt;但是，光有思路是不够的，也一定要写出代码来。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/11/add-a-remove-multiple-method-for-list.html#comments</comments>
      <pubDate>Sat, 03 Nov 2012 00:06:31 GMT</pubDate>
      <lastBuildDate>Sat, 03 Nov 2012 11:32:17 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/life/">生活心情</category>
      <title>图灵访谈之三十六：以“玩”之名——赵劼（老赵）专访</title>
      <link>http://blog.zhaojie.me/2012/10/interview-by-turing.html</link>
      <guid>http://blog.zhaojie.me/2012/10/interview-by-turing.html</guid>
      <description>&lt;p&gt;最近一个多月工作很忙，再加上之前参加许多活动，搞得身心俱疲，于是这段时间一直在休整，以看书和思考为主，连Wind.js也碰的不多，更别说博客了。接下来又要开始努力了，包括写博客，于是就从转帖&lt;a href="http://www.ituring.com.cn/article/14720"&gt;这个访谈&lt;/a&gt;开始吧，也可以顺便继续修订一下。这是两个月前在图灵公司接受的采访，从一大早到下午，原本还担心无甚可讲，但最后只感觉时间不太够用。这篇采访中所有的内容都是我的真实想法，但后果就是又有更多人往我一举一动上贴“微软”标签了，很无趣，所以这年头说真话还不如跟着分析师评论员们说套话来的好。不过想贴标签就贴罢，爱咋咋滴，就像访谈里说的，大家都是聪明人，爱帖标签的人就算没标签也可以找出其他说法来。&lt;/p&gt;

&lt;h1&gt;编程人生的开始&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;一开始大家都是每天在一起做类似的事情，但是到后来你就会发现，你们在以后的发展路径中就再也没有交点了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;图灵社区：你是什么时候开始学编程的？&lt;/h2&gt;

&lt;p&gt;我小学毕业的时候搞来一台486电脑，上面装了一个DOS系统，于是我开始搞最简单的编程，当时就是为了好玩。我用DOS写了一个bat，功能大概是在系统启动之后自动执行，生成一个菜单，可以上一页下一页或者按个数字进入某个应用，退出后重新回到这个菜单，目的就是为了避免输入命令，方便操作。当时还没有互联网，全靠一本叫“DOS 6.2”的书，这是唯一的渠道，现在回想起来，这些东西好像也挺有难度的，不是那么简单（笑）。后来（写代码）就是为了玩游戏，什么大富翁3，大航海时代什么的，都是那个时候的经典。我一直对计算机比较感兴趣，小时候还学了十年钢琴，但是我敢说基本没有琴童是对钢琴感兴趣的，可能长大后会有些兴趣，但是当时肯定都是被逼被打的。后来我发现自己太笨，玩不好游戏。&lt;strong&gt;上大学的时候大家流行玩CS，（玩游戏时）我人都没看到一个，就死了，下一局，还是没看到人，我又死了，我就搞不清楚这个东西的趣味在什么地方，所以不如把时间花在写程序上比较有趣。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的升学经历就是全考，我的有些同学都是一路直升，没有经过大考，而我每次都是差一点点。小学考初中时，老师总说你们要是不好好学习，到时候就差0.5分考不上，结果那个人就是我。高考的时候，我努力搞计算机竞赛，想去交大。我其他成绩比较差，一直以来的打算就是不高考，精力都是用在信息奥赛方面。结果我高考那年交大拿了一个ACM的世界冠军，显得很牛，当时有五大联赛：数学、物理、生物、化学、计算机，而交大只要数学或者物理的直升，而复旦都要。最后没办法，还得高考，我用仅剩的半年时间拼命读书，同时因为痛恨交大所以报了复旦，还好最后考进了。&lt;/p&gt;

&lt;h2&gt;图灵社区：你所接受的大学教育有什么可圈可点之处吗？&lt;/h2&gt;

&lt;p&gt;进入复旦的软件学院对于我来说是很幸运的，当时的院长很有水平，在理念上很先进。从大一开始我们的所有教材都是国外的，全英文。其中大部分都是MIT等国际名校的教材，比如《深入理解计算机系统》那本书就是我们主要的教材，学编程基础课时也建议我们看&lt;em&gt;Core Java&lt;/em&gt;，学操作系统的时候用的也都是响当当的恐龙书，现在看来真的是很有价值。&lt;strong&gt;我们从大一开始啃大部头的英文原作，我只能硬啃，不能怕，这样学下来收获是很大的。&lt;/strong&gt;当时人人都这样学习，所以整体环境也是很向上，我同寝室隔壁寝室的人大都比我强。可惜现在看来，我大学的时光还是浪费了很多，算是比上不足，比下有余。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有时候我会很奇怪，为什么有些人没有看过《操作系统概论》，为什么有人觉得写一个语言或者编译器是一件很了不起的事情，为什么很多人也都没有自己写过操作系统。&lt;/strong&gt;这些其实都是学校里的大作业，虽然我们写的操作系统也是比较弱的，但是那也是一个操作系统，线程调度，虚拟内存，文件系统等等，该有的都会有，也可以在虚拟机里启动。这些在我看来应该是人人都做过的东西，而很多人都没有做过。虽然我大学里专业课成绩也不算差，但是因为当时在学校的学习有时间压力，也贪玩，虽然不玩游戏但也会跟同学或女朋友玩，同时也很懒，所以教科书中的很多内容其实还是没有吃透。&lt;/p&gt;

&lt;p&gt;还有一点就是课程的设计，我们还有函数式编程课程，我那时学LISP，后两年的学生学的是Haskell。学到后来有不同方向，无论哪个方向都可以毕业。有些人甚至学的是逻辑式编程，Prolog什么的。虽然很多东西对我的帮助可能不会直接感受到，例如我没有做过任何实际的操作系统或函数式开发，但是这些课程设计是很了不起的。&lt;/p&gt;

&lt;p&gt;一直都有人问我不知道怎么进步，有什么书可以推荐。&lt;strong&gt;我通常的回答就是，你要提高什么我不知道，但我建议你回到大学的课程，也可以参考国外教科书中的内容，跟着教科书你肯定不会错。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在大学里，有些东西我要看三五遍才能懂，而我寝室的兄弟只看一遍就懂了。他大一就看《具体数学》，甚至高德纳那套《计算机程序设计艺术》那样的书，我希望有一天我也能看懂这套书。很多人在大学之初看起来都差不多，&lt;strong&gt;一开始大家都是每天在一起做类似的事情，但是到后来你就会发现，你们在以后的发展路径中就再也没有交点了。&lt;/strong&gt;我认识的一起在暑假里做过项目的人中就有人去了普林斯顿，走上了科研道路，我觉得我似乎永远都无法企及他那种高度了。&lt;/p&gt;

&lt;h1&gt;理想？现实？&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;这段创业经历给我的启示就是，我不想当老板，我就想当码农，快乐地编码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;图灵社区：你有没有什么梦想？&lt;/h2&gt;

&lt;p&gt;我从小就想当科学家。科学家是推动人类进步的源动力，我相信世界是由科学家推动的。他们不一定要有很强的工业背景，我所崇拜的科学家就是搞研究的，并不急着把自己研究的东西转化成实际产品，世界上不缺急着赚钱的人。他们（科学家）可能会做10年，20年以后才能得到有实际用途的东西，等到这些东西真正发展成熟了工业界才会拿去用。&lt;strong&gt;科学家会把世界向前推动一点点，而不是在已知的领域把已知的东西反复利用，炒作价值。&lt;/strong&gt;比如华尔街那些用钱生钱，玩数字游戏的一群人，他们可以赚很多的钱，但是他们对人类发展的贡献很小。我尊重个人的选择，有人喜欢赚大钱让自己过得舒服一点，但对我个人而言对于科学家更有认同感。我希望以后可以赚够足够的钱，不用工作就可以生活，那时我愿意重新去读书，重新进入学术界。&lt;/p&gt;

&lt;p&gt;我承认科技有它的副作用，但是那是由于人类的滥用。例如，现在由于科技只是发展到一定程度，它能产生让人吃上去舒服但是并不健康的东西，但是如果再往前发展，我相信添加剂可以做到提高口感而且很健康，而这些负面的效果可能只是因为科技发展还不够，人类还没有准备好。现在的社会环境就是做好事可能没有什么直接好处，但是做坏事有可能会拿到很多钱，人们权衡利弊，还是决定做坏事。&lt;strong&gt;假如做好事和坏事的成本和收益相差不大，我相信人们还是会选择做好事的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我认为宗教和科学并不抵触，宗教让人对未知的世界保留一丝敬畏，科学解决不了的东西也是存在的。&lt;strong&gt;科学是在探索世界，而不是在发明世界。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;图灵社区：谈一下你职业发展的历程吧。&lt;/h2&gt;

&lt;p&gt;我第一份工作是在一家国内二线的大型网站，开发他们的媒体平台。我忍不了程序员们无所事事、甚至还不想好好做事情的氛围，所以只呆了六个月左右就离开了。举个例子，他们有的人可能会复制粘贴50次，也不会想到要提取出一个公用的方法。这地方的氛围跟我理想里的科研机构根本没法比，就像是你说草履虫不是哺乳动物一样，中间还隔着十万八千里呢。&lt;/p&gt;

&lt;p&gt;后来我和陈黎夫一起创业两年多，做一个女性奢侈品网站。&lt;strong&gt;这段创业经历给我的启示就是，我不想当老板，我就想当码农，快乐地编码。&lt;/strong&gt;创业对我来说没什么吸引人的地方。有了这段经历，人家再跟我说创业的时候，我就可以说：创业，我早创过了。当时刚出校门没多久，思路也不清楚，说实话这次创业也只是一个普通的工作，只不过自由一些，工资少些。&lt;/p&gt;

&lt;p&gt;后来我去了盛大，差点试用期没有过。&lt;strong&gt;因为老板坐在我身后，一抬头就能看见我的屏幕，他就会问：你怎么又在刷微博啊？&lt;/strong&gt;别人都是试用期过了直接入职，我当时和老板谈老半天。其实我干的活也不比别人少，麦库的架构都是我一点一点搭出来的，第一行代码就是我提交的，现在的API也是我当时绞尽脑汁设计和实现出来的，自诩十分漂亮，十分Restful。虽然我不喜欢做产品，也不认同只有产品才能体现技术的价值或是技术脱离产品就失去意义等观点，但就算从产品角度来衡量工作成果，好像我还是比很多人干得有价值呢。盛大创新院诞生过很多项目，死掉的不少，突出的不多，但麦库算是其中比较突出的一个吧。&lt;/p&gt;

&lt;p&gt;现在我在IBM，去IBM并没有经过猎头，我似乎不是猎头们喜欢的类型（笑），基本没人来找过我。来IBM的主要原因是在深圳工作，面向香港客户，我想这样在香港产子会方便一些，这方面对我来说还是很有吸引力的。我现在是香港公民，但不是永久居民。只要有工作签证就能拿到香港身份证，便是所谓的香港公民了，但必须连续六年还是七年是香港公民才能成为“永久居民”。可惜我刚去香港没多久，香港就规定“双非”子女即使在香港出生也不算永久居民，直接摧毁了我南下最主要的原因。我一直说我运气很不好，读书时每次直升都差一点点。我的小学初中关门了，高中大学都堕落了，之前提到我很敬佩的院长也因为某些原因去交大了，至于呆过的公司则要么倒闭要么走下坡路。&lt;/p&gt;

&lt;p&gt;我的自我调节能力还是很强的，总能在工作中找到自己喜欢做的事情。在IBM的时间对我来说过得很快。&lt;strong&gt;我对工作的要求就是不要让我不停的加班，没有自己的时间，晚上七点最晚八点对我来说就应该结束工作了。&lt;/strong&gt;我是享乐派码农，最爱美女，其次是弹钢琴，接着才是编程，所以我不会去创业，也自觉不加入创业公司。&lt;strong&gt;我自诩加入哪家创业公司哪家就必倒，至少工作态度上会被我带坏。创业跟享乐还是很难共存的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;图灵社区：你现在在IBM的工作内容是什么？&lt;/h2&gt;

&lt;p&gt;很多人其实不知道我做些什么，他们能看到的最多只是我写的文章等东西。我平时的工作既不流行也不火，只是一般的平常工作。我现在在IBM里做投资银行的相关项目，完全不涉及IBM内部事务。比如说给投行做一些交易系统前端之类，比如说处理交易，聚合一些数据给人看等等。用户则根据这些数据制定下一步的行动决策，设法赚更多的钱。在银行这种非技术为核心的不差钱的机构，很倾向于直接买现成的东西来一用。他们不差钱，可以拿钱换时间、换机会。我不少技术方面的工作实际都是围绕这些现成的产品，而银行的核心业务很少有人能接触到。核心业务，比如说根据大量的历史交易辅助交易员和研究员作出下一步决策。这里面需要大量的数学和算法知识，也需要对业务熟悉，而大部分人都是在做外围，买一个设备、买一个软件，然后使用。&lt;/p&gt;

&lt;p&gt;我在GDC，算是IBM的二等部门，这个部门可以简单认为是IBM开的外包公司，例如前段时间非常著名的苏宁项目，便是南京GDC参与的。GDC前几年还不算是正式的IBM部门，后来才进入IBM的正式编制，但对于IBM一等部门，例如IBM China及CDL的一些人来说，GDC的人都不算是真正的IBM员工。这个部门也很难让人产生归属感，虽然我的合同是长期的，但是有些项目的人签的都是短期合同，雇用期随着项目中止而结束。&lt;/p&gt;

&lt;h2&gt;图灵社区：你看起来精力充沛，你怎么分配你的时间？生活的时间？维护博客的时间？学习新技术的时间？&lt;/h2&gt;

&lt;p&gt;我7点左右下班，女朋友一般会早下班买菜回家，我到家后做饭，吃完饭可能会弹会儿钢琴，但是10点之后就不能再弹了，邻居会疯掉的，我承诺图灵社区会录一段钢琴曲给大家（笑）。我之前还会花时间健身、减肥，但是减到80（公斤）就再也减不下去了。他们都说我的体型是“正太”分布的曲线。其实我觉得我的生活还是挺丰富多彩的，例如除了弹琴外我唱歌也不错。之前我还参加了深圳IBM唱歌比赛，最后拿了第三名，而且在打分阶段我还是第一，只不过PK的时候败了。有人说码农苦逼，我倒觉得还好，我现在的同事有那么一堆人，每个周末都在一起玩，比如看电影啊吃饭啊K歌啊桌游啊或是去海边玩什么的，还有什么“吃遍深圳”计划，high的不得了，反倒是我周末要忙着写代码或是陪女朋友活动，只是偶尔才加入他们。所以关键还是看自己啊，&lt;strong&gt;一是要热爱写代码，这样就不会觉得工作太累，二是要热爱生活，没说码农就只能宅在家的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我博客的内容大部分都是平时在想，真正需要码字的时候其实不费多少时间。博客维护对于我来说是随时随地的事，你经常会看到我拿着一个平板电脑，有可能我就是在做这件事。其实我觉得写作就是在说话，把你想说的东西写清楚就可以了，怎么想就怎么说，怎么说就怎么写。Wind.js可以说是提升我个人价值的东西。很难统计每周我花在这上面的时间，&lt;strong&gt;因为我可能每时每刻都在思考一些东西、构思一些代码，甚至在脑中进行实现，至少每时每刻都因为它在和别人进行交流。&lt;/strong&gt;我现在在推广它，希望在未来某个时刻，忽然有一个大项目或者大公司决定使用它，或者收编它，这样它就能火了。&lt;/p&gt;

&lt;p&gt;对于新的技术，我一般很少看这方面的书，但是我会把源代码花一点时间（比如说一个周末）看一下，里面有一些沟沟坎坎就全都清楚了，该怎么用，靠想也能想明白。对于我比较熟悉的技术，我可能从头到尾执行一遍就知道（怎么回事）了，然后在网上看一些介绍用法的文章，我就能想到它是怎么做出来的。看一个项目我也知道从哪里看起，因为我知道它的执行过程是怎么样的。书当然也会看，但一般都是看些实现原理，设计思路的书，因为这些内容有时很难从代码里看出来。当然对于大部分我不会深入的技术，我可能就不会读源代码，直接看一些内部实现或是思路分析的书就满足了。&lt;/p&gt;

&lt;h1&gt;以“玩”之名&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;我为了玩技术而搞技术，这层次显然比为了做产品才搞技术要高得多嘛。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;图灵社区：有人说你不会转换自我价值？&lt;/h2&gt;

&lt;p&gt;我觉得还好吧，我写博客，和大家交流也影响了很多人啊。我赚的钱也够花，按照winter同学的说法，&lt;strong&gt;虽然买不起房，很多人也买不起啊，但我去必胜客点最贵的套餐也丝毫没有压力啊。&lt;/strong&gt;难道是说我不是分析师管理层，或不是什么O吗？其实我现在就是Wind.js的CEO加上CTO加上天使投资人，我还是Founder，连co都没有。&lt;/p&gt;

&lt;p&gt;或者是因为我不写书？我还是情愿多写点程序，多写点零碎的文章来讲讲自己的想法。我喜欢自由，而写书会被太多的东西束缚住。我不喜欢在边角上投入精力，有这个时间，我情愿去做一个项目，例如把Wind.js的边边角角都做好，然后顺便写一些总结和体会。写书我认为需要面面俱到，把沟沟坎坎都填掉，而我现在还没有那种精力和状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我是个纯码农，还是享乐派的，所以我是为了兴趣才写代码，写代码完全是因为好玩。&lt;/strong&gt;有人说搞技术是为了做产品，没有产品技术就失去意义，我倒不觉得。在我看来技术不仅仅是工具，还是玩具，甚至是艺术品。&lt;strong&gt;我为了玩技术而搞技术，这层次显然比为了做产品才搞技术要高得多嘛。&lt;/strong&gt;你看动物只把交配作为繁衍后代的手段，而人类已经把交配当作娱乐和社会活动了。现在很多技术人员喜欢说产品，我觉得这其实挺有问题的。你知道自己在什么场合或者在说什么东西倒也罢，但我看来很多时候就是一些不怎么样的技术人员在瞎找借口乱讲大道理。举个不怎么好听的例子，在讨论语言设计的时候总有人会嚷嚷“语言之争没有意义”什么的，在我看来这好比人类在讨论某些“技术性问题”的时候，动物们冲出来插嘴说“体位之争没有意义”。但其实呢？它们首先不知道并非所有物种都是为了繁衍才交配的，其次它们也不懂体位对于繁殖的效率也是很重要的。比如人类在帮狗配种之后，都会把母狗倒悬20分钟，目的就是为了增加受精成功率。&lt;/p&gt;

&lt;p&gt;你看我微博的认证信息，不是那个自己随便填的个人说明，就是“资深码农”，我是真以码农身份为豪的。所以我也不会对什么业界大事或是传言做什么分析什么，在我看来那是互联网分析师做的事情，我挺不喜欢现在网上遍地都是的那种产品经理或者分析师。&lt;strong&gt;我甚至不会对技术做什么预测，因为预测什么的我觉得太不靠谱，太廉价，很多时候正过来反过去说都行，都太没意思了。&lt;/strong&gt;我最多就根据“事实”发表看法，当然也就是在技术方面。&lt;/p&gt;

&lt;h2&gt;图灵社区：最近有很多关于裁员和失业的新闻，你觉得作为程序员需要掌握什么样的能力，学什么样的技术？&lt;/h2&gt;

&lt;p&gt;把自己和任何产业或者某种技术绑定在一起在我看来都是不太可靠的，对于我来说，我干任何工作我都是以提高个人能力为目标，这样安全一点。当然话说回来，现在想要绑定某种技术也不容易吧，搞.NET的失业了就不能去搞Java了吗？&lt;strong&gt;如果某人真把自己和某种技术绑死了，那基本就是自找的。&lt;/strong&gt;我觉得现在很多同学遇到的困难都可以归结为自找的。例如，说程序员找不到女朋友？那是因为你不敢厚着脸皮去找，我就基本一追一个准，我觉得IT男其实挺有优势的。例如，说程序员看不懂英语书？那是因为你没有像我一样硬啃原版的大部头书，我的英语也就四级水品，之前在微博上被一大堆人鄙视的，但我现在英语做点技术方面的双语演讲也够用。例如，说程序员不会写文章作演讲？那是因为没有坚持写坚持说，我刚开始写的博客现在看起来也十分稚嫩，&lt;strong&gt;初中时竞选大队长时我演讲双腿发抖同学都看得到，而现在面向几百人做演讲毫无压力，这都是自己逼出来的。&lt;/strong&gt;好吧不说了，再说下去变炫耀贴了……&lt;/p&gt;

&lt;p&gt;回到技术，我认为技术要根植于现在。&lt;strong&gt;有些人觉得专注于稳定的技术不怕找不到工作、吃不饱饭，但是吃的香不香、好不好就是另外一回事儿了。&lt;/strong&gt;热门的东西可以捞一票就走，然后吃香的喝辣的去。例如，虽然C的历史十分悠久，重要性毋庸置疑，但是搞C的人一定能找到很好的工作吗？有可能这个市场已经饱和了，只有学得很好的那群人才能到很好的报酬。而如果你做很火的技术比如说PHP，那里有大量的工作机会，没准可以得到很快的提升，你的生活水平和自身价值也会得到迅速地提高。&lt;/p&gt;

&lt;p&gt;我在技术上很倾向于微软，但是就算（微软）真倒了我也不担心找不到好工作，因为我又没有把自己绑死在微软技术上，而且技术多少是相通的，去搞别家技术一样顺利。打个比方，当年Google最火的一件事情就是从微软大肆挖人，&lt;strong&gt;假如搞微软技术都必须靠微软才能混饭吃，那么那些人去了Google之后是做什么的？&lt;/strong&gt;难道是写.NET或做Windows开发么？还有，StackOverflow总得分第一的Jon Skeet，也就是我唯二或唯三推荐的.NET必读书籍《深入理解C#》的作者，他搞了好久的.NET，比我还深入也说不定，结果不也直接被挖去Google嘛。说起来我推荐的另一本.NET必读书籍《Framework Design Guideline》的作者之一Brad Abrams也跳槽Google了，所以实在不行我也可以去Google嘛（笑）。&lt;/p&gt;

&lt;p&gt;我学技术唯一的标准就是要有意思，好玩，或者说有美感、符合我的口味。就像我很不喜欢指针和或纠缠于内存地址等大量细节，所以我就对C和C++都敬而远之，尤其是后者，前者至少比较容易理解吧，大学里也用过不少。其实我十年前在IE6上玩JavaScript的时候不也是破破烂烂的嘛，谁知道后来Google和Chrome把它带火了呢？&lt;/p&gt;

&lt;h1&gt;我相信的事&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;我不会为了推广自己的概念而忽悠人或者贬低别人。我只会说我认为正确的东西。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;图灵社区：你是出了名的微软系，为什么对微软这么推崇？&lt;/h2&gt;

&lt;p&gt;我做.NET的原因是因为对Anders Heisenberg的崇拜，而后来技术这条路线是对微软的欣赏。经常听某些老一代程序员说微软对程序员怎么怎么不好，抛弃了多少技术，但我没这种体会。我应该算是随着.NET诞生开始搞微软技术的，之前做的更多的是Java，中学时则更多用Delphi做过一些小游戏以及一些教学用的课件，而从搞.NET开始我就没觉得它有放弃的迹象。&lt;/p&gt;

&lt;p&gt;我欣赏微软，是因为微软是一家Geek公司，看看Channel 9就能知道这点。另外微软在软件研发乃至研究方面的投入是最大的，而且它在研究方面的投入可谓不计回报，所以你会发现微软研究院有很多案例都很有趣。而在开发技术方面，它的DevLabs里面也有许多有趣的项目和技术，例如Reactive Framework，实在是让我眼前一亮，真心佩服那些人的聪明才智。Reactive Framework的思路是对“拉”模型的接口取逆，成为一种推模型，然后一下子就可以推广至各式推模型和异步操作了。Reactive Framework的提出者是Erik Meijer，他是微软的级别比较高的研究员，之前在大学里当教授，这种人我想当喜欢。微软的研究成果可能很长时间以后才会变成产品，比如说Kinect。话说回来，我的Wind.js也是受到了他们的F#中计算表达式特性的启发，&lt;strong&gt;说实话F#也没有多火或是多流行，但有多少公司会用心发展一门受众不那么广的语言，并放入自己的主流产品中？&lt;/strong&gt;像Google开发Dart或Go语言，目的都相当明确，就是要替换现有的JavaScript或C++等语言。有人总说苹果公司研发投入比微软少得多，却赚得确盆满钵盈，表明转化效率多么惊人，所以多么厉害。我的结论恰好相反，因为&lt;strong&gt;商业上的成功不能吸引我，相比起来我更佩服微软那种不计产出——当然肯定不会丝毫不计——的研发投入，这跟我佩服搞科研的人是一种思路，我就欣赏某些二杆子精神。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有人常会问我为什么不去微软工作，我之所以没有去微软是因为，理论上说，在微软你不可以读开源的代码。微软害怕你在看了开源的项目之后，会不知不觉地在工作中应用到开源东西，产生法律纠纷。这点真的很可惜，必须对微软做出严厉批评，还好微软开源的东西也越来越多了，F#和ASP.NET MVC一直开源，现在整个ASP.NET 技术基本都开源了，还有Entity Framework等等。现在微软也在Node.js和HTML5等开放技术上投入很多。例如，在iOS上使用HTML5技术开发应用还有因为太简单被苹果拒绝的风险，而Win8直接把HTML5作为原生开发技术了，最近微软还和某公司共同向HTML5移植了大量经典小游戏，所以我一直自诩杂牌技术玩家，但搞了半天最后还是没有逃出微软的五指山（笑）。&lt;/p&gt;

&lt;h2&gt;图灵社区：你和开源社区和开源项目其实有着很多联系，你对国内开源现状怎么看？&lt;/h2&gt;

&lt;p&gt;我认为国内的开源属于开源初级阶段，就是说打着开源的旗号来做其他一些事情。举个例子来说，现在的开源项目貌似很多，每个公司都有开源项目，但是很多公司他们只是开源自己的东西，而不用别人的东西。开源自己的东西很容易，因为代码都是自己写的，我可以说我要弄一个开源项目，然后我把我的代码放出去，然后这个事情就结束了。但是你有没有在持续更新呢？有没有对这个项目的周边进行持续性投入呢？&lt;/p&gt;

&lt;p&gt;开源项目附带有一种正面的宣传效果，好像取得了道德制高点一样。用来体现公司对社会的价值，提高公司的层次。但是问题是，你自己用的是不是你开源出去的东西？有的公司本身在用一套，但是并不及时更新外面的程序，开放源代码很容易，但是配套的东西都没有做到位。这里还会涉及另到一些问题，比如说，我从外界可不可以提交代码？外部想用这个东西有没有足够的说明文档？使用这个东西出了问题应该找谁？有没有什么地方可以讨论出一套解决方案？别的公司可以用你的东西吗？而你会用别人的东西吗？比如说Hadoop，源于Yahoo，很多公司都在用，Facebook也在用也在不断贡献，它同时也在开源自己的一些技术，Facebook开源的技术Yahoo也能用，Yahoo也会作出贡献。&lt;/p&gt;

&lt;p&gt;开源之所以有意义就是因为，每个人都可以提交补丁，为它作贡献，最终达到大家都获益的效果。而国内的现状就是你不用我的，我也不用你的，&lt;strong&gt;我不在意别人用不用我的东西，我也不在意这个东西接下来的发展，我只是作出一个姿态：这个东西开源了。&lt;/strong&gt;比如说最近两年，大家都号称开源了自己的底层数据库，而为什么大家最终都只是各做各的？说白了这也不过是一种广告而已。而不是我为你的项目贡献，让我自己变的更好。我觉得一个好的状态应该是，一个项目出来，没有人在意这个项目是谁的，没有人算计和计较究竟谁获益较多。其实开源就应该是大公司搞了，用自己的资源和钱来支撑这个项目，最后做出有益的东西，而不是随便玩玩。&lt;/p&gt;

&lt;h2&gt;图灵社区：你经常被卷入网上的一些争论中，你怎么看待这件事？&lt;/h2&gt;

&lt;p&gt;我一直都认为自己是个不太聪明的人，但是虽然这样我仍然在茁壮成长。之所以有些人觉得我很自信，是因为我会花时间学习，我认为我已经掌握了令自己信服的东西之后，才会据理力争。可能有人花一个小时查几个名词解释就可以很有底气，但是我可能要花5个小时才能把一些东西搞明白。你可以“拍”我，只要你的道理是通的，我也会经常纠正自己的观点。我希望可以用作研究的态度来争论一些观点，但是实际过程中可能未必控制得好。&lt;/p&gt;

&lt;p&gt;我觉得程序员在讨论技术话题时，不要扯太远，能给数据就给数据，没有数据也可以讲道理，不要绕。我很烦讨论的时候偏离主线，绕得很远。比如说，你说你的做法速度快，我测了一下觉得速度不快，你就说“这个做法还有其他好处”，结果就越扯越开。&lt;strong&gt;本来谈技术，谈到后来又扯到用户体验。&lt;/strong&gt;前段时间在讨论内存大小的问题，有人说某某情况下有内存泄漏，然后我和别人做过实验没有内存泄漏，后来对方又说内存大有什么不好，结果实验下来实际上只是系统认为没有必要及时释放而已，接着对方又说这会让用户体验不好会让界面卡，但是为什么会影响用户体验？你必须拿出一些证据。这种情况下话题越扯越多，本来一开始讨论的是什么就不管了。转移话题也是可以的，但是个中关系应该讲清楚，从内存大到用户体验，中间涉及到一系列的为什么，这些就是应该说清楚的。&lt;/p&gt;

&lt;p&gt;还有程序员大都比较“机灵”，无论什么结论都能找出理由来。例如，有人在苹果东西卖的不好的时候会说它的产品多么好，而新产品无甚亮点的时候，又会说这种保守策略很正常，你看卖的不照样很好么？&lt;strong&gt;这种“争论”就很没意思，正过来反过去都是你说了算，所以我也很讨厌许多产品经理和分析师。&lt;/strong&gt;话说这方面还是Amazon好，其实我最喜欢的公司是Amazon，它真正推动了云服务产业，而且电子书和平板设备都在不断超越自己，还卖的那么便宜，还没那么多不理智的粉丝。有些争吵的影响力很大，大家转来转去的，而很多这样的争论在我看来都没啥价值，但有时候我也会控制不住。&lt;/p&gt;

&lt;p&gt;我不反感别人喷，但是我反感别人乱喷，我微博上也关注了一些喜欢喷的朋友，因为喷得有道理，不乱喷，我觉得挺不错的。&lt;strong&gt;我喜欢看别人吵架，但是这要建立在双方都能说出道理的前提下。&lt;/strong&gt;网络上大部分的吵架都无法让人吸取到营养。很多人吵架都是意气之争，一语不和，就开始争论，都是想赢，而不是关注问题。当然我也不赞同有些人说在争论技术的时候一定要心平气和，口不吐脏字，用最平和的方式来讨论。最重要的是逻辑一定要清晰。我在推Wind.js的时候一定会把适用场合说清楚，而不是一概而论说它哪都好。&lt;strong&gt;我不会为了推广自己的概念而忽悠人或者贬低别人。我只会说我认为正确的东西。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以我还真不适合当销售，完全就是个码农。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/10/interview-by-turing.html#comments</comments>
      <pubDate>Wed, 31 Oct 2012 23:02:10 GMT</pubDate>
      <lastBuildDate>Wed, 31 Oct 2012 23:16:32 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/parallel/">并行处理</category>
      <title>讨论：一则并行聚合计算方案的设计</title>
      <link>http://blog.zhaojie.me/2012/09/discussion-design-of-a-parallel-aggregation-case.html</link>
      <guid>http://blog.zhaojie.me/2012/09/discussion-design-of-a-parallel-aggregation-case.html</guid>
      <description>&lt;p&gt;最近的工作让我想到了一个对集合的元素进行并行聚合的案例，尽管这个需求还不存在，但最近却一直在我的脑海里挥之不去，尚未得出令人满意的结果。今天下班前我将这个问题辛苦地缩减为140字内的描述发到了微博上，得到了许多同学的回复，但可能是由于描述过于简单，得到的建议似乎都不能满足我的需求。于是在此我通过博客详细描述下这个问题的需求，还有我之前做过的尝试，这样讨论起来也可以更加有针对性一些。&lt;/p&gt;

&lt;h1&gt;问题描述&lt;/h1&gt;

&lt;p&gt;现有一个集合，最多包含100K个元素。每个元素包含100个字段，为了简化问题假设这些字段都为整型，因此我们完全可以把所有数据都加载到内存中。同时，我们定义两种修改操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;向集合中添加或删除一个元素。&lt;/li&gt;
&lt;li&gt;修改元素中某个属性的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们会有一个线程不断的将这两种修改操作运用到整个数据集中。修改是串行执行的，前一个操作完全执行结束才会开始下一个，但频率十分密集，例如每秒会产生数百甚至数千次修改，其中第2种修改的次数远多于第1种。&lt;/p&gt;

&lt;p&gt;我们需要对集合中的元素进行聚合运算，聚合规则不超过50个，每条规则都会给定一个名称及其计算方式，例如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SumOfA：对集合中所有元素的A字段的值求和，即&lt;code&gt;Sum(A)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;AvgOfB：对集合中所有元素的B字段的值求平均，即&lt;code&gt;Avg(B)&lt;/code&gt;，或&lt;code&gt;Sum(A) / Count(A)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;WtdAvgOfCD：对集合中所有元素的C字段和D字段做加权平均，D为权，即&lt;code&gt;Sum(C * D) / Sum(D)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除了对整个集合进行聚合之外，我们还会给出多个字段（不超过5个）用于分组，整个集合会被这些字段的不同值划分为不同的小集合，并需要将相同的聚合规则运用在每个小集合内，最终所有的聚合数据会完整展示在界面上，例如：&lt;/p&gt;

&lt;table border="1" cellpadding="5" cellspacing="0"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;A &lt;/th&gt;
&lt;th&gt; B &lt;/th&gt;
&lt;th&gt; C &lt;/th&gt;
&lt;th&gt; SumOfA &lt;/th&gt;
&lt;th&gt; AvgOfB &lt;/th&gt;
&lt;th&gt; WtdAvgOfCD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1 &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; 2 &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; 3 &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; 4 &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; 5 &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; 6 &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; 7 &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8 &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- &lt;/td&gt;
&lt;td&gt; 9 &lt;/td&gt;
&lt;td&gt; - &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;    &lt;/td&gt;
&lt;td&gt; &amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上表中使用A，B，C三个字段进行分组。由于恰好每行一个数字，这里便以这个数字作为行号了（最上方没有数字的那行则当做第0行）。这个表格可以视作是一个展开的树状结构，每个树状结构的节点包含每个聚合规则的名称及其结果。&lt;/p&gt;

&lt;p&gt;例如第0行，便是针对整个数据集的聚合结果，而第1行则是“字段A等于1”的所有元素的聚合结果。第2行从结构上看处于第1行的“内部”，因此它展示的其实是&lt;code&gt;A == 1 &amp;amp;&amp;amp; B == 2&lt;/code&gt;的所有元素的聚合结果。同理可得，第7行为&lt;code&gt;A == 1 &amp;amp;&amp;amp; B == 5 &amp;amp;&amp;amp; C == 7&lt;/code&gt;，而第9行为&lt;code&gt;A == 8 &amp;amp;&amp;amp; B == 9&lt;/code&gt;的所有元素的聚合结果。&lt;/p&gt;

&lt;p&gt;这张表格显然会无比巨大，在实际情况里我们只可能显示其中的一小部分数据，但是由于用户可以随意拖动滚动条，因此事实上所有的数据都希望可以立即显示出来，并且尽量实时地显示最新数据集的聚合结果。此外，也有一些（与本问题无关的）计算需要使用完整的聚合结果，因此我们希望在内存中存在完整的结果，而不是仅仅计算“显示出的那部分数据”。&lt;/p&gt;

&lt;p&gt;另外，实际情况下内存中可能存在多个这样的集合，集合中的元素可以共享，但每个集合都需要聚合（规则各不相同）。如果还有什么额外的条件的话，那么再假设“分组的字段”更新频率较小吧。&lt;/p&gt;

&lt;h1&gt;我的串行解决方法及并行尝试&lt;/h1&gt;

&lt;p&gt;由于实际情况下的数据量相对较小，我通过一个简单的串行的实现便可以满足性能要求。为此我实现了两个基础功能：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一个在添加和删除元素时可以得到通知的集合。&lt;/li&gt;
&lt;li&gt;在更新元素属性时，也可以得到元素本身，被更新的属性，以及更新前后的值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我在集合上运用聚合器，同时监听集合中每个元素的属性改变。聚合器内部保留中间状态，这样当新元素添加到集合中时，便可以利用新增或删除的元素做差值计算，由于属性修改时可以获得更新前后的值，因此差值计算同样可行。&lt;/p&gt;

&lt;p&gt;至于分组，其实就是利用一个额外的组件，将一个集合划分为多个子集合。例如我们要对A，B，C进行分组，则先根据A进行分组得到一堆子集合，每个子集合内的元素都拥有相同的字段A的值，然后为每个子集合分别运用聚合器，这便是满足如&lt;code&gt;A == 1&lt;/code&gt;的所有元素的聚合结果。分组器同样会监听集合以及集合中每个元素字段的改变，维护每个子集合内的元素。例如某个元素的字段A从1被修改为2时，分组器会将这个元素从子集合1移动到子集合2中，这会触发两个子集合的变化通知，从而触发这两个集合中的聚合器更新。至于更深一级的聚合结果，则会将相同的分组策略运用到每个子集合中，只不过这次针对下一级的分组字段（例如B）即可。不断深入，直到最后一层分组。&lt;/p&gt;

&lt;p&gt;这样无论是什么样的修改操作，每次修改完成之后都会立即更新聚合结果，且只会改动受影响的部分。但是随着数据量和更新频率的提高，我希望可以利用多核CPU来增加计算效率。这种并行运算会产生延迟，这并没有关系，只要尽量实时即可。有些同学提出在每次变动后并行计算结果，这个最容易，但实际上并不可行。因为数据随时都在更新，每次针对整个数据集进行计算会导致CPU久高不下，且并行计算的同时数据也在变动，因此计算过程中也会出现并发问题，甚至得到错误的结果。&lt;/p&gt;

&lt;p&gt;我目前的尝试是像Erlang那样，将每个聚合器作为一个Actor来对待。元素的改变会作为消息发送至聚合器，高一级聚合器又会发送消息给低一级的聚合器（这种消息传递并不一定是直接“转发”）。这种做法会让整个系统都是“热”的，且能够自然而然地进行并发，且单个聚合器可以保持串行。但是，随之而来的问题是，由于元素属性本身在不断更新，导致我们的“延迟计算”无法在处理消息时得到当时的值，这需要我们在发送消息时携带当前元素的“快照”，这样又会带来额外的开销。元素的添加删除操作倒也罢，但假如每次在字段更新时都要携带整个快照的话，这带来开销实在太高。不过似乎我们也只需要在“分组字段”改变时携带快照即可，因为只有那时才会引起聚合器的变动（这与之前元素在子集合之间移动的性质相同）。要知道分组字段改变次数相对会少很多，因此在大部分情况里我们只需要使用字段的更新前后的值即可。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;欢迎各位同学给出自己的设想，描述地越详细越好，如果能给出参考实现便再好不过了。假如您对需求或是限制还有什么不明白，也请立即提出，我可以作进一步解释或是更新文章。我也会继续尝试和探索，希望最后能给出一个完整的示例程序。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/09/discussion-design-of-a-parallel-aggregation-case.html#comments</comments>
      <pubDate>Wed, 05 Sep 2012 23:31:50 GMT</pubDate>
      <lastBuildDate>Thu, 06 Sep 2012 13:49:45 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/discussion/">思考讨论</category>
      <title>我看面试时出（纯）算法题</title>
      <link>http://blog.zhaojie.me/2012/08/my-opinion-of-algorithm-interview.html</link>
      <guid>http://blog.zhaojie.me/2012/08/my-opinion-of-algorithm-interview.html</guid>
      <description>&lt;p&gt;今天早上一边出门一边在平板上读了&lt;a href="http://weibo.com/haoel"&gt;左耳朵耗子&lt;/a&gt;的新文章《&lt;a href="http://coolshell.cn/articles/8138.html"&gt;为什么我反对纯算法面试题&lt;/a&gt;》，略有想法。正逢外面暴雨如注，我就又回屋打开笔记本发了一些回复，特此整理一下。为了避免有人扭曲我的看法，我先声明我并不是反对这篇文章，相反我是基本同意其中的观点，只不过会加以一些补充，把其中一些我认为有些过头的地方按一按。您也可以认为我的观点是提交一些补丁，发了一些Pull Request（当然不是&lt;a href="https://github.com/textmate/textmate/pull/37"&gt;这种Pull Request&lt;/a&gt;）就行了。我当时吐的第一个槽，是说文章太鄙视搞学术研究的人，说他们是书呆子，不关心业务需求，认为那是应试教育不会思考的产物。这个么其实不是重点，只不过触到了我的学术研究情结罢了，接下来的才是我真正想说的。&lt;/p&gt;

&lt;p&gt;耗子的文章以前两天的一个讨论引出话题，那是一道面试题：“找出无序数组的第2大的数”，而在当时的面试中，“排序”后再取数被判为不合格的答案。耗子认为其实在工程中“排序”才是更合适的做法，因为需求往往会变化，经过“需求分析”后更合理的决策应该是寻找“第K大的数”。我当时看到这题面试时就提出“寻找第K大的数”是一种过早优化，但耗子在新文章里的观点是，&lt;code&gt;FindKthMax(array, k)&lt;/code&gt;才是更常见的接口，而不会是&lt;code&gt;Find2ndMax&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;不过，即便是从“工程”角度来说，我还是认为“排序”是种不合适的做法，同时&lt;code&gt;FindKthMax(array, k)&lt;/code&gt;依然是种过早优化。既然提出了需求是取第2个数，其实我不太建议去考虑提前去实现取第K个数的需求，因为这太复杂了。例如，难道排序一次之后真可以反复取数？排序后反复取的前提是数组不变化，且这么做往往接口往往不是&lt;code&gt;FindKthMax(array, k)&lt;/code&gt;，而是&lt;code&gt;new ArrayFinder(array).Find(k)&lt;/code&gt;。还有，排序往往会改变数组本身元素顺序，那么是否允许？是否要做一份拷贝？要考虑这些实在太复杂了，其实既然目前的需求只是取第2个，这是个很有用的限制，两个变量一个循环可以让我们在3分钟里完成这个工作，那何必要做成通用的呢？&lt;/p&gt;

&lt;p&gt;此外，耗子认为是应试教育导致人们会选择O(n)的做法，而不是排序。我的感觉恰好相反，因为排序才是人人会接触过的事物，应试教育会让人对排序有深刻的印象。但是对我来说，我看到这题的第一反应就是“不能用排序”，因为这显然会产生不必要的开销。好吧，我不排除是“应试教育”让我能立即看清题目意图的可能性。&lt;/p&gt;

&lt;p&gt;换个角度来说，其实&lt;code&gt;Find2ndMax&lt;/code&gt;这种接口也并没有什么问题，尽管只解决了特例，但针对这个特例高效地完成任务，且没有副作用。大伙可以去看看.NET框架里的&lt;code&gt;String.Concat&lt;/code&gt;方法，它为2~4个字符串的连接操作各实现了一份重载，还提供了一个接受一个字符串数组的接口。由于大部分字符串的连接操作都在4个以内，因此单独为这些特例实现有针对性的实现，这在实际工程中并不罕见。&lt;/p&gt;

&lt;p&gt;我不反对纯面试算法，尤其是我认为一个简单的算法“你不会我就不能接受”的情况，这是个门槛。当然我也反对纯用很变态的面试算法来刷人，例如&lt;a href="http://weibo.com/wintercn"&gt;winter&lt;/a&gt;被面试过的“Winner树”以及传说中的“大草原”。此外，谁说纯算法不符合实际需求的啊？算法根据输入参数的大小变化选取不同策略这个太多了，纯算法没说在割离工程。更进一步地说，算法题也不代表只有标准答案才是正确的，算法题只是表现形式，考得也是解题思路，并非只有“最优解”才算过关，次优解以及沟通的过程都是在考察面试者。就如winter当年并不知道“Winner树”，但通过发现题目中缺少的一个限制条件，使用取哈希值的方法给出了满足要求的解决方案，这也体现出了强大的应变能力，这对于“工程”来说也至关重要。&lt;/p&gt;

&lt;p&gt;有问题的不是算法题，只不过是面试官或是面试方式而已。&lt;/p&gt;

&lt;p&gt;再顺便谈下ACM，因为我预感有人会借此鄙视ACM。其实按照耗子在文章里的标准，ACM绝对属于很工程的环境。因为你要在掌握算法的基础上，快速理解需求，建模，根据数据量选择合适的做法，符合题目的时间限制和空间限制快速解决问题。此时能够快速暴力枚举的就不用高级解法，甚至预先思考准备两种做法，一种无法通过立即换上第二种。更何况还是绝对在高压环境下，与所谓的“工程环境”十分相符。&lt;/p&gt;

&lt;p&gt;当然，ACM也并非没有与工程中相违背的地方，例如不重视代码的可维护性，还有输入数据的边界条件等等。这顺便可以引出一个可以写入“面试宝典”的面试经验：拿到问题后确认每一个输入的细节，例如现在这题是2呢还是k，还有例如是不是会小于零等等。很多面试官其实也是在考察面试者对于边界条件的关注程度，问清楚这些有利于提升自己的形象，给自己争取思考的时间，几乎有百利而无一害。&lt;/p&gt;

&lt;p&gt;除非你遇到了极品面试官，这就是另外一回事情了。&lt;/p&gt;

&lt;p&gt;再除非你是美女，这就又是另外一回事情了。&lt;/p&gt;

&lt;p&gt;话说男人真是没出息的动物，看到美女就围着团团转流口水。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/08/my-opinion-of-algorithm-interview.html#comments</comments>
      <pubDate>Wed, 22 Aug 2012 19:55:11 GMT</pubDate>
      <lastBuildDate>Wed, 22 Aug 2012 22:08:56 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/discussion/">思考讨论</category>
      <title>由eval生成的代码效率真的很差吗？</title>
      <link>http://blog.zhaojie.me/2012/08/js-code-from-eval-benchmark.html</link>
      <guid>http://blog.zhaojie.me/2012/08/js-code-from-eval-benchmark.html</guid>
      <description>&lt;p&gt;昨晚跟一位Node.js专家讲解了我的Wind.js类库。之前那位仁兄对Jscex（Wind.js的前身）的看法是“就是不喜欢”，也在微博上对Jscex冷嘲热讽，于是我私信他说建议看一下文档了解一下Jscex。昨天我们的争论主要围绕在&lt;code&gt;eval&lt;/code&gt;的使用上，他认为更好的做法是像&lt;a href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt;那样使用一个额外的进程监听改变，这样更方便。我说CoffeeScript这么做是因为它没有像Wind.js那样借助&lt;code&gt;eval&lt;/code&gt;实现完全动态的运行时转化，且生产环境中不会出现&lt;code&gt;eval&lt;/code&gt;。最后他坚持认为“&lt;code&gt;eval&lt;/code&gt;就是有性能问题”，因此开发时也不应该使用，否则Wind.js为什么要提供预编译器？虽然最后不欢而散，不过我忽然也打算验证一下&lt;code&gt;eval&lt;/code&gt;生成的代码效率到底会差到什么样的地步，于是便有了这次试验。&lt;/p&gt;

&lt;h1&gt;测试代码&lt;/h1&gt;

&lt;p&gt;有人可能会问，&lt;code&gt;eval&lt;/code&gt;每次动态的执行代码时需要重新分析代码，还不能进行优化，为什么会“不慢”？不过请注意，这里测试的目标不是用&lt;code&gt;eval&lt;/code&gt;执行代码慢不慢，而是反复执行通过&lt;code&gt;eval&lt;/code&gt;生成的代码，因为这才是Wind.js对&lt;code&gt;eval&lt;/code&gt;的使用方式。Wind.js中每次eval将会生成一个函数，然后在使用的过程中不会反复&lt;code&gt;eval&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;既然是测试纯性能，我就找了个纯粹用来计算的函数：&lt;a href="http://en.wikipedia.org/wiki/Linear_congruential_generator"&gt;LCG随机数生成器&lt;/a&gt;。这个随机数生成器实现简单，效率极高，因此运用十分广泛。这里我们不关心它的原理，只给出它的JavaScript实现：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;nativeRandomLCG = &lt;span style="color: blue"&gt;function &lt;/span&gt;(seed) {
    &lt;span style="color: blue"&gt;return function &lt;/span&gt;() {
        seed = (214013 * seed + 2531011) % 0x100000000;
        &lt;span style="color: blue"&gt;return &lt;/span&gt;seed * (1.0 / 4294967296.0);
    };
};

&lt;span style="color: blue"&gt;var &lt;/span&gt;evalRandomLCG = &lt;span style="color: blue"&gt;function &lt;/span&gt;(seed) {
    &lt;span style="color: blue"&gt;var &lt;/span&gt;randomLCG = eval(&lt;span style="color: maroon"&gt;&amp;quot;(&amp;quot; &lt;/span&gt;+ nativeRandomLCG.toString() + &lt;span style="color: maroon"&gt;&amp;quot;)&amp;quot;&lt;/span&gt;);
    &lt;span style="color: blue"&gt;return &lt;/span&gt;randomLCG(seed);
};&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;nativeRandomLCG&lt;/code&gt;将通过&lt;code&gt;seed&lt;/code&gt;生成一个随机数生成器，而&lt;code&gt;evalRandomLCG&lt;/code&gt;则会将前者的代码作为字符串取出，并在&lt;code&gt;eval&lt;/code&gt;后重新获得随机数生成器。我们的评测对象便是这两个生成器：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;nativeSuite = {
    name: &lt;span style="color: maroon"&gt;&amp;quot;native&amp;quot;&lt;/span&gt;,
    target: nativeRandomLCG(100)
};

&lt;span style="color: blue"&gt;var &lt;/span&gt;evalSuite = {
    name: &lt;span style="color: maroon"&gt;&amp;quot;eval&amp;quot;&lt;/span&gt;,
    target: evalRandomLCG(100)
};

&lt;span style="color: blue"&gt;var &lt;/span&gt;iterations = [100, 200, 300];

&lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;round = 0; round &amp;lt; iterations.length; round++) {
    console.log(&lt;span style="color: maroon"&gt;&amp;quot;Round &amp;quot; &lt;/span&gt;+ round);
    test(iterations[round] * 1000 * 1000, nativeSuite, evalSuite);
    console.log(&lt;span style="color: maroon"&gt;&amp;quot;&amp;quot;&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;我将进行三轮测试，分别生成100M，200M及300M个随机数，并观察两个随机数生成器的耗时。&lt;a href="https://github.com/JeffreyZhao/benchmark/tree/master/js-code-from-eval"&gt;完整代码可以在此获得&lt;/a&gt;，其中lcg.js可以直接作为Node.js程序运行，而lcg.html则可以在浏览器里打开，点击页面上的按钮启动计算，测试结果会在控制台里输出。&lt;/p&gt;

&lt;p&gt;由于Node.js可以在不同平台上使用，而Windows和OSX又各有一个不跨平台的浏览器，因此我会在两个平台上分别对Node.js和主流浏览器进行测试。为了避免Firefox出现“脚本执行时间过长，是否中止”这样的提示，还需要&lt;a href="http://support.mozilla.org/en-US/kb/warning-unresponsive-script"&gt;对其进行简单的设置&lt;/a&gt;。&lt;/p&gt;

&lt;h1&gt;Windows实验结果&lt;/h1&gt;

&lt;p&gt;Windows上的实验使用的是我工作时所使用的ThinkPad 520，操作系统为Windows 7，CPU信息如下：&lt;/p&gt;

&lt;p&gt;&lt;img alt="ThinkPad 520 CPU" src="http://img.zhaojie.me/blog/js-code-from-eval-benchmark/win-cpu.png" /&gt;&lt;/p&gt;

&lt;p&gt;四个JavaScript执行环境为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Node.js 0.8.6 &lt;/li&gt;

  &lt;li&gt;IE 9 &lt;/li&gt;

  &lt;li&gt;Chrome 21 &lt;/li&gt;

  &lt;li&gt;Firefox 14 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实验结果：&lt;/p&gt;
&lt;iframe width="535" height="170" frameborder="0" scrolling="no" src="https://r.office.microsoft.com/r/rlidExcelEmbed?su=-314050802145437870&amp;Fi=SDFBA4447598B1D752!3913&amp;ak=t%3d0%26s%3d0%26v%3d!ALaYj4wk0Hx43AM&amp;kip=1&amp;wdAllowInteractivity=False&amp;Item=Win!A1%3AE7"&gt;&lt;/iframe&gt;

&lt;p&gt;图表：&lt;/p&gt;
&lt;iframe height="372" src="https://r.office.microsoft.com/r/rlidExcelEmbed?su=-314050802145437870&amp;amp;Fi=SDFBA4447598B1D752!3913&amp;amp;ak=t%3d0%26s%3d0%26v%3d!ALaYj4wk0Hx43AM&amp;amp;kip=1&amp;amp;wdAllowInteractivity=False&amp;amp;Item=Chart%202" frameborder="0" width="562" scrolling="no"&gt;&lt;/iframe&gt;

&lt;p&gt;从中我们可以清晰地得出：&lt;/p&gt;

&lt;p&gt;对于Node.js来说，使用&lt;code&gt;eval&lt;/code&gt;得到的函数，其执行效率和JavaScript直接定义的函数可谓毫无二至。事实上，除了IE似乎&lt;code&gt;eval&lt;/code&gt;普遍稍慢于原生函数外，其他引擎里的表现都可谓基本持平，连IE的落后也基本可以忽略不计。所以，“&lt;code&gt;eval&lt;/code&gt;出来的代码效率会有很大差距”这种说法，至少在这个实验中丝毫没有体现出来。&lt;/p&gt;

&lt;p&gt;有意思的是，在Chrome中还发生了这么一件事情：在第一轮比较中，原生定义的函数有较大的性能优势，而且自从测试了&lt;code&gt;eval&lt;/code&gt;得到的函数之后，后面两轮连原生函数的效率都下降了。这会不会是因为&lt;code&gt;eval&lt;/code&gt;让整个执行引擎大打折扣了呢？严谨起见，我又测试了三种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两个测试用例都使用原生函数。 &lt;/li&gt;

  &lt;li&gt;&lt;code&gt;eval&lt;/code&gt;得到的函数先于原生函数前执行。 &lt;/li&gt;

  &lt;li&gt;两个测试都使用&lt;code&gt;eval&lt;/code&gt;得到的函数。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;都得到了类似的结果：先执行的函数效率会高出许多。我猜测这是因为Chrome发现了大量的密集计算，为了保证界面的响应能力，将JavaScript执行的优先级降低的缘故。值得一提的是，尽管Chrome的“降速”后的结果略慢于IE和Firefox，但它是唯一一个在性能测试的时候，整个界面还没有失去响应的浏览器。此时我可以切换到其他Tab，也可以关闭这张页面——甚至控制台里输出的文字也是立即出现的，而其他两个浏览器都必须等整段程序执行完成之后所有输出才同时出现。&lt;/p&gt;

&lt;p&gt;必须承认，Chrome浏览器在这方面的确可圈可点。&lt;/p&gt;

&lt;h1&gt;OSX实验结果&lt;/h1&gt;

&lt;p&gt;OSX上的实验使用的是一台高配的MBP with Retina Display，操作系统为最新的OSX Mountain Lion，CPU信息如下：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/js-code-from-eval-benchmark/osx-cpu.png" width="437" /&gt;&lt;/p&gt;

&lt;p&gt;四个JavaScript执行环境为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Node.js 0.8.0 &lt;/li&gt;

  &lt;li&gt;Safari 6 &lt;/li&gt;

  &lt;li&gt;Chrome 21 &lt;/li&gt;

  &lt;li&gt;Firefox 14 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实验结果：&lt;/p&gt;
&lt;iframe height="170" src="https://r.office.microsoft.com/r/rlidExcelEmbed?su=-314050802145437870&amp;amp;Fi=SDFBA4447598B1D752!3913&amp;amp;ak=t%3d0%26s%3d0%26v%3d!ALaYj4wk0Hx43AM&amp;amp;kip=1&amp;amp;wdAllowInteractivity=False&amp;amp;Item=OSX!A1%3AE7" frameborder="0" width="535" scrolling="no"&gt;&lt;/iframe&gt;

&lt;p&gt;图表：&lt;/p&gt;
&lt;iframe height="367" src="https://r.office.microsoft.com/r/rlidExcelEmbed?su=-314050802145437870&amp;amp;Fi=SDFBA4447598B1D752!3913&amp;amp;ak=t%3d0%26s%3d0%26v%3d!ALaYj4wk0Hx43AM&amp;amp;kip=1&amp;amp;wdAllowInteractivity=False&amp;amp;Item=Chart%201" frameborder="0" width="564" scrolling="no"&gt;&lt;/iframe&gt;

&lt;p&gt;由于结论十分类似，我就不多做分析了。不过有意思的是，不知为何Safari浏览器的性能极低，我一开始使用相同规模的实验数据，发现Safari迟迟不返回结果，直到我将生成随机数的数量降低到十分之一时，才得到Safari如今的耗时。因此请注意这里的Safari附带的x0.1字样，正是指它实验数据的规模仅仅为其他JavaScript执行引擎的十分之一。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;eval&lt;/code&gt;本身的执行无疑会慢，因为它需要动态的分析那段字符串的内容才能执行，且单次执行为它进行优化可能也得不偿失。但是，像Wind.js那样将&lt;code&gt;eval&lt;/code&gt;的结果反复执行，并非反复执行&lt;code&gt;eval&lt;/code&gt;本身，这可能就是另外一回事情了。&lt;code&gt;eval&lt;/code&gt;最终还是得到一段代码，而这段代码在反复执行过程中可能也会被JIT，也会被优化。&lt;/p&gt;

&lt;p&gt;我不能说我设计的这个简单案例就能说明一切，但是至少通过这个我立即就想到的首个测试用例，能够说明&lt;code&gt;eval&lt;/code&gt;的某些使用方式可能并不想许多人幻想中对性能会产生多大的影响。而且对于Wind.js这种异步类库来说，程序几乎都是在等待异步任务完成，代码层面的性能基本不会造成任何影响。如果你实在害怕&lt;code&gt;eval&lt;/code&gt;，完全可以在生产环境中通过预编译消除所有的&lt;code&gt;eval&lt;/code&gt;。这里的预编译并不是为了性能，而是让代码可以脱离体积最大的编译器模块运行，剩下的部分在Minified和GZipped之后只有4K大小。&lt;/p&gt;

&lt;p&gt;如果你非要如那位Node.js专家说“&lt;code&gt;eval&lt;/code&gt;就是慢”，那我只能这么说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Wind.js中使用&lt;code&gt;eval&lt;/code&gt;不会产生什么性能问题，我觉得排斥的人有三种情况：不熟悉eval，不熟悉是不了解Wind.js，找茬。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在微博上说了上面这句话之后，却得到那位专家这样的回应：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;看來，不喜歡Wind.js的人要麼是不懂，要麼是故意找茬了。Wind.js是不容置疑的。//@老赵 :我觉得排斥的人有三种情况：不熟悉eval，不熟悉Wind.js，找茬……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我顿时觉得很生气，说道：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;身为有头有脸的专家不要断章取义，我说的是排斥“Wind.js里使用eval”。你可以不喜欢Wind.js，但是要说出靠谱的理由。上次你也跑上来黑一票Wind.js就走，真枉我买过你的书。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结果却得到对方“义正词严”的批评：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;還是請您就事論事，不要人身攻擊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;真令人好生疑惑，我这就算是人身攻击？哪里没有就事论事？是谁在断章取义，搞低级黑？&lt;/p&gt;

&lt;p&gt;那攻击就攻击吧，反正我已经很失望了。&lt;/p&gt;

&lt;p&gt;注：&lt;a href="http://www.otakustay.com/eval-performance-profile/"&gt;也有实验显示&lt;/a&gt;，&lt;code&gt;eval&lt;/code&gt;对性能的影响，并非要用过&lt;code&gt;eval&lt;/code&gt;执行，或是执行&lt;code&gt;eval&lt;/code&gt;出的代码才能体现出来，而&lt;code&gt;eval&lt;/code&gt;某些存在方式也会让JavaScript引擎降低对其他代码的优化程度。因此，Wind.js中的&lt;code&gt;eval&lt;/code&gt;到底产生多大影响也需要做进一步探明。接下来我也会在&lt;a href="http://windjs.org/"&gt;Wind.js官方网站&lt;/a&gt;上发布一些更针对Wind.js中&lt;code&gt;eval&lt;/code&gt;使用方式的性能测试报告。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/08/js-code-from-eval-benchmark.html#comments</comments>
      <pubDate>Wed, 15 Aug 2012 21:29:33 GMT</pubDate>
      <lastBuildDate>Thu, 16 Aug 2012 13:44:27 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/discussion/">思考讨论</category>
      <title>我对“语言之争”的看法：别随便拉我入场</title>
      <link>http://blog.zhaojie.me/2012/08/programming-languages-arguments-dont-pull-me-in.html</link>
      <guid>http://blog.zhaojie.me/2012/08/programming-languages-arguments-dont-pull-me-in.html</guid>
      <description>&lt;p&gt;最近又有语言之争了，不过没我什么事情。事情起因可以在&lt;a href="http://coolshell.cn/articles/7992.html"&gt;酷壳&lt;/a&gt;最新一篇文章里看到，简单地说是关于C++的复杂度问题的。我对文章内容其实没有什么看法，但对这句话深有感触：“我对C++的感情有三个过程，先是喜欢地要死，然后是恨地要死，现在的又爱又恨，爱的是这个语言，恨的是很多不合格的人在滥用和凌辱它。”，我以为我想说，这“现在”的状态，就是我对“语言之争”的看法，“语言之争”被太多不合格人凌辱了。&lt;/p&gt;

&lt;p&gt;我很喜欢编程语言，但我争论语言时有着基本的原则和必备的知识，没有这些在我看来就不应该参与讨论。讨论时我也会严格控制范围，因此我基本不会使用类比，因为类比其实就是在用外部知识来理解当前的话题，很容易把话题扯开出去。同理，我也不会像高级分析师们讲一些初级程序员们都懂——但往往我不怎么理解或赞同的大道理。我就是怎么没出息，就像今天早上还有人在IM上对我说“老赵怎么可能还在写程序，你是冒牌的吧？”。&lt;/p&gt;

&lt;p&gt;有一种观点是解决问题比选择工具重要，这是个可行的立论，但不是唯一的。语言本身也是问题，有积累，有知识，当然也有某些同学说的训练编程思维等等。争论语言时我看到说“语言只是工具”所以“没什么可谈的”就烦，“编程语言”似乎已经变成“经济”或“政治”这样的话题了，随便谁都觉得自己有能力参与讨论。有意思的是，许多人的论点居然是“无意义”。&lt;/p&gt;

&lt;p&gt;编程语言是一门课，一门学科，不是什么人人都自然懂自然会的东西。我说过很多次，假如你觉得自己不知道该如何提高了，不知道学什么，就去翻教科书，那里东西多得你学不完。很多东西都是有定义的有概念的，不要我说编程语言安全性的时候，就有人跑出来说安全性什么和语言无关，去你妹的。&lt;/p&gt;

&lt;p&gt;假如您不知道这方面有哪些内容可以参考，我这里倒也可以推荐两本书，一本是《&lt;a href="http://www.amazon.com/Programming-Language-Pragmatics-Third-Edition/dp/0123745144/"&gt;Programming Language Pragmatics&lt;/a&gt;》，还有一本是《&lt;a href="http://www.amazon.com/Concepts-Programming-Languages-10th-Edition/dp/0131395319/"&gt;Concepts of Programming Languages&lt;/a&gt;》。这两本书国内都引进了影印版，也有对应的中译本，分别叫做《&lt;a href="http://book.douban.com/subject/10802357/"&gt;程序设计语言——实践之路&lt;/a&gt;》和《&lt;a href="http://book.douban.com/subject/2126664/"&gt;程序设计语言原理&lt;/a&gt;》。两本书我都可以算是看过，虽然并没有完整地仔细阅读。&lt;/p&gt;

&lt;p&gt;所以以后有语言争论不要轻易拉我入场，我和你的语言争论很可能不是一码事情。同理，也别用你的争论是多么没意义来证明我的争论有没有意义。现在随便来一个人就会冲上来讲些大道理或者发表自己见解，当然你可以这么做，我也觉得没意义。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/08/programming-languages-arguments-dont-pull-me-in.html#comments</comments>
      <pubDate>Mon, 06 Aug 2012 13:11:49 GMT</pubDate>
      <lastBuildDate>Mon, 06 Aug 2012 13:50:38 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/essential/">重中之重</category>
      <category domain="http://blog.zhaojie.me/reading/">阅读相关</category>
      <title>写给《程序员》杂志社：那些你们早该知道的东西</title>
      <link>http://blog.zhaojie.me/2012/07/to-programmer-magazine-something-you-should-have-known-for-a-long-time.html</link>
      <guid>http://blog.zhaojie.me/2012/07/to-programmer-magazine-something-you-should-have-known-for-a-long-time.html</guid>
      <description>&lt;h1&gt;缘起&lt;/h1&gt;

&lt;p&gt;最近我写了一篇文章投给《程序员》杂志社，“开源”专题。我写的是关于&lt;a href="http://jscex.info/"&gt;Jscex&lt;/a&gt;的内容，自然十分用心，再加上看了不少之前编辑让我提些意见建议的文章，因此我对于这期的内容还是很有信心的。我是一个对文章阅读体验有极高要求的人，无论是作为&lt;a href="http://blog.zhaojie.me/2010/08/get-a-better-style-for-reading.html"&gt;文章的读者&lt;/a&gt;还是&lt;a href="http://blog.zhaojie.me/2010/08/my-view-of-good-blogging-theme.html"&gt;文章的作者&lt;/a&gt;，也经常对各种样式混乱的博客表示不满。我也算是《程序员》的长期读者，知道它在代码展示方面有很多不足之处，之前也时常向相关人等（例如&lt;a href="http://weibo.com/turingbook"&gt;刘江总编&lt;/a&gt;）提出不少建议。这次既然涉及到我的文章，我自然会加倍小心，千叮咛万嘱咐，也主动配合编辑的工作。我反复的询问编辑对于代码提交方式的需求，对方说要提供代码的截图，最好需要着色。于是我为每一幅代码都提供了&lt;a title="高清代码截图" href="http://img.zhaojie.me/blog/to-prog-magazine/code-2.png" target="_top" data-popup="image"&gt;高清的截图&lt;/a&gt;。有多高清？在Retina屏幕的帮助下，图片像素高达3360x2100，当时我还在微博上笑谈到“这次总不会模糊了吧”。保险起见，我还为每一段代码增加了&lt;a title="矢量PDF格式" href="http://img.zhaojie.me/blog/to-prog-magazine/code-2.pdf"&gt;PDF矢量格式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;令人遗憾的是，在编辑发给我的PDF中这段代码是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/1.png" /&gt;&lt;/p&gt;

&lt;p&gt;我顿时就愤怒了。清晰度先姑且不谈，编辑说是因为这是压缩后的PDF，实际印刷出来会很清晰。但是，代码为什么会变成这样？我的高清截图哪儿去了？即使由于种种原因这种截图无法使用，那么矢量的PDF呢？我并不是心疼我花在准备代码上的时间，我心疼的是整篇文章的阅读体验。假如我看到一篇这样的文章，我基本就会随手丢在一旁，糟糕的阅读体验会让我没有心情关注内容。在我看来，我的文章就这么被毁了。&lt;/p&gt;

&lt;p&gt;即便编辑对此表示歉意，但于事无补。同时我发现《程序员》杂志社从编辑到排版人员，居然会不了解一些已经被广为接受的知识，甚至可以说是“常识”。为了让今后的文章可以“免遭毒手”，我当时立刻表示要为《程序员》杂志社单独写一篇文章补补课。编辑和排版人员不能因为“不写代码”而忽视这些基础内容，因为这对你们来说就是所谓的“行业”或者说“领域”知识。就好比我现在是金融行业的程序员，就不能因为我“只是个写代码的”而对基础金融常识视而不见。&lt;/p&gt;

&lt;p&gt;没有这么多理由。&lt;/p&gt;

&lt;h1&gt;代码样式&lt;/h1&gt;

&lt;p&gt;上面这段代码犯了一个最最基本的错误：使用了“非等宽字体”。例如，您能看出上面这段代码使用了几个作为缩进？有人说是4.5格，这估计是看着第一个缩进数出来的，您不妨再数下&lt;code&gt;if (compare(&lt;/code&gt;与上一行代码相差了几个字符。这就是因为在非等宽字体里，不同的字符是不同的宽度，空格就显得特别窄，而小写l和大写W的宽度会差好几倍。但是在等宽字体中，无论是什么字符都是相同宽度，例如&lt;code&gt;World&lt;/code&gt;的五个字符。代码排版一定要使用“等宽字体”，也就是每个字符都是相同的宽度，这样代码才能显得优雅整洁，对齐良好。&lt;/p&gt;

&lt;p&gt;例如我博客上的代码都优先使用Windows自带的Consolas字体：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/2.png" width="409" /&gt;&lt;/p&gt;

&lt;p&gt;或是Mac自带的Monaco字体：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/3.png" width="466" /&gt;&lt;/p&gt;

&lt;p&gt;不过等宽字体只是必要条件，还不够充分，例如Courier New是一种等宽字体，但并不适合用于编写代码。请看这个表达式：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/4.png" width="120" /&gt;&lt;/p&gt;

&lt;p&gt;假如您的答案是1234，则说明您落入了Courier New的陷阱。这里第二个数字并非11111，而是一个长整型的1111，因为它最后一个字母是小写字母L，而不是数字1。但是换作是Consolas就会一清二楚：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/5.png" width="105" /&gt;&lt;/p&gt;

&lt;p&gt;Monaco也有明显区别：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/6.png" width="120" /&gt;&lt;/p&gt;

&lt;p&gt;同样需要区分的还有数字0和大写字母O等等，这点对于非等宽字体来说反而不是问题，但在选择等宽字体时就需要注意区分度，让人可以一眼看清究竟是什么样的代码。适合用于编写程序的字体有很多，&lt;a href="http://hivelogic.com/articles/top-10-programming-fonts/"&gt;而且几乎都是现成的&lt;/a&gt;，我们完全不需要自行挖掘。&lt;/p&gt;

&lt;p&gt;代码样式虽然简单，但往往就是是否专业的分水岭。不管你是多么优秀的程序员，一旦使用了非等宽字体编写代码，我就会认为你至少在这个方面显得不专业。当然，你可以说是你的个人习惯，我也会尊重你的选择，因为这只会影响你一个人。但是，作为一个出版社，一个媒体，是要将一段代码展现给千万大众阅读的，如果还使用非等宽字体就是一种罪过了。其实《程序员》杂志之前的代码也至少会使用等宽字体，不知道为什么这次就这么堕落了，还堕落在我这个极其重视阅读体验的人头上。&lt;/p&gt;

&lt;h1&gt;文档格式&lt;/h1&gt;

&lt;p&gt;我不知道《程序员》内部使用什么格式提交文本，就我感觉来说他们十分喜欢Word，我拿到的所有的文档都是Word格式的。我这次提交了Markdown格式及其导出的HTML文件，编辑的反馈居然是“排版人员不知道如何使用”，最后的文章也完全丢失了所有的内嵌代码格式。好吧，那么我们就一点点来说。&lt;/p&gt;

&lt;p&gt;对于一篇文章来说，Word其实很不利于排版。因为Word自带大量样式，这些显然不能直接使用。而且，并非所有人都会使用Word进行排版，因此我们经常能看到一些格式混乱的Word文档。有经验的同学会使用Word的“大纲视图”来编写代码，最终设定各个节点的格式，一篇文章的布局就搞定了，完全不需要手动设置每一行每一段。&lt;/p&gt;

&lt;p&gt;从这个方面来说，其实HTML是个很好的格式，排版人员应该很容易使用才对。HTML文档本身其实不包括任何样式，样式都是由CSS决定的。HTML节点都有各自的“语义”，例如用&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;到&lt;code&gt;&amp;lt;h6&amp;gt;&amp;lt;/h6&amp;gt;&lt;/code&gt;来表示标题，&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;来表示自然段落，&lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt;来表示代码，&lt;code&gt;&amp;lt;ol&amp;gt;&amp;lt;/ol&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;&lt;/code&gt;来表示有序或无需的列表，一篇使用HTML提交的文章，其文档的结构已经一清二楚，剩下的只是如何表示每个元素的问题。&lt;/p&gt;

&lt;p&gt;但是“HTML标签”终究不太适合直接用来编写文档，因为人们需要花额外的精力来表达文档结构，而并非全身心投入到文档内容里。如果使用一些所见即所得的工具来编写HTML，又容易出现样式混乱的情况。我目前见过的最好的，最干净，最不容易产生混乱代码的HTML所见即所得编辑器便是Windows Live Writer，这这可能是因为它的目标是为了编写博客这样的文章内容，因此只提供了相当有限的样式设置功能，并能自动清理混乱的HTML代码。这其实也是我们写技术文章的要求：结构清楚，不需要复杂的样式。所以，我其实很推荐各位使用Windows Live Writer来编写文章——假如不那么“技术”的话。&lt;/p&gt;

&lt;p&gt;对于技术人员来说，或者文章中涉及大量代码，可能更好的选择是&lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown格式&lt;/a&gt;。Markdown是专为程序员打造的文档格式，它的特点是容易编写，容易阅读。使用Markdown我们可以很轻易地表达出文档的各种结构，例如段落，列表，甚至代码：&lt;/p&gt;

&lt;pre class="code"&gt;# 一级标题

## 二级标题

段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一段落一。

段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二段落二。

    // 缩进四格即是代码    
    var compareAsync = function (x, y, callback) {
        setTimeout(function () {
            callback(x - y);
        }, 50)
    }

还可以引用：

&amp;gt; 引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一引用一
&amp;gt;
&amp;gt; 引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二引用二

以及列表：

1. 有序列表项1
2. 有序列表项2
3. 缩进四格还可以嵌套
    * 无序列表项1
    * 无序列表项2&lt;/pre&gt;

&lt;p&gt;使用Markdown格式一般是为了生成HTML（它还支持内嵌HTML代码），因此例如上面的内容会自动生成&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;blockquote&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;ol&amp;gt;&amp;lt;/o&amp;gt;&lt;/code&gt;及&lt;code&gt;&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;&lt;/code&gt;等元素，但是从编写上来说Markdown格式无疑更为方便。同时，Markdown格式可以使用普通的文本编辑器打开，并直接阅读，基本没有障碍。正因为这些好处，Markdown格式已经在编程领域运用地越来越广泛，例如&lt;a href="http://stackoverflow.com/"&gt;StackOverflow&lt;/a&gt;的回复，自然也有我的博客回复等等。我建议，假如您认为自己是一个专业程序员，就尽快掌握Markdown格式吧。&lt;/p&gt;

&lt;p&gt;值得一提地是，Markdown还支持在段落内方便地嵌入代码：&lt;/p&gt;

&lt;pre class="code"&gt;Step类库提供了一个`Step`函数。&lt;/pre&gt;

&lt;p&gt;它生成的HTML代码会自动为第二个Step用上&lt;code&gt;&amp;lt;code&amp;gt;&amp;lt;/code&amp;gt;&lt;/code&gt;标签，因此样式也会有所不同，例如在我的博客上：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/to-prog-magazine/7.png" width="215" /&gt;&lt;/p&gt;

&lt;p&gt;还记得代码的基本规则吗？没错，便是“等宽字体”。文章的内嵌代码也是代码，也要使用等宽字体。遗憾地是，尽管我不断向编辑强调这一点，尽管我提供的Markdown格式和HTML里面都体现了普通文本和内嵌代码的区别，最终《程序员》杂志还是不加分辨地进行排版。&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;虽然这篇文章是因《程序员》而起，也是特地写给《程序员》的编辑和排版人员的，但是这种业余的排版风格并非他们一家的专利。例如“电子工业出版社”的《&lt;a href="http://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=32783"&gt;HTML 5实验室：Canvas世界&lt;/a&gt;》一书，其中所有的代码排版也是混乱不堪，此外我也不提这不知道是“太太乐鸡精”还是“香飘飘奶茶”风格的封面了。尽管书中写了不少Jscex的内容，我还是实在不好意思向别人推荐这本书，因为看上去实在是太山寨了。&lt;/p&gt;

&lt;p&gt;说实话我很难想象，国内的出版媒体会堕落到这种地步，经历了那么多年，连一些基本的要求都做不好。其实这并不仅仅是出版社的问题，读者和作者也有一定的责任，为什么那么多年来就没人指出？为什么作者不讲究点“品味”不爱惜自己的辛勤成果？到底怎样才能让我们的媒体变得专业？我不知道，但至少从现在开始，我会努力盯住我所看得到的地方。《程序员》杂志自然是一个，希望你们不会让我失望。&lt;/p&gt;

&lt;p&gt;不对，是“继续”失望。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/07/to-programmer-magazine-something-you-should-have-known-for-a-long-time.html#comments</comments>
      <pubDate>Mon, 30 Jul 2012 01:42:53 GMT</pubDate>
      <lastBuildDate>Mon, 30 Jul 2012 19:10:06 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <title>专访Jscex作者老赵（上）：缘由、思路及发展</title>
      <link>http://blog.zhaojie.me/2012/07/infoq-interview-jscex-author-1.html</link>
      <guid>http://blog.zhaojie.me/2012/07/infoq-interview-jscex-author-1.html</guid>
      <description>&lt;h1&gt;引言&lt;/h1&gt;

&lt;p&gt;&lt;a title="Jscex Website" href="http://jscex.info/zh-cn/"&gt;Jscex&lt;/a&gt;是很有特点的一个JavaScript异步编程类库，最近作者不但发布了其眼中的里程碑版（v0.6.5），还在“&lt;a href="http://ouropensource.51qiangzuo.com/"&gt;我们的开源项目&lt;/a&gt;”系列活动和&lt;a href="http://adc.taobao.com/carnival/"&gt;阿里技术嘉年华&lt;/a&gt;上连续露脸，获得广泛关注。Jscex的作者&lt;a href="http://blog.zhaojie.me/"&gt;赵劼&lt;/a&gt;就在本站担任编辑，InfoQ自然抓住机会对老赵做了正式的书面采访。采访篇幅较长，将分上下集播出。老赵将在上篇中借机倾述他对于库设计的思考和心得。&lt;/p&gt;

&lt;p&gt;注：&lt;a href="http://www.infoq.com/cn/articles/interview-jscex-author-part-1"&gt;本文首发于InfoQ&lt;/a&gt;，出于阅读体验等方面考虑，现在重新发于博客。&lt;/p&gt;

&lt;h1&gt;采访&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Q：能否先介绍一下你自己？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大家好，我是赵劼，在网上一般叫做老赵或者赵姐夫，经常沉迷于代码世界里，关注技术发展或是程序员的成长等话题，而不太愿意接触如今比较“流行”的产品设计，项目管理，产业分析等等，连所谓的“大规模应用架构设计”都不太关心——甚至还略有抵触，所以我可以说是个纯码农。之前呆过外企，呆过民企，创过业，也呆过国内的互联网企业，现在则是在做外资银行的内部系统，可以说是一块没有接触过的领域，痛并快乐着。&lt;/p&gt;

&lt;p&gt;在工作之余，我也会十分热衷于在业余时间编写自己的开源?作品，其中Jscex便是迄今为止我最为投入（没有之一）的项目。当然技术之外，我也喜欢烧烧菜，弹弹琴——别看我一副十足的码农范，但我也是从小学琴，标准琴童出身呢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：是什么促使你开发Jscex这个异步编程类库的呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应该说是需求与兴趣的共同驱使吧。&lt;/p&gt;

&lt;p&gt;首先，随着Web平台地位的提升，霸占着浏览器的JavaScript语言也成为了世界上最流行的语言之一，甚至通过&lt;a title="Node.js" href="http://nodejs.org/"&gt;Node.js&lt;/a&gt;进入了服务器编程领域。JavaScript的一个重要特性便是“不能阻塞”，这里的“不能”是指“不应该”而不是“无法”的意思（只要提供阻塞的API）。JavaScript是一门单线程语言，因此一旦有某个API阻塞了当前线程，就相当于阻塞了整个程序，所以“异步”在JavaScript编程中占有很重要的地位。异步编程对程序执行效果的好处这里就不多谈了，但是异步编程对于开发者来说十分麻烦，它会将程序逻辑拆分地支离破碎，语义完全丢失。因此，许多程序员都在打造一些异步编程模型已经相关的API来简化异步编程工作，例如Promise模型。而我开发Jscex，其实也是出于这个目的，只不过使用的方式有些特别，效果更好。&lt;/p&gt;

&lt;p&gt;其次，我本身一直是个编程语言爱好者，对这方面的关注经常不被人理解，被鄙视也不是一次两次了。Jscex主要受到了F#的启发，F#是微软为.NET平台创建的一门函数式编程语言，以OCaml为基础，并加入了一些前沿的编程语言研究成果。其中很重要的一个特性便是“计算表达式”，它对于异步编程的支持令人眼前一亮。Jscex的全称是JavaScript Computation Expressions，它是F#中“&lt;a title="F# Computation Expressions" href="http://msdn.microsoft.com/en-us/library/dd233182.aspx"&gt;计算表达式&lt;/a&gt;”特性在JavaScript编程语言上的体现，因此理论上说它不仅仅只有“异步编程”，但简化异步编程的确是它最重要的一部分功能，没有之一。&lt;/p&gt;

&lt;p&gt;这么看来，我为JavaScript本身引入其他语言的异步编程特性也是顺理成章的事情吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：正如你所说的那样，在简化JavaScript异步编程这个事情上其实已经有很多不同的方案（例如Promise等异步模型），那么你觉得这些现成的方案都有哪些不足之处，Jscex是否有“重新发明轮子”的意味在里面呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;作为一个异步流程控制类库，Jscex的唯一目的便是“改善编程体验”，这跟其他大大小小异步流程控制方案有着相同的目标——但是，改善的“程度”以及改善的“方式”便是Jscex与它们最大的区别。&lt;/p&gt;

&lt;p&gt;在传统的异步流程控制类库中，人们普遍使用构建各类API的方式来辅助异步逻辑编写。例如著名的&lt;a title="Step" href="https://github.com/creationix/step/"&gt;Step&lt;/a&gt;类库为了解决异步操作顺序执行的问题，便引入了一个&lt;code&gt;Step&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre class="code"&gt;Step(
    &lt;span style="color: blue"&gt;function &lt;/span&gt;readFile() {
        fs.readFile(filename, &lt;span style="color: blue"&gt;this&lt;/span&gt;);
    },
    &lt;span style="color: blue"&gt;function &lt;/span&gt;capitalize(err, text) {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(err) &lt;span style="color: blue"&gt;throw &lt;/span&gt;err;
        &lt;span style="color: blue"&gt;return &lt;/span&gt;text.toUpperCase();
    },
    &lt;span style="color: blue"&gt;function &lt;/span&gt;writeBack(err, newText) {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(err) &lt;span style="color: blue"&gt;throw &lt;/span&gt;err;
        fs.writeFile(filename, newText, &lt;span style="color: blue"&gt;this&lt;/span&gt;);
    },
    &lt;span style="color: blue"&gt;function &lt;/span&gt;complete(err) {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(err) &lt;span style="color: blue"&gt;throw &lt;/span&gt;err;
        console.log(&lt;span style="color: maroon"&gt;&amp;quot;complete&amp;quot;&lt;/span&gt;);
    }
);&lt;/pre&gt;

&lt;p&gt;在Step类库里，假如要将几个系统串联，则可以依次将多个函数顺序提供给&lt;code&gt;Step&lt;/code&gt;方法，每个函数内部使用自身的&lt;code&gt;this&lt;/code&gt;作为回调，或直接返回一个结果。那么这里就有一个问题，例如在一个面向对象开发的系统中，它们对&lt;code&gt;this&lt;/code&gt;有着严格的依赖关系，而Step则强制使用&lt;code&gt;this&lt;/code&gt;保存回调函数，那又该如何协调两者之间的矛盾？当然，对于一个有经验的JavaScript开发人员来说，解决这点自然不是问题，但始终需要“绕”，即便不影响功能，也会影响编程风格（模式）——由于类库的需要而不得不引入的编程风格（模式）。&lt;/p&gt;

&lt;p&gt;串行如此，那么并行呢？Step又引入了&lt;code&gt;parallel&lt;/code&gt;函数来实现这方面需求，换句话说，每增加一类需求，我们则往往需要增加一个甚至一套API。Step提供了“串行”、“并行”、以及“分组”三类执行方式，而功能更为丰富的&lt;a title="Async" href="https://github.com/caolan/async/"&gt;Async&lt;/a&gt;类库则提供了十几种异步流程控制或是数据处理的辅助方法。&lt;/p&gt;

&lt;p&gt;这就产生了矛盾：更强大的类库，则往往意味着更多的API，以及更多的学习时间，这样开发者才能根据自身需求选择最合适的方法。那么，多少API才能够满足广大人民群众的需求呢？这其实很难界定，根据80/20法则，80%的用户只需要20%的功能，但其实不同的用户群体需要的那20%可能各不相同，这几乎意味着一个类库为了满足各种多变的需求，则需要提供100%的功能，让不同的用户各取自身所需的20%功能。而事实上，由于人们总是能够不断地挖掘出新的需求，因此我们时不时需要设计并实现新的API。同时，为了保证现有代码的兼容性，旧的API也必须保留下来，于是类库的规模往往会不断扩大。&lt;/p&gt;

&lt;p&gt;此外，API的粒度也是一个课题。粒度越大的API往往功能越强，可以通过少量的调用完成大量工作，但粒度大往往意味着难以复用。越细粒度的API灵活度往往越高，可以通过有限的API组合出足够的灵活性，但组合是需要付出“表现力”作为成本的。JavaScript在表现力方面有一些硬伤，即所谓“&lt;a href="syntactic-noise"&gt;语法噪音&lt;/a&gt;”，例如定义函数所用的&lt;code&gt;function&lt;/code&gt;关键字和大括号，函数返回值必须使用的&lt;code&gt;return&lt;/code&gt;关键字等等，其实都限制JavaScript在某些场景下的表达能力，例如在&lt;a title="CoffeeScript" href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt;中的匿名函数&lt;code&gt;(x) -&amp;gt; x + 1&lt;/code&gt;，使用JavaScript就必须写为&lt;code&gt;function (x) { return x + 1; }&lt;/code&gt;。我们的确可以在JavaScript中设计出一套足够灵活，可以组合出各种流程的异步API，我也做过这方面的尝试，但最终会发现，这样设计出来的API始终无法清晰地表达出流程的真正意图。&lt;/p&gt;

&lt;p&gt;总之，对于传统类库来说，在如何界定类库的“边界”，如何确定API的粒度等方面，都需要做出大量的权衡。所谓“权衡”便是通过牺牲一部分的利益来换取更大的收获，但可能在满足80%的需求的时候，剩余20%的用户只能无奈地离开了。&lt;/p&gt;

&lt;p&gt;Jscex的确是个“轮子”，但绝对不是“重新发明”的轮子。我不会掩饰对Jscex的“自夸”：Jscex在JavaScript异步编程领域绝对是一个创新，可谓前无来者。有朋友就评价说“在看到Jscex之前，真以为这是不可能实现的”，因为Jscex事实上是用类库的形式“修补”了JavaScript语言，也正是这个原因，才能让JavaScript异步编程体验获得质的飞跃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：你一直强调Jscex完全就是JavaScript的编程，包括“编程体验”，为什么特别纠结这一点？你为Jscex选择了比较特别的实现方式，也跟这个思路有关吗？这种实现方式的优势在哪里？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们现在想要解决的是“流程控制”问题，那么说起在JavaScript中进行流程控制，有什么能比JavaScript语言本身更为现成的解决方案呢？在我看来，&lt;strong&gt;流程控制并非是一个理应使用类库来解决的问题，它应该是语言的职责&lt;/strong&gt;。只不过在某些时候，我们无法使用语言来表达逻辑或是控制流程，于是推而求其次地使用“类库”来解决这方面的问题。&lt;/p&gt;

&lt;p&gt;这方面我可以举一个例子，且看这段简单的代码：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = -5; i &amp;lt; 5; i++) {
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(i &amp;lt; 0) {
        console.log(i + &lt;span style="color: maroon"&gt;&amp;quot;是负数&amp;quot;&lt;/span&gt;);
    } &lt;span style="color: blue"&gt;else &lt;/span&gt;{
        console.log(i + &lt;span style="color: maroon"&gt;&amp;quot;是正整数&amp;quot;&lt;/span&gt;);
    }
}&lt;/pre&gt;

&lt;p&gt;但其实，只要我们提供了合适的&lt;code&gt;_for&lt;/code&gt;及&lt;code&gt;_if&lt;/code&gt;函数（附1），我们完全可以不用&lt;code&gt;for&lt;/code&gt;及&lt;code&gt;if&lt;/code&gt;关键字来实现相同的功能：&lt;/p&gt;

&lt;pre class="code"&gt;_for(-5, 5, &lt;span style="color: blue"&gt;function &lt;/span&gt;(i) {
    _if(
    &lt;span style="color: #006400"&gt;// 条件
        &lt;/span&gt;i &amp;lt; 0,
    &lt;span style="color: #006400"&gt;// 满足条件的分支
        &lt;/span&gt;&lt;span style="color: blue"&gt;function &lt;/span&gt;() {
            console.log(i + &lt;span style="color: maroon"&gt;&amp;quot;是负数&amp;quot;&lt;/span&gt;);
        },
    &lt;span style="color: #006400"&gt;// else分支
        &lt;/span&gt;&lt;span style="color: blue"&gt;function &lt;/span&gt;() {
            console.log(i + &lt;span style="color: maroon"&gt;&amp;quot;是正整数&amp;quot;&lt;/span&gt;);
        });
});&lt;/pre&gt;

&lt;p&gt;其实只要是有一定函数式编程能力（主要是匿名函数）的语言，都可以在一定程度上通过这种形式的类库实现流程控制，只不过因为语言特性不同，各有美丑而已。不得不说，JavaScript虽然有着还算不错的函数式编程特性，但由于之前提到的硬伤，几乎无法优雅地完成这项任务。&lt;/p&gt;

&lt;p&gt;事实上，上面演示的&lt;code&gt;_for&lt;/code&gt;方法的灵活程度与&lt;code&gt;for&lt;/code&gt;语句还有很大差距，例如，您不妨尝试下如何使用类库实现如下的&lt;code&gt;for&lt;/code&gt;循环：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;iter = getIterator();
&lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = 0; iter.current &amp;lt; i++; iter.moveNext()) {
    ...
}&lt;/pre&gt;

&lt;p&gt;这会直接导致我们的&lt;code&gt;_for&lt;/code&gt;函数必须接受更多的匿名函数，“享受”更多JavaScript语言的硬伤。&lt;/p&gt;

&lt;p&gt;我想说的是，即便我们“有能力”用类库实现类似的效果，但真会有人去这么做吗？使用JavaScript语言本身提供的特性进行流程控制，对于JavaScript开发人员来说，是一件天经地义，顺理成章的事情。JavaScript语言已经提供了开发人员控制流程所需的全部关键字，而且开发人员已经无数次证明了这些关键字是多么的灵活与优雅。假如，我们这里先说“假如”——假如我们可以使用传统的JavaScript语言编写异步代码，使用JavaScript来控制流程，表达逻辑，那么我们就可以避免学习大量新的API，避免遭受JavaScript中的语法噪音，我们只需编写简单而熟悉的JavaScript代码即可。&lt;/p&gt;

&lt;p&gt;在软件开发行业有一句很著名的话：&lt;a title="Leaky Abstractions" href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html"&gt;Every abstraction is leaky&lt;/a&gt;，换句话说，任何一种抽象都是有缺陷的。事实上，各种异步编程模型都是种抽象，它们是为了实现一些常用的异步编程模式而设计出来的一套有针对性的API。但是，在实际使用过程中我们可能遇到千变万化的问题，一旦遇到模型没有“正面应对”的场景，或是触及这种模型的限制（如Step的&lt;code&gt;this&lt;/code&gt;回调），开发人员往往就只能使用一些相对较为丑陋的方式来“回避问题”。Jscex也是一种抽象，因此也不可避免的出现leaky，但Jscex的设计思路便是将这种抽象构建为JavaScript本身。换句话说，Jscex的能力在很大程度上是受限于JavaScript语言的表达能力，而传统异步编程类库则是受限于自身设计的API的表达能力。哪种做法可以应对更大范围的场景，我相信应该已经不言而喻了。&lt;/p&gt;

&lt;p&gt;所以Jscex选择的是这么一种方式：开发人员使用最普通不过的JavaScript来表达一段逻辑，只不过通过某种方式来指定某一个环节是“异步操作”，代码执行流程会在这里“暂停”，等待该异步操作结束，然后再继续执行后续代码。如果这个操作失败，则相当于抛出了一个异常，会被&lt;code&gt;catch&lt;/code&gt;语句捕获。一段类似的代码可以是这样的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;try &lt;/span&gt;{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;content = $await(read(src, content));
    console.log(&lt;span style="color: maroon"&gt;&amp;quot;内容读取成功&amp;quot;&lt;/span&gt;);
    $await(write(target, content));
    console.log(&lt;span style="color: maroon"&gt;&amp;quot;内容读取成功&amp;quot;&lt;/span&gt;);
} &lt;span style="color: blue"&gt;catch &lt;/span&gt;(ex) {
    $await(submitError(ex));
    console.log(&lt;span style="color: maroon"&gt;&amp;quot;错误提交成功&amp;quot;&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;在这段代码里，我们用&lt;code&gt;$await(&amp;lt;task&amp;gt;)&lt;/code&gt;标记一个异步操作，代码流程会在此处“等待”异步操作完成，在&lt;code&gt;catch&lt;/code&gt;分支中也一样。我想，任何一个普通的JavaScript程序员都能顺利理解这段代码的含义。至于性能，自然必须和使用传统回调风格写出来的程序完全一致，这里的“等待”并不是“阻塞”，而会空出执行线程，直至操作完成。而且，假如系统本身没有提供阻塞的API，我们甚至没有“阻塞”代码的方法（当然，本就不该阻塞）。&lt;/p&gt;

&lt;p&gt;当然，单纯依靠JavaScript语言本身显然无法获得这样的能力，JavaScript的执行流程不会随便地暂停，因此我们需要对代码进行&lt;strong&gt;自动改写&lt;/strong&gt;。这便是Jscex的工作原理，值得注意的是“自动”二字，换句话说开发者编写代码的时候完全不需要额外的“改写”步骤，这个功能在Jscex中叫做“&lt;a title="JIT" href="http://en.wikipedia.org/wiki/Just-in-time_compilation"&gt;JIT（Just in Time）编译&lt;/a&gt;”，也就是在程序的执行过程中动态生成并执行新的代码。&lt;/p&gt;

&lt;p&gt;Jscex自动改写的最小单位是“函数”，传统JavaScript函数是这样定义的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;func = &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    &lt;span style="color: #006400"&gt;// 函数体
&lt;/span&gt;};&lt;/pre&gt;

&lt;p&gt;而Jscex函数是这样定义的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;jscexFunc = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;async&amp;quot;&lt;/span&gt;,
    &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
        &lt;span style="color: #006400"&gt;// Jscex函数体
    &lt;/span&gt;}
));&lt;/pre&gt;

&lt;p&gt;可见，在Jscex在使用形式上和一个普通类库毫无二致，这便保证了它与JavaScript有着相同的编程体验。传统如CoffeeScript或是&lt;a title="Dart" href="http://www.dartlang.org/"&gt;Dart&lt;/a&gt;等以JavaScript作为目标语言的“新语言”，都必须引入一个额外的编译步骤。我反复强调，使用Jscex进行开发与普通的JavaScript编程几乎没有任何区别。至于外围的“架子代码”，我们完全可以不关心其特别含义，作为代码片段加入编辑工具，敲一个快捷键便能直接输出。&lt;/p&gt;

&lt;p&gt;在Jscex函数中，我们就可以使用唯一的语言扩展：“绑定”操作，这可以简单理解为那个异步的&lt;code&gt;$await&lt;/code&gt;操作。可以看到，这个特殊操作使用了JavaScript的“函数调用”语义，同样符合JavaScript的编程实践。有些朋友建议把&lt;code&gt;$await&lt;/code&gt;改成关键字形式，而不是函数调用。可惜，这么做首先会被JavaScript运行环境拒之门外，导致无法实现JIT编译器，其次也有可能会破坏一些相关的事物，例如开发工具里的代码着色，甚至某些高级IDE中的语法提示，因为语法提示功能需要先对代码语义进行完整的分析。因此，保证Jscex与JavaScript绝对一致，其实也是在保证Jscex能够完美融入整个JavaScript生态环境。&lt;/p&gt;

&lt;p&gt;不仅是语法设计上如此，Jscex自带的类库设计也充分借助了JavaScript的语义实现。例如Jscex的异步任务模型支持取消操作，要将一个任务置为“取消”状态，只需抛出一个未经捕获的&lt;code&gt;CanceledError&lt;/code&gt;错误即可，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;t1 = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;async&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    $await(t2());
}));

&lt;span style="color: blue"&gt;var &lt;/span&gt;t2 = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;async&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    $await(t3());
}));

&lt;span style="color: blue"&gt;var &lt;/span&gt;t3 = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;async&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    &lt;span style="color: blue"&gt;throw new &lt;/span&gt;CanceledError();
}));&lt;/pre&gt;

&lt;p&gt;根据JavaScript的语义，一个未捕获的异常会顺着调用链不断抛出，导致一系列的异步任务都会进入“取消”状态。这是一个统一而简单的取消模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：Jscex原来的版本API极其简单，可以说只有一个$await。发展到现在，Jscex增加了一些扩展，比如针对Node.js、WinRT的扩展，还有编程模型方面的扩展，像seq、agent这些。这些扩展是否说明Jscex的应用场景超出你原来的预想？Jscex的surface API和语法有没有因为这些扩展而变得复杂呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说实话，Jscex目前还处于“叫好不叫座”的推广期，并没有收到太多额外的用户需求，所有的组件与都是由我设计并实现的，所以当然都在我预想之内啦！&lt;/p&gt;

&lt;p&gt;其实你说的这些概念都不是同一个层面上的东西，它们可以分两大类，一是用于不同目的的“构造器”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a title="Jscex Asynchronous Module" href="http://jscex.info/zh-cn/manuals/async/"&gt;异步&lt;/a&gt;：即&lt;code&gt;async&lt;/code&gt;构造器，用于简化异步开发，基于Jscex自带的异步任务模型。 &lt;/li&gt;

  &lt;li&gt;迭代：即&lt;code&gt;seq&lt;/code&gt;构造器，用于生成一个延迟计算的迭代器。 &lt;/li&gt;

  &lt;li&gt;&lt;a title="Jscex Promise Module" href="http://jscex.info/zh-cn/manuals/promise/"&gt;Promise&lt;/a&gt;：即&lt;code&gt;promise&lt;/code&gt;构造器，用于支持基于Promise/A模型的异步开发。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“构造器”和“编译器”是Jscex的两大支柱。Jscex编译器在转化一个普通的JavaScript函数的时候永远使用相同的模式，但配合不同的“构造器”便能得到不同的效果。例如&lt;code&gt;seq&lt;/code&gt;构造器可以用来创建一个无限长的迭代器：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;infinite = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;seq&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;(start) {
    &lt;span style="color: blue"&gt;while &lt;/span&gt;(&lt;span style="color: blue"&gt;true&lt;/span&gt;) {
        $yield(start++);
    }
}));

&lt;span style="color: blue"&gt;var &lt;/span&gt;fib = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;seq&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    $yield(0);
    $yield(1);

    &lt;span style="color: blue"&gt;var &lt;/span&gt;a = 0, current = 1;
    &lt;span style="color: blue"&gt;while &lt;/span&gt;(&lt;span style="color: blue"&gt;true&lt;/span&gt;) {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;b = a;
        a = current;
        current = a + b;

        $yield(current);
    }
}));&lt;/pre&gt;

&lt;p&gt;不同的构造器中的“绑定”操作不同，其含义也不一样。例如在&lt;code&gt;seq&lt;/code&gt;构造器中的绑定操作为&lt;code&gt;$yield&lt;/code&gt;，表示输出迭代器里的一个对象，并将控制权交由外部，直到下次调用&lt;code&gt;moveNext&lt;/code&gt;方法时才继续执行。因此，虽然上述两个方法都是会输出“无限长”的序列，但什么时候取元素，取多少元素完全由使用者控制，即所谓“延迟计算”，“按需计算”。&lt;/p&gt;

&lt;p&gt;两个迭代器还能够组合使用，例如：&lt;/p&gt;

&lt;pre class="code"&gt;fib() &lt;span style="color: #006400"&gt;// 无限长的菲波纳契数列
    &lt;/span&gt;.filter(&lt;span style="color: blue"&gt;function &lt;/span&gt;(n) { &lt;span style="color: blue"&gt;return &lt;/span&gt;n % 2 == 0; }) &lt;span style="color: #006400"&gt;// 取其中所有的偶数
    &lt;/span&gt;.skip(2) &lt;span style="color: #006400"&gt;// 跳开前2个数
    &lt;/span&gt;.take(5) &lt;span style="color: #006400"&gt;// 取5个数
    &lt;/span&gt;.zip(infinite(1)) &lt;span style="color: #006400"&gt;// 和从1开始的无限长序列组合
    &lt;/span&gt;.map(&lt;span style="color: blue"&gt;function &lt;/span&gt;(a) { &lt;span style="color: blue"&gt;return &lt;/span&gt;a[1] + &lt;span style="color: maroon"&gt;&amp;quot;: &amp;quot; &lt;/span&gt;+ a[0]; }) &lt;span style="color: #006400"&gt;// 将每个组合拼接成字符串
    &lt;/span&gt;.each(print); &lt;span style="color: #006400"&gt;// 并打印出来&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;即便是无穷序列，但由于我们使用了&lt;code&gt;take(5)&lt;/code&gt;操作，最终也只会打印出五项，而不会成为死循环。这类“组合”操作便是“扩展类库”的功劳，确切地说在这里是指“迭代增强模块”。面向异步编程的&lt;code&gt;async&lt;/code&gt;构造器也有对应的“&lt;a title="Jscex Asynchronous Powerpack Module" href="http://jscex.info/zh-cn/manuals/async/powerpack.html"&gt;异步增强模块&lt;/a&gt;”，它扩展了&lt;code&gt;async&lt;/code&gt;构造器所使用的异步任务模型，例如并发相关的辅助函数。此外还有一些常用的异步操作（如封装了&lt;code&gt;setTimeout&lt;/code&gt;的&lt;code&gt;sleep&lt;/code&gt;方法），并简化了与其他一些常见异步编程模型的协作。你所提到的Node.js以及agent扩展都是类似的“类库”，前者自不必说，后者则是一个Erlang中Actor模型的尝试实现，基于Jscex的异步编程支持。&lt;/p&gt;

&lt;p&gt;不过你提到的WinRT扩展就不同了，它其实便是&lt;code&gt;promise&lt;/code&gt;构造器，是为了直接支持使用&lt;a title="Promise/A" href="http://wiki.commonjs.org/wiki/Promises/A"&gt;Promise/A&lt;/a&gt;异步模型的开发环境。Promise/A现在是CommonJS的草案之一，提出了一种Promise模型的设计及API表现。虽说它离“标准”还有很长一段距离，但其实很多类库都已经实现了这个规范了，例如著名的&lt;a title="Promise in jQuery" href="http://api.jquery.com/promise/"&gt;jQuery&lt;/a&gt;，&lt;a title="node-promise" href="http://github.com/kriszyp/node-promise"&gt;node-promise&lt;/a&gt;，还有用来编写Win8中Metro应用（即WinRT）的HTML5开发平台。当然严格来说，它们都是基于Promise/A规范的一套“扩展实现”，但既然有了共有的子集，那事情就已经好办多了。&lt;/p&gt;

&lt;p&gt;之前在一个QQ群上某同学建议我提供一个类似于&lt;code&gt;fromStandard&lt;/code&gt;（用于将标准的回调异步方法适配为Jscex异步模型）一样的&lt;code&gt;fromPromise&lt;/code&gt;辅助方法。这当然没问题，其实很简单，接下来也会做，但Jscex考虑得更多，例如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;为什么需要&lt;code&gt;fromPromise&lt;/code&gt;辅助方法？因为用户使用了Promise异步模型，而希望Jscex提供更好的辅助环境。 &lt;/li&gt;

  &lt;li&gt;为什么对方不使用Jscex自带的异步任务模型？因为用户可能已经有部分代码采用了Promise模型。 &lt;/li&gt;

  &lt;li&gt;为什么它要使用Promise这种已经较为成熟且复杂的异步模型？因为用户可能已经有了一个围绕着Promise模型开发的应用程序，甚至是一个已经拥有大量辅助方法支持的应用开发框架（例如WinRT）。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，这种情况下如何还需要再结合Jscex的异步任务模型，则需要来回转换，显得略为冗余——不如就让Jscex对Promise/A异步模型直接提供支持吧！换句话说，要让&lt;code&gt;$await&lt;/code&gt;操作接受一个Promise对象而不是一个Jscex异步任务对象，同时一个使用&lt;code&gt;promise&lt;/code&gt;构造器生成的Jscex异步方法也会直接返回一个Promise/A对象。于是我们在WinRT中便可以编写这样的代码：&lt;/p&gt;

&lt;pre class="code"&gt;WinJS.Namespace.define(&lt;span style="color: maroon"&gt;&amp;quot;MyApp&amp;quot;&lt;/span&gt;, {
    showPhoto: eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;promise&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;dlg = &lt;span style="color: blue"&gt;new &lt;/span&gt;MessageDialog(&lt;span style="color: maroon"&gt;&amp;quot;Do you want to open a file?&amp;quot;&lt;/span&gt;);
        dlg.commands.push(&lt;span style="color: blue"&gt;new &lt;/span&gt;UICommand(&lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;null&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;));
        dlg.commands.push(&lt;span style="color: blue"&gt;new &lt;/span&gt;UICommand(&lt;span style="color: maroon"&gt;&amp;quot;No&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;null&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;No&amp;quot;&lt;/span&gt;));

        &lt;span style="color: #006400"&gt;// 显示对话框，并等待用户选择Yes或No
        &lt;/span&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;result = $await(dlg.showAsync());

        &lt;span style="color: blue"&gt;if &lt;/span&gt;(result.id == &lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;) {
            &lt;span style="color: blue"&gt;var &lt;/span&gt;picker = &lt;span style="color: blue"&gt;new &lt;/span&gt;FileOpenPicker();
            picker.viewMode = PickerViewMode.thumbnail;
            picker.suggestedStartLocation = PickerLocationId.picturesLibrary;
            picker.fileTypeFilter.push(&lt;span style="color: maroon"&gt;&amp;quot;.jpg&amp;quot;&lt;/span&gt;);

            &lt;span style="color: #006400"&gt;// 显示文件选择器，并等待用户选择文件
            &lt;/span&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;file = $await(picker.pickSingleFileAsync());

            &lt;span style="color: blue"&gt;if &lt;/span&gt;(file != &lt;span style="color: blue"&gt;null&lt;/span&gt;) {
                $(&lt;span style="color: maroon"&gt;&amp;quot;#myImg&amp;quot;&lt;/span&gt;).src = URL.createObjectURL(file);
            }
        }
    }))
});&lt;/pre&gt;

&lt;p&gt;此时我们可以一视同仁地对待showPhoto方法以及WinRT中标准的异步操作，甚至可以把它传入WinRT的系统方法配合使用，因为它完全符合WinRT标准。值得一提地是，创建&lt;code&gt;promise&lt;/code&gt;构造器只需花费30余行代码（包括空行及函数定义）。从这个例子中可以看出，在需要的情况下，我们完全可以轻松地让Jscex融入任何异步模型。&lt;/p&gt;

&lt;p&gt;一开始我就提到，Jscex其实是受到F#计算表达式的启发而诞生的JavaScript类库，这些所谓的“变化”和“扩展”实际上都没有逃离计算表达式及其基础理论&lt;a title="Monad (Wikipedia)" href="http://en.wikipedia.org/wiki/Monad_(functional_programming)"&gt;Monad&lt;/a&gt;的范畴。Jscex从诞生开始便一直差不多是现在这样的使用方式，只是其内部实现在不断完善而已。不过我目前的精力完全放在了异步编程上，因此如&lt;code&gt;seq&lt;/code&gt;构造器或是agent扩展都还处于孵化阶段，虽然它们几乎是我还在验证Jscex可行性的阶段时开发的。&lt;/p&gt;

&lt;h1&gt;附1&lt;/h1&gt;

&lt;p&gt;我们可以这样实现&lt;code&gt;_for&lt;/code&gt;及&lt;code&gt;_if&lt;/code&gt;函数：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;_for = &lt;span style="color: blue"&gt;function &lt;/span&gt;(begin, end, body) {
    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = begin; i &amp;lt; end; i++) {
        body(i);
    }
};

&lt;span style="color: blue"&gt;var &lt;/span&gt;_if = &lt;span style="color: blue"&gt;function &lt;/span&gt;(condition, bodyPart, elsePart) {
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(condition) {
        bodyPart();
    } &lt;span style="color: blue"&gt;else &lt;/span&gt;{
        elsePart();
    }
};&lt;/pre&gt;


&lt;h1&gt;参考&lt;/h1&gt;

&lt;p&gt;Jscex相关：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a title="Jscex Website" href="http://jscex.info/zh-cn/"&gt;网站&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Jscex GitHub" href="https://github.com/JeffreyZhao/jscex"&gt;源码&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Jscex Manuals" href="http://jscex.info/zh-cn/manuals/"&gt;开发指南&lt;/a&gt; 

    &lt;ul&gt;
      &lt;li&gt;&lt;a title="Jscex JIT Module" href="http://jscex.info/zh-cn/manuals/jit/"&gt;JIT模块&lt;/a&gt; &lt;/li&gt;

      &lt;li&gt;&lt;a title="Jscex Asynchronous Module" href="http://jscex.info/zh-cn/manuals/async/"&gt;异步开发模块&lt;/a&gt; 

        &lt;ul&gt;
          &lt;li&gt;&lt;a title="Jscex Asynchronous Powerpack Module" href="http://jscex.info/zh-cn/manuals/async/powerpack.html"&gt;异步增强模块&lt;/a&gt; &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;

      &lt;li&gt;&lt;a title="Jscex Promise Module" href="http://jscex.info/zh-cn/manuals/promise/"&gt;Promise模块&lt;/a&gt; &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;项目：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a title="Step" href="https://github.com/creationix/step/"&gt;Step&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Async" href="https://github.com/caolan/async/"&gt;Async&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="CoffeeScript" href="http://coffeescript.org/"&gt;CoffeeScript&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Dart" href="http://www.dartlang.org/"&gt;Dart&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Promise模型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a title="Promise/A" href="http://wiki.commonjs.org/wiki/Promises/A"&gt;Promise/A规范&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="node-promise" href="http://github.com/kriszyp/node-promise"&gt;node-promise&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Promise in jQuery" href="http://api.jquery.com/promise/"&gt;jQuery中的Promise&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Promise in WinRT" href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx"&gt;Win8 Metro开发中的Promise&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="fsharp-computation-expressions"&gt;F#计算表达式&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Monad (Wikipedia)" href="http://en.wikipedia.org/wiki/Monad_(functional_programming)"&gt;Monad&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Syntactic Noise" href="http://martinfowler.com/bliki/SyntacticNoise.html"&gt;语法噪音&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="JIT" href="http://en.wikipedia.org/wiki/Just-in-time_compilation"&gt;JIT编译&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;&lt;a title="Leaky Abstractions" href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html"&gt;抽象泄露定律&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;</description>
      <comments>http://blog.zhaojie.me/2012/07/infoq-interview-jscex-author-1.html#comments</comments>
      <pubDate>Sat, 28 Jul 2012 22:01:06 GMT</pubDate>
      <lastBuildDate>Mon, 30 Jul 2012 00:19:25 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/extension/">项目扩展</category>
      <title>Jscex与Promise/A那些事</title>
      <link>http://blog.zhaojie.me/2012/06/promise-support-in-jscex.html</link>
      <guid>http://blog.zhaojie.me/2012/06/promise-support-in-jscex.html</guid>
      <description>&lt;p&gt;任何异步编程的类库要做的第一件事往往便是统一异步编程的模型，例如&lt;a href="http://jscex.info/zh-cn/"&gt;Jscex&lt;/a&gt;的&lt;a href="http://jscex.info/zh-cn/manuals/async/"&gt;异步模块&lt;/a&gt;自带一个类似于.NET中的异步任务模型。围绕统一的模型，开发人员便可以尽情地提供各种扩展，例如Jscex&lt;a href="http://jscex.info/zh-cn/manuals/async/powerpack.html"&gt;异步增强模块&lt;/a&gt;中的&lt;code&gt;whenAll&lt;/code&gt;或&lt;code&gt;whenAny&lt;/code&gt;一样。换句话说，假如要混用两种异步编程模型，往往需要将其中一种适配至另外一种，因此异步增强模块中也提供了&lt;code&gt;fromCallback&lt;/code&gt;及&lt;code&gt;fromStandard&lt;/code&gt;辅助，能够轻易地将最简单的（也是Node.js里使用的）两种异步函数接口绑定为异步任务。那么&lt;a href="http://wiki.commonjs.org/wiki/Promises/A"&gt;Promise/A&lt;/a&gt;呢？它也是种目前运用十分广泛的异步编程模型，Jscex对它有什么特别的支持吗？当然有，但方式有所不同，更为直接。&lt;/p&gt;

&lt;p&gt;Promise/A现在为CommonJS的草案之一，提出了一种Promise模型的设计及API表现。虽说它离“标准”还有很长一段距离，但其实很多类库都已经实现了这个规范了，例如著名的jQuery，&lt;a href="https://github.com/kriszyp/node-promise"&gt;node-promise&lt;/a&gt;，还有用来编写Win8中Metro应用的HTML5开发平台。当然严格来说，它们都是基于Promise/A规范的一套“扩展实现”，但既然有了共有的子集，那事情就已经好办多了。例如，之前在一个QQ群上某同学建议我提供一个&lt;a href="https://github.com/JeffreyZhao/jscex/issues/19"&gt;类似于fromStandard一样的fromPromise辅助方法&lt;/a&gt;。这当然没问题，其实很简单，接下来也会做，但Jscex考虑地更多。&lt;/p&gt;

&lt;p&gt;或者说，就是多问了几个为什么：&lt;/p&gt;

&lt;p&gt;为什么需要fromPromise辅助方法？因为用户使用了Promise异步模型，而Jscex希望提供更好的辅助环境。为什么对方不使用Jscex自带的异步任务模型？因为用户可能已经有部分代码采用了Promise模型。为什么它要使用Promise这种已经较为成熟且复杂的异步模型？因为用户可能已经有了一个围绕着Promise模型开发的应用程序，甚至是一个已经拥有大量辅助方法支持的应用开发框架（例如Win8），而在这个情况下再结合Jscex的异步任务模型，则需要来回转换，显得略为冗余。那么，Jscex能否直接对Promise异步模型提供支持呢？&lt;/p&gt;

&lt;p&gt;当然可以，从一开始Jscex就是这么设计的，且看&lt;a href="http://repository.jscex.info/master/samples/promise/jquery-animation.html" data-popup-height="200" data-popup-width="300" data-popup="iframe"&gt;这个示例&lt;/a&gt;：&lt;/p&gt;

&lt;pre class="code"&gt;Jscex.Promise.create = &lt;span style="color: blue"&gt;function &lt;/span&gt;(init) {
    &lt;span style="color: blue"&gt;var &lt;/span&gt;dfd = &lt;span style="color: blue"&gt;new &lt;/span&gt;$.Deferred();
    init(dfd.resolve, dfd.reject);
    &lt;span style="color: blue"&gt;return &lt;/span&gt;dfd.promise();
}

&lt;span style="color: blue"&gt;var &lt;/span&gt;oneRoundTripAsync = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;promise&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    $await($(&lt;span style="color: maroon"&gt;&amp;quot;#block&amp;quot;&lt;/span&gt;).animate({ left: &lt;span style="color: maroon"&gt;&amp;quot;200px&amp;quot; &lt;/span&gt;}, 1000).promise());
    $await($(&lt;span style="color: maroon"&gt;&amp;quot;#block&amp;quot;&lt;/span&gt;).animate({ left: &lt;span style="color: maroon"&gt;&amp;quot;0px&amp;quot; &lt;/span&gt;}, 1000).promise());
}));

&lt;span style="color: blue"&gt;var &lt;/span&gt;roundTripsAsync = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;promise&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;(n) {
    &lt;span style="color: blue"&gt;for &lt;/span&gt;(&lt;span style="color: blue"&gt;var &lt;/span&gt;i = 0; i &amp;lt; n; i++) {
        $await(oneRoundTripAsync());
    }
}));&lt;/pre&gt;

&lt;p&gt;这是用jQuery自带的animate方法创建动画的示例。正如我之前说的那样，各个模型其实都是基于Promise/A的“扩展”，因此Jscex无法提供一种另所有人都满意的Promise模型，于是它谁都不去迎合，将构造Promise对象的任务交给使用者——这便是上面代码中提供Jscex.Promise.create方法的原因。之后便可以像使用Jscex异步模型那样创建和使用异步方法了，区别仅仅是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用promise作为构造器的名称。 &lt;/li&gt;

  &lt;li&gt;异步方法返回的都将是Promise对象。 &lt;/li&gt;

  &lt;li&gt;$await操作接受的参数也是Promise对象。 &lt;/li&gt;

  &lt;li&gt;执行异步方法之后，异步操作已经直接启动了，而无需调用start方法。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而想在Win8里开发也一样，首先提供一个用于创建Promise对象的工厂方法：&lt;/p&gt;

&lt;pre class="code"&gt;Jscex.Promise.create = &lt;span style="color: blue"&gt;function &lt;/span&gt;(init) {
    &lt;span style="color: blue"&gt;return new &lt;/span&gt;WinJS.Promise(init);
}&lt;/pre&gt;

&lt;p&gt;然后便可以将以下这段使用回调实现的“提示”、“显示选择器”、“显示图片”这个事务：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;MessageDialog = Windows.UI.Popups.MessageDialog;
&lt;span style="color: blue"&gt;var &lt;/span&gt;UICommand = Windows.UI.Popups.UICommand;
&lt;span style="color: blue"&gt;var &lt;/span&gt;FileOpenPicker = Windows.Storage.Pickers.FileOpenPicker;
&lt;span style="color: blue"&gt;var &lt;/span&gt;PickerViewMode = Windows.Storage.Pickers.PickerViewMode;
&lt;span style="color: blue"&gt;var &lt;/span&gt;PickerLocationId = Windows.Storage.Pickers.PickerLocationId;
&lt;span style="color: blue"&gt;var &lt;/span&gt;FileAccessMode = Windows.Storage.FileAccessMode;

WinJS.Namespace.define(&lt;span style="color: maroon"&gt;&amp;quot;MyApp&amp;quot;&lt;/span&gt;, {
    showPhoto: &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;dlg = &lt;span style="color: blue"&gt;new &lt;/span&gt;MessageDialog(&lt;span style="color: maroon"&gt;&amp;quot;Do you want to open a file?&amp;quot;&lt;/span&gt;);
        dlg.commands.push(&lt;span style="color: blue"&gt;new &lt;/span&gt;UICommand(&lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;null&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;));
        dlg.commands.push(&lt;span style="color: blue"&gt;new &lt;/span&gt;UICommand(&lt;span style="color: maroon"&gt;&amp;quot;No&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;null&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;No&amp;quot;&lt;/span&gt;));

        dlg.showAsync().then(&lt;span style="color: blue"&gt;function &lt;/span&gt;(result) {
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(result.id == &lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;) {
                &lt;span style="color: blue"&gt;var &lt;/span&gt;picker = &lt;span style="color: blue"&gt;new &lt;/span&gt;FileOpenPicker();
                picker.viewMode = PickerViewMode.thumbnail;
                picker.suggestedStartLocation = PickerLocationId.picturesLibrary;
                picker.fileTypeFilter.push(&lt;span style="color: maroon"&gt;&amp;quot;.jpg&amp;quot;&lt;/span&gt;);

                picker.pickSingleFileAsync().then(&lt;span style="color: blue"&gt;function &lt;/span&gt;(file) {
                    &lt;span style="color: blue"&gt;if &lt;/span&gt;(file != &lt;span style="color: blue"&gt;null&lt;/span&gt;) {
                        $(&lt;span style="color: maroon"&gt;&amp;quot;#myImg&amp;quot;&lt;/span&gt;)[0].src = URL.createObjectURL(file);
                    }
                });
            }
        });
    }
});&lt;/pre&gt;

&lt;p&gt;实现为：&lt;/p&gt;

&lt;pre class="code"&gt;WinJS.Namespace.define(&lt;span style="color: maroon"&gt;&amp;quot;MyApp&amp;quot;&lt;/span&gt;, {
    showPhoto: eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;promise&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;dlg = &lt;span style="color: blue"&gt;new &lt;/span&gt;MessageDialog(&lt;span style="color: maroon"&gt;&amp;quot;Do you want to open a file?&amp;quot;&lt;/span&gt;);
        dlg.commands.push(&lt;span style="color: blue"&gt;new &lt;/span&gt;UICommand(&lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;null&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;));
        dlg.commands.push(&lt;span style="color: blue"&gt;new &lt;/span&gt;UICommand(&lt;span style="color: maroon"&gt;&amp;quot;No&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;null&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;No&amp;quot;&lt;/span&gt;));

        &lt;span style="color: blue"&gt;var &lt;/span&gt;result = $await(dlg.showAsync());
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(result.id == &lt;span style="color: maroon"&gt;&amp;quot;Yes&amp;quot;&lt;/span&gt;) {
            &lt;span style="color: blue"&gt;var &lt;/span&gt;picker = &lt;span style="color: blue"&gt;new &lt;/span&gt;FileOpenPicker();
            picker.viewMode = PickerViewMode.thumbnail;
            picker.suggestedStartLocation = PickerLocationId.picturesLibrary;
            picker.fileTypeFilter.push(&lt;span style="color: maroon"&gt;&amp;quot;.jpg&amp;quot;&lt;/span&gt;);

            &lt;span style="color: blue"&gt;var &lt;/span&gt;file = $await(picker.pickSingleFileAsync());
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(file != &lt;span style="color: blue"&gt;null&lt;/span&gt;) {
                $(&lt;span style="color: maroon"&gt;&amp;quot;#myImg&amp;quot;&lt;/span&gt;).src = URL.createObjectURL(file);
            }
        }
    }))
});&lt;/pre&gt;

&lt;p&gt;Jscex这不又瞬间支持了Win8开发了吗？此时所有的Jscex异步函数都会返回一个Promise对象，它和WinJS中各种表达异步操作的Promise对象完全相同，也可以和Promise.join以及Promise.any共同使用。而且，实现一个&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/src/jscex-promise.js"&gt;支持Promise的Jscex构造器&lt;/a&gt;只需要30多行代码，其中相当部分还是函数定义等架子代码，创建一个Jscex构造器的大部分代码都已经由&lt;a href="http://jscex.info/zh-cn/manuals/builderbase/"&gt;构造器基础模块&lt;/a&gt;提供了。换句话说，假如您的应用中已经有个深入骨髓的异步模型，也只需30多行代码，便可以直接在Jscex中使用了。&lt;/p&gt;

&lt;p&gt;这也是Jscex的精妙之处之一：一个简单统一的结构，可以实现出各种灵活的功能。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/06/promise-support-in-jscex.html#comments</comments>
      <pubDate>Mon, 25 Jun 2012 19:13:48 GMT</pubDate>
      <lastBuildDate>Sat, 01 Sep 2012 00:30:42 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/news/">新闻信息</category>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <title>使用Node.js编写Shell脚本，暨Jscex 0.6.5版本发布</title>
      <link>http://blog.zhaojie.me/2012/06/nodejs-shell-jscex-0.6.5.html</link>
      <guid>http://blog.zhaojie.me/2012/06/nodejs-shell-jscex-0.6.5.html</guid>
      <description>&lt;p&gt;昨天不得不花时间做了点保护博客阅读体验的事情，但其实这篇才是我真正想写的。上个星期在香港出差，晚上的活动大都是喝酒，回到酒店便借着些许酒劲改进&lt;a href="http://jscex.info/zh-cn/"&gt;Jscex&lt;/a&gt;。如今虽然Jscex的开发工作并没有详细的时间计划，但我正在使用&lt;a href="https://github.com/JeffreyZhao/jscex/issues"&gt;GitHub的Issues页面&lt;/a&gt;记录需要制作的任务点，因此每天都是朝着目标逐步前进的。按照计划，&lt;a href="https://github.com/JeffreyZhao/jscex/issues?milestone=1&amp;amp;state=closed"&gt;Jscex的0.6.5的主要目标&lt;/a&gt;是对Jscex的模块机制进行改进，统一辅助方法，并使用Node.js重新编写发布脚本。这些工作的目的都是为接下来的&lt;a href="https://github.com/JeffreyZhao/jscex/issues?milestone=2&amp;amp;state=open"&gt;0.7.0版本&lt;/a&gt;作准备，它将会是Jscex在项目功能与质量，以及专业性上有重大突破的版本。&lt;/p&gt;

&lt;p&gt;Jscex的模块化划分十分细致，目前正式对外发布的也已经有&lt;a href="https://github.com/JeffreyZhao/jscex/tree/master/bin/npm"&gt;六个模块&lt;/a&gt;（还有一个是命令）。模块化的目的是为了选择性的加载，例如在前端开发过程时需要加载&lt;a href="https://github.com/JeffreyZhao/jscex/tree/master/bin/dev"&gt;所有的模块&lt;/a&gt;，而真正部署时则&lt;a href="https://github.com/JeffreyZhao/jscex/tree/master/bin/dev"&gt;无需最大的两个模块&lt;/a&gt;：JIT编译器及解析器（前者依赖后者），这既照顾到了JavaScript编程体验，也考虑到前端部署时的尺寸。但是模块化便对模块管理提出了要求，这在Node.js平台下问题不大，因为NPM自带包管理功能，但在浏览器上便没有那么好的支持了。例如，模块依赖时还会涉及到版本，版本过高或者过低都是问题，如何在模块没有加载，或是加载了错误的版本时清晰地告诉用户，这便是0.6.5版本中想要解决的问题。此外，Jscex还直接支持不同的包加载环境（如AMD环境，&lt;a href="http://blog.zhaojie.me/2012/06/jscex-unit-tests-with-mocha-chai.html"&gt;之前我也谈过这方面的单元测试&lt;/a&gt;），这也是模块机制的重要责任。有了核心模块机制以后，各模块只需要注册自己的信息以及初始化方法，之前提过的错误提示，包加载环境支持等功能，便可以一并使用了。之后如果需要修复问题，或提供更多的功能，也只需要修改这个核心模块机制——简单地说，其实就是DRY原则。&lt;/p&gt;

&lt;p&gt;更重要的一点是，这个各个模块在使用这个模块机制的时候，其实已经提供了自己的元信息，例如模块名称，当前版本，它所依赖的模块及其版本等等。换句话说，在发布这些脚本的时候，我们完全可以直接读取这些信息，而无需额外的配置文件。因此，我也使用&lt;a href="https://github.com/JeffreyZhao/jscex/tree/master/scripts"&gt;Node.js替换了原来的Shell编写发布脚本&lt;/a&gt;。使用Node.js来代替Shell脚本&lt;a href="https://github.com/JeffreyZhao/jscex/tree/master/scripts"&gt;在某些情况下的确会更为方便&lt;/a&gt;，对于一些常见逻辑表达（条件判断，循环等等）或是操作（文件处理，字符串分析等等）来讲，JavaScript语言的可读性无疑会比Shell高很多（因此也有很多人使用Ruby或Python来代替Shell脚本），对于熟悉JavaScript的同学来说则更不用说了。&lt;/p&gt;

&lt;p&gt;大量使用Node.js来编写脚本并不如想象中的麻烦，它受JavaScript异步特性的影响并不大，这是因为Node.js标准库里包含了许多同步的方法，使用这些同步方法便可以完成绝大部分工作了，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: maroon"&gt;&amp;quot;use strict&amp;quot;&lt;/span&gt;;

&lt;span style="color: blue"&gt;var &lt;/span&gt;path = require(&lt;span style="color: maroon"&gt;&amp;quot;path&amp;quot;&lt;/span&gt;),
    fs = require(&lt;span style="color: maroon"&gt;&amp;quot;fs&amp;quot;&lt;/span&gt;),
    utils = require(&lt;span style="color: maroon"&gt;&amp;quot;../lib/utils&amp;quot;&lt;/span&gt;),
    Jscex = utils.Jscex,
    _ = Jscex._;

&lt;span style="color: blue"&gt;var &lt;/span&gt;devDir = path.join(__dirname, &lt;span style="color: maroon"&gt;&amp;quot;../bin/dev&amp;quot;&lt;/span&gt;);
&lt;span style="color: blue"&gt;var &lt;/span&gt;srcDir = path.join(__dirname, &lt;span style="color: maroon"&gt;&amp;quot;../src&amp;quot;&lt;/span&gt;);

&lt;span style="color: blue"&gt;if &lt;/span&gt;(path.existsSync(devDir)) {
    utils.rmdirSync(devDir);
}

fs.mkdirSync(devDir);

&lt;span style="color: blue"&gt;var &lt;/span&gt;coreName = &lt;span style="color: maroon"&gt;&amp;quot;jscex-&amp;quot; &lt;/span&gt;+ Jscex.coreVersion + &lt;span style="color: maroon"&gt;&amp;quot;.js&amp;quot;
&lt;/span&gt;utils.copySync(path.join(srcDir, &lt;span style="color: maroon"&gt;&amp;quot;jscex.js&amp;quot;&lt;/span&gt;), path.join(devDir, coreName));
console.log(coreName + &lt;span style="color: maroon"&gt;&amp;quot; generated.&amp;quot;&lt;/span&gt;);

&lt;span style="color: blue"&gt;var &lt;/span&gt;moduleList = [&lt;span style="color: maroon"&gt;&amp;quot;parser&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;jit&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;builderbase&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;async&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;async-powerpack&amp;quot;&lt;/span&gt;];

_.each(moduleList, &lt;span style="color: blue"&gt;function &lt;/span&gt;(i, module) {
    &lt;span style="color: blue"&gt;var &lt;/span&gt;fullName = &lt;span style="color: maroon"&gt;&amp;quot;jscex-&amp;quot; &lt;/span&gt;+ module;
    &lt;span style="color: blue"&gt;var &lt;/span&gt;version = Jscex.modules[module].version;
    &lt;span style="color: blue"&gt;var &lt;/span&gt;outputName = fullName + &lt;span style="color: maroon"&gt;&amp;quot;-&amp;quot; &lt;/span&gt;+ version + &lt;span style="color: maroon"&gt;&amp;quot;.js&amp;quot;&lt;/span&gt;;
    utils.copySync(path.join(srcDir, fullName + &lt;span style="color: maroon"&gt;&amp;quot;.js&amp;quot;&lt;/span&gt;), path.join(devDir, outputName));
    console.log(outputName + &lt;span style="color: maroon"&gt;&amp;quot; generated.&amp;quot;&lt;/span&gt;);
});&lt;/pre&gt;

&lt;p&gt;以上便是&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/scripts/build-dev.js"&gt;发布开发版Jscex的脚本&lt;/a&gt;，可见其中每一步IO操作，例如判断目录是否存在，删除/创建目录以及复制文件，都使用了同步的版本。不过，Node.js并不能够完全代替Shell脚本，因为Shell脚本有其重要的武器：管道。试想，你如何使用JavaScript来实现下面这行Shell脚本所做的事情？&lt;/p&gt;

&lt;pre class="code"&gt;cat /data/logs/run.log | grep 'node' | grep -v 'innode' | awk {'print $2'} | xargs sudo kill -9&lt;/pre&gt;

&lt;p&gt;因此，有时候我们不可避免要在Node.js中调用Shell脚本。同理，我们总会有需要调用外部程序的时候，例如，在发布生产环境的Jscex时，我需要使用&lt;a href="https://developers.google.com/closure/compiler/"&gt;Google Closure Compiler&lt;/a&gt;来压缩脚本体积，这就需要使用&lt;a href="http://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback"&gt;exec&lt;/a&gt;来执行外部命令。可惜的是，exec方法没有同步的版本，因此我们必须使用回调函数来处理结果，这又会再次陷入回调函数的泥潭。不过幸好我们有Jscex：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;fromCallback = Jscex.Async.Binding.fromCallback,
    exec = require(&lt;span style="color: maroon"&gt;'child_process'&lt;/span&gt;).exec,
    execAsync = fromCallback(exec, &lt;span style="color: maroon"&gt;&amp;quot;_ignored_&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;stdout&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;stderr&amp;quot;&lt;/span&gt;);

&lt;span style="color: blue"&gt;var &lt;/span&gt;buildOne = eval(Jscex.compile(&lt;span style="color: maroon"&gt;&amp;quot;async&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;(module) {
    &lt;span style="color: blue"&gt;var &lt;/span&gt;fullName, version;
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(!module) {
        fullName = &lt;span style="color: maroon"&gt;&amp;quot;jscex&amp;quot;&lt;/span&gt;;
        version = Jscex.coreVersion;
    } &lt;span style="color: blue"&gt;else &lt;/span&gt;{
        fullName = &lt;span style="color: maroon"&gt;&amp;quot;jscex-&amp;quot; &lt;/span&gt;+ module;
        version = Jscex.modules[module].version;
    }

    &lt;span style="color: blue"&gt;var &lt;/span&gt;inputFile = fullName + &lt;span style="color: maroon"&gt;&amp;quot;.js&amp;quot;&lt;/span&gt;;
    &lt;span style="color: blue"&gt;var &lt;/span&gt;outputFile = fullName + &lt;span style="color: maroon"&gt;&amp;quot;-&amp;quot; &lt;/span&gt;+ version + &lt;span style="color: maroon"&gt;&amp;quot;.min.js&amp;quot;&lt;/span&gt;;

    &lt;span style="color: blue"&gt;var &lt;/span&gt;command = _.format(
        &lt;span style="color: maroon"&gt;&amp;quot;java -jar {0} --js {1} --js_output_file {2} --compilation_level SIMPLE_OPTIMIZATIONS&amp;quot;&lt;/span&gt;,
        gccPath,
        path.join(srcDir, inputFile),
        path.join(prodDir, outputFile));

    utils.stdout(&lt;span style="color: maroon"&gt;&amp;quot;Generating {0}...&amp;quot;&lt;/span&gt;, outputFile);

    &lt;span style="color: blue"&gt;var &lt;/span&gt;r = &lt;span style="color: red"&gt;$await(execAsync(command))&lt;/span&gt;;
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(r.stderr) {
        utils.stdout(&lt;span style="color: maroon"&gt;&amp;quot;failed.\n&amp;quot;&lt;/span&gt;);
        utils.stderr(r.stderr + &lt;span style="color: maroon"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;);
    } &lt;span style="color: blue"&gt;else &lt;/span&gt;{
        utils.stdout(&lt;span style="color: maroon"&gt;&amp;quot;done.\n&amp;quot;&lt;/span&gt;);
    }
}));&lt;/pre&gt;

&lt;p&gt;以上代码片段出自&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/scripts/build-prod.js"&gt;生产环境的Jscex发布脚本&lt;/a&gt;，可见有了Jscex之后，“阻塞”式地exec外部调用也完全不是问题。可以说，使用Jscex，可以基本解决Node.js代替编写Shell脚本的编程习惯或是风格问题，也欢迎大家多多尝试这种方法，并多多反馈，有问题及时发布在GitHub的Issues页面中。&lt;/p&gt;

&lt;p&gt;至于Jscex的0.7.0版本，目前的计划是使用一个合适的JavaScript语法分析器来替换并统一UglifyJS和Narcissus的分析器。UglifyJS的分析器提供的信息太少，而Narcissus则实现地十分不靠谱，例如它连\r\n这种换行符都不支持，此外它还自做主张地将module作为关键字，这对来说Node.js是个很大的麻烦，因此其实目前Jscex的预编译器使用的是经过少许修改的Narcissus语法分析器。在0.7.0版本中，我希望能从语法分析器中得到更多信息，这样便可以引入Source Map，更进一步地支持调试。此外，在改写Jscex的过程中，详细的单元测试自然是必不可少的。&lt;/p&gt;

&lt;p&gt;正像我一开始说的那样，Jscex的0.7.0版本将会在项目功能与质量，以及专业性上有重大突破。这么做也不枉已经有600人在GitHub上关注着Jscex：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-github-watchers-20120619.png" /&gt;&lt;/p&gt;

&lt;p&gt;在Node.js的模块列表上，&lt;a href="https://github.com/joyent/node/wiki/Modules#wiki-async-flow"&gt;流程控制分类&lt;/a&gt;有80余个项目。其中关注人数最多的是&lt;a href="https://github.com/caolan/async"&gt;async&lt;/a&gt;（2444人），其次是&lt;a href="https://github.com/creationix/step"&gt;Step&lt;/a&gt;（862人），第三便是&lt;a href="https://github.com/JeffreyZhao/jscex"&gt;Jscex&lt;/a&gt;。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/06/nodejs-shell-jscex-0.6.5.html#comments</comments>
      <pubDate>Tue, 19 Jun 2012 00:12:29 GMT</pubDate>
      <lastBuildDate>Tue, 19 Jun 2012 15:21:38 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/news/">新闻信息</category>
      <category domain="http://blog.zhaojie.me/life/">生活心情</category>
      <title>两年多来第二次更新博客功能</title>
      <link>http://blog.zhaojie.me/2012/06/the-second-blog-feature-during-the-past-two-years.html</link>
      <guid>http://blog.zhaojie.me/2012/06/the-second-blog-feature-during-the-past-two-years.html</guid>
      <description>&lt;p&gt;话说两年多前，我从博客园搬到了这个独立博客，用的是自己写的最简单粗糙的博客程序。这个博客系统十分简单粗糙，连文章编辑都是在文本框里直接显示HTML，甚至没有文章删除的功能——因为我不需要。这就是这个博客系统目的，只为我一个人服务，我够用即可，但也必须能让我够用。自己写的博客系统胜在高度的订制性，我可以把握页面任何一寸角落。直到现在，我的博客程序只增加过两次功能，其他都是对于样式方面的小修小补，可见我这人是多么的不思进取。从某个角度说，这两次更新的目的是相同的，都是为了抵御垃圾回复。这少数的令人恶心的人和事，就能不成比例地占用我的精力。&lt;/p&gt;

&lt;p&gt;第一次程序更新，是为了抵御自动回复，一开始时不时会出现一条垃圾回复，遍布各篇文章。我曾经试过手动删除，但最后垃圾回复发布频率提高到10到15秒一条，我完全删不过来，一觉醒来可以满眼都是垃圾回复，令人苦恼不堪。其实说到底还是我的博客回复太过容易，一个简单的HTTP Post请求便可发布成功。我也想过增加验证码，但我不想让博客回复变得麻烦，于是最后采用的是客户端和服务器端配合进行的简单的验证。具体方式有些忘了，应该是由服务器生成的时间戳附加在文章内容上，再用MD5生成签名等等。这些步骤对用户来说都是透明的，但可以完全抵御简单的重复提交。其实只是这么一个简单的手段就完全杜绝了之前那种垃圾回复，有空我重新读下之前写的代码，整理出一篇文章出来。&lt;/p&gt;

&lt;p&gt;自动垃圾回复容易处理，但由人肉发布的垃圾回复便难以抵挡了。基本从我搬至独立博客没有多久，我的博客上就出现了一个著名的ID，强烈抵制微软各种技术。一开始我还以为这是一个业界牛人，因为他一上来就号称自己十几年前做过哪些哪些技术，列举各种名词头头是道，所以还客气地回复，一一指出他回复中错误的地方。但后来慢慢发现，这位仁兄除了列举名词似乎就没有其他的本事，抓住任何“观点”都会莫名其妙地用来黑微软，逻辑之差令人乍舌。关键是它可以如方肘子一样搬出各种“道理”，列举各种“数据”。更有趣的是，他可以做到跟肘子一样，对于各种引文选择性地采纳，即便被人指出错误也完全不予理睬，甚至完全不去做最简单地了解就来胡扯。&lt;/p&gt;

&lt;p&gt;例如，他会在Build大会没几天就主动跑上来嚷嚷，说WinRT舍弃了.NET，还加入了各种新类型，例如IIterable，IVector，IMap等等，全然不顾真相如何。其实只要看过Build大会上最简单的介绍，就能知道Win8可以说终于对.NET提供了直接支持（在他眼里，这句话就变成了我在说WinRT是.NET的一部分），使用各种API变成系统调用，无需手动映射和封装，性能也得以提高。而WinRT中如IIterable这种集合类型，完全会被自动映射为.NET中的IEnumerable，IList或是IDictionary等等，在WinRT层面上换一个名字只是因为它是一套公用的API。事实上.NET是WinRT重要组成部分，WinRT的元数据格式就是.NET程序集中元数据的描述方式，用IL Spy类似的工具甚至可以直接查看其接口（他又觉得我认为ILSpy可以看到内部实现）。如今C#真正成为了WinRT的一等公民之一（C++自然也是，但他会认为我说只有C#才是）——但这一切对他来说都没有意义。他只要不断黑，这跟方肘子的手段一样，只要有一个人看到并相信他的说法，他就赚了。&lt;/p&gt;

&lt;p&gt;我问过他是谁，是做什么的，有没有写过的文章发起过的讨论可以看看，但两年多来，他唯一透露的自己的消息便是自己有十几年经验，各种东西都懂，现在搞一些我不了解的东西，从来不做正面回应。我也建议过他去StackOverflow或Quora上问个问题，或是给出国内一些著名的博客，让他去问问那些人的看法，但他也无动于衷，留下的回复是“之前跟他们说过”，而现在“跟他们没什么可说的”。在我看来，他之所以能够孜孜不倦地主动来我这里挑事，最重要的一点便是我保证过不会拉黑，不会删除回复（除非是纯粹小广告）。&lt;/p&gt;

&lt;p&gt;我这么做的目的，本来是想留下正反两方面地说法，而不因为自己的喜好而删除回复。本来这是种自律，如果在一个大家都会自觉把握讨论基本准绳的环境中，这应该是个理想的方式，可惜现在就有人不自觉地破坏这样的环境。在互联网上的发言，其实很大程度上是在拿自己的“信誉”做筹码，但像那位仁兄一样如缩头乌龟般从头躲到尾，即便信誉破产对他也没丝毫影响。他可以随便扯出乱七八糟的“道理”，而我则需要一条一条反驳，认真查找便阅读各种案例。而他却可以肆意歪曲我说的话，甚至无中生有地解读我的行为，或是找一些文章“标题”来证明他的说法，我却要在下次仔细阅读他的“举证”，并且做进一步的解释。&lt;/p&gt;

&lt;p&gt;久而久之，我不胜其扰，但我依然不想删除回复，于是变得脾气暴躁起来，后来基本就是见他一次骂他一次。现在看来，这么做实在是十分愚蠢——因为我在不断付出我的信誉，而他却可以躲在乌龟壳后面无所畏惧。久而久之，最终损失的只能是我自己，还包括读者的体验。痛定思痛，我决定还是为博客增加一个功能，可以将某些评论自动隐藏起来，待您真心需要浏览时再登陆查看。&lt;a href="http://blog.zhaojie.me/2012/06/jscex-unit-tests-with-mocha-chai.html"&gt;上篇文章就是一则具体案例&lt;/a&gt;，本来是一篇令我感觉颇为良好的文章，却又被糟蹋了，实在令人心痛。&lt;/p&gt;

&lt;p&gt;写了这么长，我忽然意识到似乎这更多还是为了说服我自己，让我自己做这个决定时心理可以更踏实一些。虽然开发了这个功能，但我还是希望可以尽可能地少用，毕竟它还是可以算是开了一个坏头。幸运的是，从历史上看似乎也只有那位仁兄的回复需要受此特殊待遇了。看到便隐藏，眼不见为净。&lt;/p&gt;

&lt;p&gt;只为一个人而开发一个功能，我也算是够给那位仁兄面子了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更新：&lt;/strong&gt;刚才趁在公司里下班前的时间，把那位同学的内容以及相关对话都隐藏了。看着当时大段大段客客气气的回复，让我感觉自己之前浪费了那么多时间。这些文字加起来至少也有几十篇长文，如果我能把那些时间利用起来，Jscex的文档早就完成了。愚蠢啊，我真他妈的的愚蠢。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/06/the-second-blog-feature-during-the-past-two-years.html#comments</comments>
      <pubDate>Mon, 18 Jun 2012 00:08:27 GMT</pubDate>
      <lastBuildDate>Mon, 10 Dec 2012 17:25:34 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <title>Jscex单元测试：喝着咖啡品着茶</title>
      <link>http://blog.zhaojie.me/2012/06/jscex-unit-tests-with-mocha-chai.html</link>
      <guid>http://blog.zhaojie.me/2012/06/jscex-unit-tests-with-mocha-chai.html</guid>
      <description>&lt;p&gt;这段时间在香港出差，跟高帅富们一起工作。高帅富的办公室免费供应咖啡，放在壶里随你倒。茶叶也一样，立顿普洱茉莉自取。于是乎我每天也会喝一两杯提提神，尤其是午饭后，感觉还不错。技术人员似乎都挺热衷于这些饮料，也喜欢拿饮料来为项目取名，这方面最让人想到的例子估计就是Java了。这几天我为&lt;a href="http://jscex.info/zh-cn/"&gt;Jscex&lt;/a&gt;整理代码，准备发布其0.6.5版本，并为0.7.0做准备。这方面的主要工作之一便是为Jscex补充尽可能完整的单元测试。&lt;/p&gt;

&lt;h1&gt;Jscex的单元测试&lt;/h1&gt;

&lt;p&gt;我很喜欢单元测试，在目前工作的项目里，绝大部分的单元测试都是我写的，几乎每提交一个功能或修改一个Bug都会补上配套的单元测试。有人说编写单元测试会降低开发的速度，但我倒觉得，如果没有单元测试这种可以验证程序正确性的代码片段，难道每次都要起一个完整的系统才能观察修改效果？更别说单元测试可以减少以后来回返工的可能了，有了单元测试，无论是进行修改和提交都令人放心地很。&lt;/p&gt;

&lt;p&gt;而且作为程序员来说，看到这样的界面难道不会让您感到心旷神怡吗？&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/0.png" target="_blank"&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/0.png" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而Jscex作为一个可以同时在浏览器和Node.js里运行的JavaScript类库，自然也是需要&lt;a title="Jscex单元测试" href="http://repository.jscex.info/master/tests/jscex/runner.html" data-popup-height="405" data-popup-width="720" data-popup="iframe"&gt;在浏览器里运行单元测试的&lt;/a&gt;。当然Jscex单元测试不光如此，还有一些“高级模式”用来测试不同加载环境下的支持情况。&lt;/p&gt;

&lt;h1&gt;咖啡和茶&lt;/h1&gt;

&lt;p&gt;虽然理论上不一定，但既然要同时在Node.js和浏览器里进行测试，那么很自然的选择便是使用同时支持两者的单元测试工具。Jscex使用&lt;a href="http://visionmedia.github.com/mocha/"&gt;Mocha&lt;/a&gt;作为单元测试框架，并使用&lt;a href="http://chaijs.com/"&gt;Chai&lt;/a&gt;作为断言类库——真可谓一边喝咖啡一边品茶。之前我用过一段时间的&lt;a href="https://github.com/visionmedia/should.js"&gt;should.js&lt;/a&gt;，但它不支持浏览器，更重要的是它的作者说“&lt;a href="https://github.com/visionmedia/should.js/issues/26#issuecomment-3386344"&gt;有Chai所以就不做浏览器支持了&lt;/a&gt;”让我稍觉不爽，因此全面切换为Chai。不过平心而论，should.js相比Chai还是有其优势，例如它对于错误的描述更为详细，而Chai的优势主要是&lt;a href="http://chaijs.com/api/"&gt;支持各种断言形式&lt;/a&gt;，而should.js显然只支持一种。&lt;/p&gt;

&lt;p&gt;Mocha可以搭配任何断言类库使用，它只关注测试过程中有没有抛出异常，而Chai只关注各种断言API，并再断言失败的时候抛出异常。在Node.js中使用这两个组件基本只需require进来：&lt;/p&gt;

&lt;pre class="code"&gt;require(&lt;span style="color: maroon"&gt;&amp;quot;chai&amp;quot;&lt;/span&gt;).should();

describe(&lt;span style="color: maroon"&gt;&amp;quot;Jscex&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
    it(&lt;span style="color: maroon"&gt;&amp;quot;should be powerful for asynchronous programming&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
        ...
    });

    ... more tests ...
});

... more tests ...&lt;/pre&gt;

&lt;p&gt;这里连Mocha的组件就不需要，因为在Node.js环境下，Mocha更像是一个“执行环境”，我们在安装了Mocha之后，会使用mocha命令，而不是node命令执行测试脚本：&lt;/p&gt;

&lt;pre class="code"&gt;$ [sudo] npm install -g mocha
...

$ mocha your-tests.js&lt;/pre&gt;

&lt;p&gt;这样Mocha就会执行脚本里定义的所有测试，并告诉我们执行结果。Mocha支持许多输出模式，例如上图便使用了spec模式，它的输出就好像一份规约文档。不过一般开发时我会使用默认的“简约”模式，它只会告诉我们哪些单元测试没有通过。&lt;/p&gt;

&lt;p&gt;而在浏览器里使用Mocha和Chai就略显麻烦一些了：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;html&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;head&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;meta &lt;/span&gt;&lt;span style="color: red"&gt;charset&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;title&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;&lt;/span&gt;Unit Testing with Mocha and Chai&lt;span style="color: blue"&gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;title&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    
    &lt;/span&gt;&lt;span style="color: #006400"&gt;&amp;lt;!-- Mocha --&amp;gt;
    &lt;/span&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;link &lt;/span&gt;&lt;span style="color: red"&gt;rel&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;stylesheet&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;href&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;mocha.css&amp;quot; /&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script &lt;/span&gt;&lt;span style="color: red"&gt;src&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;mocha.js&amp;quot;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;&lt;/span&gt;mocha.setup(&lt;span style="color: maroon"&gt;'bdd'&lt;/span&gt;);&lt;span style="color: blue"&gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    
    &lt;/span&gt;&lt;span style="color: #006400"&gt;&amp;lt;!-- Chai --&amp;gt;
    &lt;/span&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script &lt;/span&gt;&lt;span style="color: red"&gt;src&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;chai.js&amp;quot;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;&lt;/span&gt;chai.Should();&lt;span style="color: blue"&gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;head&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;body&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;div &lt;/span&gt;&lt;span style="color: red"&gt;id&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;mocha&amp;quot;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;div&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;

    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
        &lt;/span&gt;describe(&lt;span style="color: maroon"&gt;&amp;quot;Jscex&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
            it(&lt;span style="color: maroon"&gt;&amp;quot;should be powerful for asynchronous programming&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
                ...
            });

            ... more tests ...
        });

        ... more tests ...
    &lt;span style="color: blue"&gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;

    &amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
        &lt;/span&gt;mocha.run();
    &lt;span style="color: blue"&gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;body&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;html&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器里使用Mocha时需要额外引入一个CSS文件，并在页面上放置一个id为mocha的div。同时，我们还需要使用代码设置Mocha的单元测试模式（例如上面是BDD模式），以及Chai的断言模式（例如上面是Should模式）。使用这种方式，便能得到一张漂亮的单元测试页面，它甚至可以查看当前测试的代码：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/1.png" target="_blank"&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/1.png" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;真是多亏了JavaScript函数上的toString方法，才能出现像Mocha和Jscex这种酷到爆的东西。&lt;/p&gt;

&lt;h1&gt;测试代码结构&lt;/h1&gt;

&lt;p&gt;可以发现，两种环境里单元测试的定义方式是一样的，唯一的区别只是两个不同的执行方式，因此我们需要将所有的单元测试定义独立出来。例如在Jscex里，单元测试就是定义在独立的tests.js里的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;exports = (&lt;span style="color: blue"&gt;typeof &lt;/span&gt;window === &lt;span style="color: maroon"&gt;&amp;quot;undefined&amp;quot;&lt;/span&gt;) ? module.exports : window;

exports.setupTests = &lt;span style="color: blue"&gt;function &lt;/span&gt;(Jscex) {

    describe(&lt;span style="color: maroon"&gt;&amp;quot;underscore&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {

        &lt;span style="color: blue"&gt;var &lt;/span&gt;_ = Jscex._;

        describe(&lt;span style="color: maroon"&gt;&amp;quot;isArray&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
        
            it(&lt;span style="color: maroon"&gt;&amp;quot;should return true for array&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
                _.isArray([]).should.equal(&lt;span style="color: blue"&gt;true&lt;/span&gt;);
            });
            
            it(&lt;span style="color: maroon"&gt;&amp;quot;should return false for others&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() {
                _.isArray(&lt;span style="color: maroon"&gt;&amp;quot;&amp;quot;&lt;/span&gt;).should.equal(&lt;span style="color: blue"&gt;false&lt;/span&gt;);
                _.isArray(1).should.equal(&lt;span style="color: blue"&gt;false&lt;/span&gt;);
                _.isArray({}).should.equal(&lt;span style="color: blue"&gt;false&lt;/span&gt;);
            }); 
        });

        ... more tests ...
    });

    ... more tests ...
});&lt;/pre&gt;

&lt;p&gt;这个文件会根据环境将setupTests方法定义在window对象或是exports对象上，于是就可以共享给Node.js和浏览器执行。例如在Node.js里：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;Jscex = require(&lt;span style="color: maroon"&gt;&amp;quot;../../src/jscex&amp;quot;&lt;/span&gt;);
require(&lt;span style="color: maroon"&gt;&amp;quot;chai&amp;quot;&lt;/span&gt;).should();
require(&lt;span style="color: maroon"&gt;&amp;quot;./tests&amp;quot;&lt;/span&gt;).setupTests(Jscex);&lt;/pre&gt;

&lt;p&gt;而在浏览器里便可以：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script &lt;/span&gt;&lt;span style="color: red"&gt;src&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;../../src/jscex.js&amp;quot;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script &lt;/span&gt;&lt;span style="color: red"&gt;src&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;tests.js&amp;quot;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;

&amp;lt;&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &lt;/span&gt;window.setupTests(Jscex);
    mocha.run();
&lt;span style="color: blue"&gt;&amp;lt;/&lt;/span&gt;&lt;span style="color: maroon"&gt;script&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;于是乎，我就能随时知道两个环境里单元测试的执行情况了。&lt;/p&gt;

&lt;h1&gt;高级单元测试模式&lt;/h1&gt;

&lt;p&gt;Jscex的单元测试的时候还有一些特殊需求：Jscex内置对某些包加载器的支持，这部分代码需要在不同环境里测试，例如“&lt;a title="普通浏览器" href="http://repository.jscex.info/master/tests/jscex/env/browser.html" data-popup-height="405" data-popup-width="720" data-popup="iframe"&gt;普通浏览器环境&lt;/a&gt;”以及“&lt;a title="AMD" href="http://repository.jscex.info/master/tests/jscex/env/amd.html" data-popup-height="405" data-popup-width="720" data-popup="iframe"&gt;AMD环境&lt;/a&gt;”。&lt;/p&gt;

&lt;p&gt;测试包加载器有个特别的地方，因为无论是在哪个环境，在使用过程中脚本都只会加载一次，都只会产生一个Jscex对象。如果不同的测试用例都针对同一个Jscex对象则容易相互影响，这便是副作用的麻烦之处。在一个标准的单元测试框架中，总有机会可以设置SetUp和TearDown函数，会在每个测试用例执行前后调用，Mocha也不例外。例如在&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/tests/jscex/env/browser.html"&gt;普通浏览器的测试&lt;/a&gt;中，我便定义了这样一个beforeEach操作：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;Jscex;

beforeEach(&lt;span style="color: blue"&gt;function &lt;/span&gt;(done) {
    &lt;span style="color: blue"&gt;delete &lt;/span&gt;Jscex;
    loadScript(&lt;span style="color: maroon"&gt;&amp;quot;../../../src/jscex.js&amp;quot;&lt;/span&gt;, done);
});&lt;/pre&gt;

&lt;p&gt;beforeEach操作会在每个测试案例执行之前运行，这是一个异步操作——JavaScript是一门离不开异步的语言，因此Mocha对于异步的单元测试有很好的支持，例如我们可以选择性地调用done函数来表示测试结束。一不小心忘了调用done也没有关系，因为Mocha会为每个操作设定一个超时时间，十分友好。在上面的beforeEach里，我们删除Jscex根对象，并重新加载Jscex脚本（这里用到我写的一个简单的&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/tools/script-loader.js"&gt;loadScript辅助方法&lt;/a&gt;）。加载Jscex之后则又会在window上出现一个全新的Jscex根对象。&lt;/p&gt;

&lt;p&gt;不过问题又来了，Jscex是我写的，出现哪些根对象我自然清楚明白，但如果是第三方的脚本，难道要完全解读其实现，了解它在window上定义了哪些成员才行吗？事实上，我们有个十分容易的“探测”方法，这里又得为伟大的Mocha框架记下一功。&lt;/p&gt;

&lt;p&gt;Mocha框架为开发人员考虑了很多，例如在开发JavaScript程序时，一个拼写错误很容易在根对象上留下一个成员（这种情况在&lt;a href="http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/"&gt;ECMAScript 5的Strict Mode&lt;/a&gt;下会有所好转）。此时程序可能执行也很正常，但一旦出现问题便会很难找出原因。但Mocha有一个很贴心的功能便是在测试用例执行前后比较根对象上是否出现了额外的成员，一旦出现这种情况便会告诉我们出现了“泄露”。例如：&lt;/p&gt;

&lt;pre class="code"&gt;beforeEach(&lt;span style="color: blue"&gt;function &lt;/span&gt;(done) {
    loadScript(&lt;span style="color: maroon"&gt;&amp;quot;require.js&amp;quot;&lt;/span&gt;, done);
});

it(&lt;span style="color: maroon"&gt;&amp;quot;should tell us the global members&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() { });&lt;/pre&gt;

&lt;p&gt;这个beforeEach操作会加载&lt;a href="http://requirejs.org/"&gt;RequreJS&lt;/a&gt;的脚本，它会在根对象上添加多个成员，而执行后会告诉我们检测到哪些泄露：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/2.png" target="_blank"&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/2.png" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;例如这里我们知道泄露了requirejs，require和define三个成员。知道以后那就好办多了，补充几行代码即可：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;requirejs;
&lt;span style="color: blue"&gt;var &lt;/span&gt;require;
&lt;span style="color: blue"&gt;var &lt;/span&gt;define;

beforeEach(&lt;span style="color: blue"&gt;function &lt;/span&gt;(done) {
    &lt;span style="color: blue"&gt;delete &lt;/span&gt;requirejs;
    &lt;span style="color: blue"&gt;delete &lt;/span&gt;require;
    &lt;span style="color: blue"&gt;delete &lt;/span&gt;define;

    loadScript(&lt;span style="color: maroon"&gt;&amp;quot;require.js&amp;quot;&lt;/span&gt;, done);
});&lt;/pre&gt;

&lt;p&gt;我们只要在Mocha执行测试前先定义几个成员，在加载require.js之前删除，让它再定义回来，这样就能“骗”过Mocha了。剩下的便是编写各种异步的单元测试，Mocha对此支持的很好，例如在&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/tests/jscex/env/amd.html"&gt;AMD环境下的单元测试&lt;/a&gt;中：&lt;/p&gt;

&lt;pre class="code"&gt;it(&lt;span style="color: maroon"&gt;&amp;quot;should support complicated module&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;(done) {
    require([&lt;span style="color: maroon"&gt;'jscex'&lt;/span&gt;], &lt;span style="color: blue"&gt;function &lt;/span&gt;(Jscex) {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;loaded = [];
        define(&lt;span style="color: maroon"&gt;&amp;quot;jscex-m0&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() { &lt;span style="color: blue"&gt;return &lt;/span&gt;{ init: &lt;span style="color: blue"&gt;function &lt;/span&gt;() { loaded.push(&lt;span style="color: maroon"&gt;&amp;quot;m0&amp;quot;&lt;/span&gt;); } }; });
        define(&lt;span style="color: maroon"&gt;&amp;quot;jscex-m1&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;function &lt;/span&gt;() { &lt;span style="color: blue"&gt;return &lt;/span&gt;{ init: &lt;span style="color: blue"&gt;function &lt;/span&gt;() { loaded.push(&lt;span style="color: maroon"&gt;&amp;quot;m1&amp;quot;&lt;/span&gt;); } }; });

        Jscex.coreVersion = &lt;span style="color: maroon"&gt;&amp;quot;0.5.0&amp;quot;&lt;/span&gt;;
        Jscex.modules[&lt;span style="color: maroon"&gt;&amp;quot;d0&amp;quot;&lt;/span&gt;] = &lt;span style="color: maroon"&gt;&amp;quot;0.1.0&amp;quot;&lt;/span&gt;;
        Jscex.modules[&lt;span style="color: maroon"&gt;&amp;quot;d1&amp;quot;&lt;/span&gt;] = &lt;span style="color: maroon"&gt;&amp;quot;0.2.5&amp;quot;&lt;/span&gt;;

        Jscex.define({
            name: &lt;span style="color: maroon"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;,
            version: &lt;span style="color: maroon"&gt;&amp;quot;0.8.0&amp;quot;&lt;/span&gt;,
            autoloads: [&lt;span style="color: maroon"&gt;&amp;quot;m0&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;m1&amp;quot;&lt;/span&gt;],
            dependencies: {
                &lt;span style="color: maroon"&gt;&amp;quot;core&amp;quot;&lt;/span&gt;: &lt;span style="color: maroon"&gt;&amp;quot;~0.5.0&amp;quot;&lt;/span&gt;,
                &lt;span style="color: maroon"&gt;&amp;quot;d0&amp;quot;&lt;/span&gt;: &lt;span style="color: maroon"&gt;&amp;quot;~0.1.0&amp;quot;&lt;/span&gt;,
                &lt;span style="color: maroon"&gt;&amp;quot;d1&amp;quot;&lt;/span&gt;: &lt;span style="color: maroon"&gt;&amp;quot;~0.2.0&amp;quot;
            &lt;/span&gt;},
            init: &lt;span style="color: blue"&gt;function &lt;/span&gt;(root) {
                root.hello = &lt;span style="color: maroon"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;;
            }
        });

        require([&lt;span style="color: maroon"&gt;&amp;quot;jscex-test&amp;quot;&lt;/span&gt;], &lt;span style="color: blue"&gt;function &lt;/span&gt;(test) {
            loaded.should.be.empty;

            test.init(Jscex);

            loaded.should.eql([&lt;span style="color: maroon"&gt;&amp;quot;m0&amp;quot;&lt;/span&gt;, &lt;span style="color: maroon"&gt;&amp;quot;m1&amp;quot;&lt;/span&gt;]);
            Jscex.hello.should.equal(&lt;span style="color: maroon"&gt;&amp;quot;world&amp;quot;&lt;/span&gt;);
            Jscex.modules[&lt;span style="color: maroon"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;] = &lt;span style="color: maroon"&gt;&amp;quot;0.8.0&amp;quot;&lt;/span&gt;;

            done();
        });
    });
});&lt;/pre&gt;

&lt;p&gt;写完单元测试之后，我会感到自己是一个非常专业的程序员，突然就有了强烈的码农自豪感和自尊心。当然，Jscex的单元测试之路还很长，不过基础已经打好，剩下的就是要靠自己把握了。&lt;/p&gt;

&lt;h1&gt;无关的事情&lt;/h1&gt;

&lt;p&gt;最后再说两件无关的事情，一是上周末&lt;a href="https://twitter.com/audreyt/status/211519510446997505"&gt;Jscex得到了大名鼎鼎的唐凤大侠的肯定&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/3.png" target="_blank"&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/3.png" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;二是给自己新订了一个玩具，离香港近就是这点好：&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/4.png" target="_blank"&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-unit-tests-with-mocha-chai/4.png" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;正所谓“顶配解千愁”，古之人不余欺也。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/06/jscex-unit-tests-with-mocha-chai.html#comments</comments>
      <pubDate>Wed, 13 Jun 2012 00:47:24 GMT</pubDate>
      <lastBuildDate>Wed, 13 Jun 2012 10:49:24 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <title>Jscex预编译器及其DocPad插件</title>
      <link>http://blog.zhaojie.me/2012/06/jscex-pre-complier-and-docpad-plugin.html</link>
      <guid>http://blog.zhaojie.me/2012/06/jscex-pre-complier-and-docpad-plugin.html</guid>
      <description>&lt;p&gt;需求本身会是最好的动力。上个周末除了忙于构建&lt;a href="http://jscex.info/"&gt;Jscex主站&lt;/a&gt;以外，我还重新整理了Jscex的预编译器——或者说是AOT编译器。Jscex自带一个JIT编译器，配合eval可以在开发时避免额外的编译过程，这也可以说是Jscex的亮点之一。不过对于线上环境，一般都还是建议进行预编译，也就是将Jscex方法定义直接替换为目标代码。这么做的好处主要是为了降低部署时的脚本体积（摆脱对编译器的依赖所有代码加起来不到4KB），或是让异常情况下的错误定位变得容易（主要面向Node.js生产环境）。此外，为了便于编写文档，我还为DocPad开发了一个插件，用于对Jscex脚本进行预编译。&lt;/p&gt;

&lt;p&gt;与其他Jscex的包不同，Jscex预编译器的定位不是一个Jscex模块，而是一个独立的工具。因此，它的第一种使用方式是作为一个命令：&lt;/p&gt;

&lt;pre class="code"&gt;&amp;gt; &lt;strong&gt;npm install jscexc&lt;/strong&gt;
...

&amp;gt; &lt;strong&gt;node node_modules/jscexc&lt;/strong&gt;
Usage: node ./node_modules/jscexc --input &amp;lt;input_file&amp;gt; --output &amp;lt;output_file&amp;gt;

Options:
  --input, -i   The input file   [required]
  --output, -o  The output file  [required]

Missing required arguments: input, output&lt;/pre&gt;

&lt;p&gt;但其实最好是将这个包构造为一个可以直接执行的命令，但我还不是还不是很清楚如何让它像mocha那样同时支持Windows和*nix，所以暂时还没去实现。等搞定这个问题之后，就可以像下面这样使用jscexc命令了：&lt;/p&gt;

&lt;pre class="code"&gt;&amp;gt; &lt;strong&gt;[sudo] npm -g install jscexc&lt;/strong&gt;
...

&amp;gt; &lt;strong&gt;jscexc --input test.js --output test.aot.js&lt;/strong&gt;&lt;/pre&gt;

&lt;p&gt;于是这样便能将test.js的内容转化为test.aot.js，其中的Jscex方法定义都会被直接替换成目标代码。&lt;/p&gt;

&lt;p&gt;这么做便达到了预编译的效果，但Jscex预编译器同样可以当作模块使用。例如，我在编写首页示例的时候，我就利用DocPad提供的插件机制，直接将*.jscex文件经过预编译，转化为最终的JavaScript代码：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: green"&gt;# Export Plugin&lt;/span&gt;
module.exports = (BasePlugin) -&amp;gt;
    &lt;span style="color: green"&gt;# Define Plugin&lt;/span&gt;
    &lt;span style="color: blue"&gt;class&lt;/span&gt; JscexcPlugin &lt;span style="color: blue"&gt;extends&lt;/span&gt; BasePlugin
        name: &lt;span style="color: darkred"&gt;&amp;quot;jscexc&amp;quot;&lt;/span&gt;
        
        &lt;span style="color: green"&gt;# Render some content&lt;/span&gt;
        render: (opts, next) -&amp;gt;
            &lt;span style="color: green"&gt;# Prepare&lt;/span&gt;
            {inExtension, outExtension, templateData, file} = opts

            &lt;span style="color: green"&gt;# Check extensions&lt;/span&gt;
            &lt;span style="color: blue"&gt;if&lt;/span&gt; inExtension &lt;span style="color: blue"&gt;in&lt;/span&gt; [&lt;span style="color: darkred"&gt;&amp;quot;jscex&amp;quot;&lt;/span&gt;] &lt;span style="color: blue"&gt;and&lt;/span&gt; outExtension &lt;span style="color: blue"&gt;in&lt;/span&gt; [&lt;span style="color: darkred"&gt;&amp;quot;js&amp;quot;&lt;/span&gt;]
                &lt;span style="color: green"&gt;# Requires&lt;/span&gt;
                jscexc = require(&lt;span style="color: darkred"&gt;&amp;quot;jscexc&amp;quot;&lt;/span&gt;)

                &lt;span style="color: green"&gt;# Render&lt;/span&gt;
                opts.content = jscexc.compile(opts.content)

            &lt;span style="color: green"&gt;# Done, return back to DocPad&lt;/span&gt;
            &lt;span style="color: blue"&gt;return&lt;/span&gt; next()&lt;/pre&gt;

&lt;p&gt;虽然docpad-plugins-jscexc插件使用CoffeeScript编写，但看懂这段代码应该不成问题。总体而言，就是在需要的时候（这里是将*.jscex文件转化为*.js文件）把jscexc当作模块引入进来，再调用它的compile方法，任何Node.js文件都能这么使用jscexc包。现在，我在使用DocPad编写文档示例的时候，只要&lt;a href="https://github.com/JeffreyZhao/jscex/blob/master/doc/src/documents/scripts/sorting-animations.js.jscex"&gt;直接编写Jscex代码&lt;/a&gt;，DocPad会&lt;a href="https://github.com/jscex/jscex.github.com/blob/master/scripts/sorting-animations.js"&gt;自动生成其目标内容&lt;/a&gt;，而在页面上只需要引入&lt;a href="https://github.com/jscex/jscex.github.com/blob/master/scripts/jscex-async.bundle.min.js"&gt;最基本的Jscex异步类库&lt;/a&gt;即可，非常方便。&lt;/p&gt;

&lt;p&gt;当然也有一些已知问题，例如输入文件的换行符必须是Unix下的\n而不能是Windows下的\n\r，这问题到不大，使用dos2unix或者随便哪个文本编辑器都能轻松搞定（当然我还是会修复这个问题的）。还有同学汇报说不能使用module语句——Jscex预编译器为了尽可能保留输入文件的内容，于是使用了能提供更多信息的&lt;a href="https://github.com/mozilla/narcissus"&gt;Narcissus&lt;/a&gt;分析器，可惜它实在太自作多情了一些，把module当作保留字了，所以我对Narcissus Parser做了简单的修补，也算是绕过了这个问题。&lt;/p&gt;

&lt;p&gt;总有天我会换掉这个中看不中用的Narcissus分析器，例如&lt;a href="http://esprima.org/"&gt;Esprima&lt;/a&gt;似乎就挺不错的，而且实在不行就自己写一个。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/06/jscex-pre-complier-and-docpad-plugin.html#comments</comments>
      <pubDate>Mon, 04 Jun 2012 22:34:22 GMT</pubDate>
      <lastBuildDate>Mon, 04 Jun 2012 23:26:32 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/front-end/">前端表现</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <category domain="http://blog.zhaojie.me/news/">新闻信息</category>
      <title>Jscex疯狂周末</title>
      <link>http://blog.zhaojie.me/2012/06/jscex-weekend.html</link>
      <guid>http://blog.zhaojie.me/2012/06/jscex-weekend.html</guid>
      <description>&lt;p&gt;这是个&lt;a href="https://github.com/JeffreyZhao/jscex"&gt;Jscex&lt;/a&gt;疯狂周末。从周五下班开始直到现在，我可谓一心扑在Jscex上——当然，早茶还是要的，健身房还是去的，买菜做饭拖地也是必不可少，但剩余时间基本都贡献给Jscex了。这段时间里，我研究了一些静态站点生成机制，并最后决定使用&lt;a href="https://github.com/bevry/docpad"&gt;DocPad&lt;/a&gt;编写Jscex的文档站。然后便是捣鼓各种页面，重新编写快速入门示例等等。自然，还要它部署到&lt;a href="http://pages.github.com/"&gt;GitHub Pages&lt;/a&gt;上，并启用&lt;a href="http://jscex.info/"&gt;jscex.info&lt;/a&gt;域名，还因为GoDaddy的域名服务器总是被墙，又把DNS解析交给了&lt;a href="https://www.dnspod.cn/"&gt;DNSPod&lt;/a&gt;。现在&lt;a href="http://jscex.info/zh-cn/"&gt;Jscex主站&lt;/a&gt;看上去是不是像样多了？&lt;/p&gt;

&lt;p&gt;&lt;a href="http://img.zhaojie.me/blog/jscex-homepage-20120604.png" alt="Jscex 新首页"&gt;&lt;img src="http://img.zhaojie.me/blog/jscex-homepage-20120604.png" width="450" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个版式自然不是我设计的，我只是直接使用了&lt;a href="http://jeffreyzhao.github.com/jscex/"&gt;GitHub的项目页的某个模板&lt;/a&gt;。这个纯静态页只需要一个CSS文件，修改使用都很容易，所以您会发现其实我在页面右上角还增加了一个链接，为此我还画了一个图标，绝对是参考着GitHub的New Repository图标，用Paint.NET一个个像素描出来的（当然如果您有更好的图标也欢迎推荐给我）。&lt;/p&gt;

&lt;p&gt;我还重写了首页快速入门的示例：我一直很喜欢排序动画这个示例，因为其实冒泡排序的算法很简单，但即便如此简单的逻辑同样很难写成动画，可以充分体现“异步编程之殇”。可惜之前有朋友说这个示例还是有些复杂，因此我换成了&lt;a href="http://en.wikipedia.org/wiki/Fibonacci_number"&gt;菲薄纳契数列&lt;/a&gt;，但现在又觉得太无趣。在新的快速入门中，用户可以直接体验排序动画的演示效果，我觉得应该能用这种“趣味性”来弥补少许的“复杂度”——快去尝试一下吧。&lt;/p&gt;

&lt;p&gt;以前的文档和示例还没有完全迁移过去，接下来要逐渐丰富主站的内容。&lt;/p&gt;

&lt;p&gt;如果您对Jscex的发展有什么建议，也及时告诉我，或者您正在使用Jscex也一样，我最近会汇集一下Jscex的使用案例，打算放在主站上。对了，Jscex基金里也已经累计了超过6000元钱呢！&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/06/jscex-weekend.html#comments</comments>
      <pubDate>Sun, 03 Jun 2012 23:39:44 GMT</pubDate>
      <lastBuildDate>Mon, 04 Jun 2012 10:42:47 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>C#的设计缺陷（2）：不能以void作为泛型参数</title>
      <link>http://blog.zhaojie.me/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html</link>
      <guid>http://blog.zhaojie.me/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html</guid>
      <description>&lt;p&gt;&lt;a href="http://blog.zhaojie.me/2012/05/csharp-design-flaws-1-explicitly-implement-interface-event.html" target="_blank"&gt;上一篇文章&lt;/a&gt;里我谈了C#中“显示实现接口事件”的限制（不过似乎有点打歪了），这一篇我们换个话题，再来谈泛型方面的限制。相对于Java的假泛型（编译型泛型，类型擦除）来说，真泛型是.NET的一个亮点。Anders Heisenberg多次提到.NET的真泛型有利于编程语言的进一步发展，可以带来更丰富的编程模型。不过.NET支持的泛型是一方面，具体到语言本身则又涉及到编译器的实现，而编译器的实现又收到运行时的限制等等，所以要谈语言的设计缺陷的“原因”就会变得很复杂。不过这里我们就把C#作为一个“成品”来对待，谈下它不允许以void作为泛型参数的“后果”，“原因”则略为一提，不做深究。&lt;/p&gt;

&lt;h1&gt;泛型的限制&lt;/h1&gt;

&lt;p&gt;话说C#中泛型是很常用的特性，很多朋友都应该遇到过一些这方面令您不爽的地方。例如，为什么在定义泛型成员的时候，泛型参数T不能限制为Enum（枚举）或Delegate（委托）；还有例如，为什么可以限制T存在没有参数的构造函数，但为什么不能指定它有特定参数的构造函数呢？其实很多时候并非是这么做没价值或者做不到，而是如Eric Lippert（咦，怎么老是你）&lt;a href="http://stackoverflow.com/questions/1331739/enum-type-constraints-in-c-sharp#1331811" target="_blank"&gt;在被问及为什么不支持Enum限制时提到的那样&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;As I'm fond of pointing out, ALL features are unimplemented until someone designs, specs, implements, tests, documents and ships the feature. So far, no one has done that for this one. There's no particularly unusual reason why not; we have lots of other things to do, limited budgets, and this one has never made it past the &amp;quot;wouldn't this be nice?&amp;quot; discussion in the language design team.&lt;/p&gt;

  &lt;p&gt;I can see that there are a few decent usage cases, but none of them are so compelling that we'd do this work rather than one of the hundreds of other features that are much more frequently requested, or have more compelling and farther-reaching usage cases. (If we're going to muck with this code, I'd personally prioritize delegate constraints way, way above enum constraints.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总而言之就是：“有更重要的事情要做啦！”所以我在上一篇文章里也谈过，有些东西虽说可能只是小改动，但可能也再也不会实现了。&lt;/p&gt;

&lt;h1&gt;void不能作为泛型参数&lt;/h1&gt;

&lt;p&gt;不过有些问题的确只是些容易绕过的小问题，但我这次要谈的问题造成的麻烦则要大得多：您有没有试过使用void作为泛型类型？有没有想过，假如可以使用void作为泛型参数，会对开发有什么影响？&lt;/p&gt;

&lt;p&gt;首先，我们就不需要Func和Action两套委托类型了，因为Func&amp;lt;T&lt;sub&gt;1&lt;/sub&gt;, T&lt;sub&gt;2&lt;/sub&gt;, ..., T&lt;sub&gt;N&lt;/sub&gt;, void&amp;gt;已经能够代替Action&amp;lt;T&lt;sub&gt;1&lt;/sub&gt;, T&lt;sub&gt;2&lt;/sub&gt;, ..., T&lt;sub&gt;N&lt;/sub&gt;&amp;gt;。然后更进一步，很多API就无需写“两套”了——不过真的只要写两套吗？且看Task和Task&amp;lt;TResult&amp;gt;两个类型的ContinueWith重载吧：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task
&lt;/span&gt;{
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt; ContinueWith&amp;lt;TResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;, TResult&amp;gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt; ContinueWith&amp;lt;TResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;, TResult&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt; ContinueWith&amp;lt;TResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;, TResult&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt; ContinueWith&amp;lt;TResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;, TResult&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt; ContinueWith&amp;lt;TResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;, TResult&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
}

&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt; : &lt;span style="color: #2b91af"&gt;Task
&lt;/span&gt;{
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;&amp;gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; ContinueWith&amp;lt;TNewResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, TNewResult&amp;gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; ContinueWith&amp;lt;TNewResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, TNewResult&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; ContinueWith&amp;lt;TNewResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, TNewResult&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; ContinueWith&amp;lt;TNewResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, TNewResult&amp;gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;ContinueWith(&lt;span style="color: #2b91af"&gt;Action&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
    &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; ContinueWith&amp;lt;TNewResult&amp;gt;(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, TNewResult&amp;gt;, &lt;span style="color: #2b91af"&gt;CancellationToken&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskContinuationOptions&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;TaskScheduler&lt;/span&gt;);
}&lt;/pre&gt;

&lt;p&gt;首先，如果Task&amp;lt;void&amp;gt;可以代替Task，则已然消灭了其中一半重载。其次，如果可以用Func&amp;lt;Task&amp;lt;TResult&amp;gt;, void&amp;gt;代替Action&amp;lt;Task&amp;lt;TResult&amp;gt;&amp;gt;，则其余重载又可以消减一半。因此没错，一下子就砍掉了四分之三。&lt;/p&gt;

&lt;p&gt;其实道理很简单，假如一个API重载，包括返回值和参数在内，总共有N个独立可变类型（即可以选择泛型类型T以及void，且一个参数可能就有多个可变类型），则经过“排列”之后就有2&lt;sup&gt;N&lt;/sup&gt;种可能性，每种都必须单独实现一遍，而这原本只需要一次实现就够了。例如上面的例子有两个独立可变类型TResult和TNewResult，于是需要实现的量就活活变为了4倍。&lt;/p&gt;

&lt;p&gt;这是API设计者的噩梦啊。&lt;/p&gt;

&lt;h1&gt;一则实例&lt;/h1&gt;

&lt;p&gt;例如，我最近在为Task编写一些扩展，主要是因为在没有C# 5中async/await环境下那么好的语言支持，我只能退而求其次地实现&lt;a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank"&gt;一个Promose模型&lt;/a&gt;相关的API，例如最简单的Then，我便要实现四个重载：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;Then(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;task, &lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt; successHandler);
&lt;span style="color: blue"&gt;static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;Then&amp;lt;TResult&amp;gt;(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, &lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;TResult, &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt;);
&lt;span style="color: blue"&gt;static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; Then&amp;lt;TNewResult&amp;gt;(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;, &lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt;&amp;gt;);
&lt;span style="color: blue"&gt;static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt; Then&amp;lt;TResult, TNewResult&amp;gt;(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TResult&amp;gt;, &lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;TResult, &lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;lt;TNewResult&amp;gt;&amp;gt;);&lt;/pre&gt;

&lt;p&gt;其实这四个重载做的事情都一样，唯一的区别只是在参数和返回值上各有一个可变类型（还是TResult和TNewResult），导致一个功能要实现四遍。更重要的是其内部实现：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;static &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;Then(&lt;span style="color: blue"&gt;this &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;task, &lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;Task&lt;/span&gt;&amp;gt; successHandler)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;tcs = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;TaskCompletionSource&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;object&lt;/span&gt;&amp;gt;(); &lt;span style="color: green"&gt;// 1

    &lt;/span&gt;task.ContinueWith(t =&amp;gt;
    {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(t.IsFaulted)
        {
            tcs.SetException(t.Exception.InnerExceptions);
        }
        &lt;span style="color: blue"&gt;else if &lt;/span&gt;(t.IsCanceled)
        {
            tcs.SetCanceled();
        }
        &lt;span style="color: blue"&gt;else
        &lt;/span&gt;{
            &lt;span style="color: #2b91af"&gt;Task &lt;/span&gt;nextTask;

            &lt;span style="color: blue"&gt;try
            &lt;/span&gt;{
                nextTask = successHandler(); &lt;span style="color: green"&gt;// 2
            &lt;/span&gt;}
            &lt;span style="color: blue"&gt;catch &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;Exception &lt;/span&gt;ex)
            {
                tcs.SetException(ex);
                &lt;span style="color: blue"&gt;return&lt;/span&gt;;
            }

            ExecuteAndAssign(nextTask, tcs);&lt;span style="color: green"&gt;
        &lt;/span&gt;}
    });

    &lt;span style="color: blue"&gt;return &lt;/span&gt;tcs.Task;
}&lt;/pre&gt;

&lt;p&gt;如果您关注这四个方法的实现，就会发现它们的实现几乎完全相同，可以看到的“区别”似乎只是上面标记出的两处。但事实上您会发现，由于类型上无法兼容，导致这些结构相同的代码几乎没法重用，而必须独自写一遍。这就导致了难以避免的Repeat Yourself。对于这种简单逻辑，编写四遍还能勉强接受，但如果是更复杂的逻辑，需要编写八遍呢？此时开发人员就会急切渴望更加强大的泛型系统了。&lt;/p&gt;

&lt;p&gt;至于这个问题带来的其他麻烦，例如降低了对函数式编程的支持，让一些编程模式变得复杂等等就不多谈了，会耗费许多笔墨，要引起共鸣就更不容易了……&lt;/p&gt;

&lt;h1&gt;运行时的限制&lt;/h1&gt;

&lt;p&gt;使用者方面，让泛型参数支持使用void，对于使用者来说可谓没有任何影响，因为这种“适配”都是由编译器自动完成的。即便是现在，我们在写一个委托对象的时候，也不会指定它的具体类型，编译器会根据最后是否存在返回值类决定究竟是使用Action还是Func重载。有人可能会说，那么对于一些API来说，使用void没有意义啊，例如List&amp;lt;void&amp;gt;，存放void对象？我觉得这没什么问题，让这个List只能存放System.Void类型嘛，它的确没什么意义，但其实我们现在遇到的没意义的情况也太多了，“没意义”的场景程序员自然不会去用，也不会对“有意义”的情况造成不好的影响。&lt;/p&gt;

&lt;p&gt;可惜，如今System.Void类型实在是一个特例，它是一个struct，但它存在的目的似乎只是为了支持一些反射相关的API，不能作为泛型参数——您可能会说，不能支持泛型参数类型很多啊，为什么说System.Void是个特例呢？这是因为这点是记录在&lt;a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-335.pdf" target="_blank"&gt;CLI规范（ECMA-335）&lt;/a&gt;里的，没错，的确是运行时规范：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The following kinds of type cannot be used as arguments in instantiations (of generic types or methods):&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;Byref types (e.g., System.Generic.Collection.List`1&amp;lt;string&amp;amp;&amp;gt; is invalid) &lt;/li&gt;

    &lt;li&gt;Value types that contain fields that can point into the CIL evaluation stack (e.g.,List&amp;lt;System.RuntimeArgumentHandle&amp;gt;) &lt;/li&gt;

    &lt;li&gt;&lt;font color="#ff0000"&gt;void (e.g., List&amp;lt;System.Void&amp;gt; is invalid)&lt;/font&gt; &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;您说System.Void冤不冤，其他两种都可以说是在说一类事物，但第三项完全是指名道姓来的哪。换句话说，泛型不支持void是从运行时开始就存在限制的，并非像Enum之类的只是C#语言的限制。为什么会有这种限制，运行时规范上并没有说清楚。我的猜想是规范考虑到泛型参数会作为返回值来使用，但返回System.Void类型的方法在使用时和普通没有返回值的void方法有所区别？但在我看来，既然您本身就是个虚拟机，那完全是可以适配，“适配”本身也可以是您的职责之一嘛，所以我觉得说到底这原因还是归结为一个字：“懒”。&lt;/p&gt;

&lt;p&gt;之前在微博上吐槽这问题的时候，有不少朋友纷纷表示泛型参数不能用void对生活没什么影响。可能有朋友还会奇怪为什么我会有那么多抱怨？我想说，那是因为你没有用过F#等做的好的语言啊，其他如OCaml或Haskell就先不谈了，但F#与C#一样也是一门构建在.NET平台上的语言，它的泛型设计和实现就为C#做出了很好的榜样。不了解也就没抱怨，这情况见的多了。&lt;/p&gt;

&lt;p&gt;至于F#是怎么回避System.Void不能作为泛型参数的问题，简单地说就是它使用了自定义的FSharpVoid类型。很显然这不会被C#承认，对互操作不利。这也没办法，谁让这问题出在运行时上呢。在运行时的限制面前，编译器真的无能为力。&lt;/p&gt;

&lt;h1&gt;相关文章&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="http://blog.zhaojie.me/2012/05/csharp-design-flaws-1-explicitly-implement-interface-event.html" target="_blank"&gt;C#的设计缺陷（1）：显式实现接口内的事件&lt;/a&gt; &lt;/li&gt;

  &lt;li&gt;C#的设计缺陷（2）：不能以void作为泛型参数 &lt;/li&gt;
&lt;/ul&gt;</description>
      <comments>http://blog.zhaojie.me/2012/05/csharp-design-flaws-2-cannot-use-void-as-generic-type-parameter.html#comments</comments>
      <pubDate>Mon, 28 May 2012 12:27:24 GMT</pubDate>
      <lastBuildDate>Wed, 13 Jun 2012 00:54:09 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/language/">语言编程</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>C#的设计缺陷（1）：显式实现接口内的事件</title>
      <link>http://blog.zhaojie.me/2012/05/csharp-design-flaws-1-explicitly-implement-interface-event.html</link>
      <guid>http://blog.zhaojie.me/2012/05/csharp-design-flaws-1-explicitly-implement-interface-event.html</guid>
      <description>&lt;p&gt;其实使用C#这么多年，我时不时会遇到一些令人不爽的设计缺陷。这些缺陷大都是些限制，虽说无伤大雅，也很容易避免，但一旦遇到这些情况，总会令人心生不快，毕竟都是些无谓的限制。而且令人遗憾的是，虽说去除这些限制也不会带来什么问题，但我认为C#设计团队也基本不会去修复这些问题了，毕竟它们大都是些细枝末节。作为一名用C#的纯种码农，我突然一时兴起也要把这些设计缺陷记录下，也方便和大伙一起讨论下。那么这次就先从实现接口内的事件说起，当我们需要显式实现一个接口内的事件时，会发现我们必须提供add和remove访问器，这还会稍许影响到事件常用的使用模式。&lt;/p&gt;

&lt;h1&gt;强制add和remove访问器&lt;/h1&gt;

&lt;p&gt;这个问题听上去有些绕，不过看代码便一清二楚。例如，在项目中我会定义一个这样的INotifyPropertyChanged接口，其中包含一个PropertyChanged事件：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;TPropertyIdentity&amp;gt;
{
    &lt;span style="color: blue"&gt;event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;TPropertyIdentity&amp;gt;&amp;gt; PropertyChanged;
}

&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;TPropertyIdentity&amp;gt; : &lt;span style="color: #2b91af"&gt;EventArgs
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;PropertyChangedEventArgs(TPropertyIdentity propertyIdentity)
    {
        &lt;span style="color: blue"&gt;this&lt;/span&gt;.PropertyIdentity = propertyIdentity;
    }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;TPropertyIdentity PropertyIdentity { &lt;span style="color: blue"&gt;get&lt;/span&gt;; &lt;span style="color: blue"&gt;private set&lt;/span&gt;; }
}&lt;/pre&gt;

&lt;p&gt;可以看出这个接口和.NET内置的INotifyPropertyChanged事件可谓如出一辙，其实他们的目的也一样，就是向外通知该对象的某个属性发生了改变。不同的是，系统内置的PropertyChangedEventArgs对象使用属性名，也就是一个字符串标识一个属性，而在如上带泛型的PropertyChangedEventArgs里，则可以使用任意类型的对象来标识属性，这无疑带来的更多的灵活性。例如，我们可以使用连续的整型数值来标识对象，这样我们就可以使用数组来创建一个索引，它的性能会比使用字符串为键值的字典要高出一些。&lt;/p&gt;

&lt;p&gt;不过，我们实现系统自带的INotifyPropertyChanged属性时，并非是要“自行使用”，而往往是想让通知其他组件，例如ORM框架或是UI控件。因此，它其实已经是.NET平台上的统一约定，即便有所不足，也不能舍弃它。因此，我们往往需要在一个对象上同时实现两种INotifyPropertyChanged接口，例如：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Item &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;, &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;
{
    &lt;span style="color: blue"&gt;public event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: blue"&gt;int&lt;/span&gt;&amp;gt;&amp;gt; PropertyChanged;

    &lt;span style="color: blue"&gt;event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventHandler INotifyPropertyChanged&lt;/span&gt;.PropertyChanged
    {
        &lt;span style="color: blue"&gt;add &lt;/span&gt;{ &lt;span style="color: blue"&gt;throw new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;NotImplementedException&lt;/span&gt;(); }
        &lt;span style="color: blue"&gt;remove &lt;/span&gt;{ &lt;span style="color: blue"&gt;throw new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;NotImplementedException&lt;/span&gt;(); }
    }
}&lt;/pre&gt;

&lt;p&gt;以上是Visual Studio为两个事件实现自动生成的代码框架，且看第二个事件，它要求我们提供add和remove访问器。为什么？我不知道，&lt;a href="http://stackoverflow.com/questions/2268065/c-sharp-language-design-explicit-interface-implementation-of-an-event#2268472"&gt;C#开发团队自己可能也已经不太清楚这么规定的原因&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Interesting question. I did some poking around the language notes archive and I discovered that this decision was made on the 13th of October, 1999, but the notes do not give a justification for the decision.&lt;/p&gt;

  &lt;p&gt;Off the top of my head I don't see any theoretical or practical reason why we could not have field-like explicitly implemented events. Nor do I see any reason why we particularly need to. This may have to remain one of the mysteries of the unknown.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/users/88656/eric-lippert"&gt;Eric Lippert&lt;/a&gt;是老牌C#团队成员了，经常在Stack Overflow或是博客上写一些C#的设计内幕，可惜在这个问题上连他也认为是个“不解之谜”。此外，“自动属性”让这个限制进一步显得“无厘头”了，因为我们完全可以这么显式实现接口里的属性：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af"&gt;INameProvider
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;string &lt;/span&gt;Name { &lt;span style="color: blue"&gt;get&lt;/span&gt;; &lt;span style="color: blue"&gt;set&lt;/span&gt;; }
}

&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyNameProvider &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;INameProvider
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;string &lt;/span&gt;&lt;span style="color: #2b91af"&gt;INameProvider&lt;/span&gt;.Name { &lt;span style="color: blue"&gt;get&lt;/span&gt;; &lt;span style="color: blue"&gt;set&lt;/span&gt;; }
}&lt;/pre&gt;

&lt;p&gt;既然如此，事件跟它又有什么本质区别呢？&lt;/p&gt;

&lt;h1&gt;相关问题&lt;/h1&gt;

&lt;p&gt;顺便一提，我们知道，在C#里不能把显式实现的接口成员标注为抽象成员，这对于事件来说还存在一些额外的问题。且看以下代码片段：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public abstract class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Base &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;
{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;&amp;gt; PropertyChanged;

    &lt;span style="color: blue"&gt;protected void &lt;/span&gt;OnPropertyChanged(&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt; args)
    {
        &lt;span style="color: blue"&gt;var &lt;/span&gt;propertyChanged = &lt;span style="color: blue"&gt;this&lt;/span&gt;.PropertyChanged;
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(propertyChanged != &lt;span style="color: blue"&gt;null&lt;/span&gt;)
        {
            propertyChanged(&lt;span style="color: blue"&gt;this&lt;/span&gt;, args);
        }
    }
}&lt;/pre&gt;

&lt;p&gt;Base是个基类，因此它往往会暴露个OnXyz方法，以便子类触发Xyz事件。在OnPropertyChanged方法中，我们会先判断_propertyChanged是否为null，因为null表示还没有人注册过事件——这是事件使用时的常见模式。事件本身没有注册任何处理器，则意味着事件本身不触发亦可，同样意味着我们甚至可以不去创建事件所需的EventArgs参数。但是，如果我们是要在子类里触发事件（即调用OnXxx方法），则没有办法检查该事件有没有注册处理器。假如这个EventArgs对象创建起来成本较高，就会造成一定的性能损失。&lt;/p&gt;

&lt;p&gt;解决方法倒也简单，例如，在基类里增加一个事件：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public abstract class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Base &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;
{
    &lt;span style="color: blue"&gt;public abstract event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;&amp;gt; MyIdentityPropertyChanged;

    &lt;span style="color: blue"&gt;event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;&amp;gt; &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;.PropertyChanged
    {
        &lt;span style="color: blue"&gt;add &lt;/span&gt;{ &lt;span style="color: blue"&gt;this&lt;/span&gt;.MyIdentityPropertyChanged += &lt;span style="color: blue"&gt;value&lt;/span&gt;; }
        &lt;span style="color: blue"&gt;remove &lt;/span&gt;{ &lt;span style="color: blue"&gt;this&lt;/span&gt;.MyIdentityPropertyChanged -= &lt;span style="color: blue"&gt;value&lt;/span&gt;; }
    }
}&lt;/pre&gt;

&lt;p&gt;或干脆加一个“延迟”构造EventArgs的重载：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public abstract class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;Base &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;
{
    &lt;span style="color: blue"&gt;private &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;&amp;gt; _propertyChanged;

    &lt;span style="color: blue"&gt;event &lt;/span&gt;&lt;span style="color: #2b91af"&gt;EventHandler&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;&amp;gt; &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;.PropertyChanged
    {
        &lt;span style="color: blue"&gt;add &lt;/span&gt;{ &lt;span style="color: blue"&gt;this&lt;/span&gt;._propertyChanged += &lt;span style="color: blue"&gt;value&lt;/span&gt;; }
        &lt;span style="color: blue"&gt;remove &lt;/span&gt;{ &lt;span style="color: blue"&gt;this&lt;/span&gt;._propertyChanged -= &lt;span style="color: blue"&gt;value&lt;/span&gt;; }
    }

    &lt;span style="color: blue"&gt;protected void &lt;/span&gt;OnPropertyChanged(&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt; args) { ... }

    &lt;span style="color: blue"&gt;protected void &lt;/span&gt;OnPropertyChanged(&lt;span style="color: #2b91af"&gt;Func&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;&amp;gt; argsFactory) { ... }
}&lt;/pre&gt;

&lt;p&gt;于是在基类里触发事件时即可：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;this&lt;/span&gt;.OnPropertyChanged(() =&amp;gt; &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;PropertyChangedEventArgs&lt;/span&gt;&amp;lt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;&amp;gt;(&lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;MyIdentity&lt;/span&gt;()));&lt;/pre&gt;

&lt;p&gt;如果您觉得在没有事件处理器的情况下创建一个委托对象也是一种浪费，那么就自己想办法解决咯。没什么困难的，不应该想不出。&lt;/p&gt;

&lt;h1&gt;更新&lt;/h1&gt;

&lt;p&gt;文章写完后很快就有同学回复，说其实&lt;a href="http://stackoverflow.com/questions/2268065/c-sharp-language-design-explicit-interface-implementation-of-an-event#9178955"&gt;Eric Lippert下方那位同学的回答&lt;/a&gt;更靠谱。我看了看又想了想，的确如此。&lt;/p&gt;

&lt;p&gt;事件是个很特别的成员，平时在使用事件的时候，只能将其放在+=或-=的左边，表示为事件添加或移除处理器——除非是在定义事件的类型内部，我们可以将其“赋值”给其他变量，或是当作参数传递，这时候其实操作的就是一个委托对象了。但如果我们是显式声明一个接口内的事件，我们其实是先要将this转化为具体的接口类型才去使用的：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;var &lt;/span&gt;propertyChanged = ((&lt;span style="color: #2b91af"&gt;INotifyPropertyChanged&lt;/span&gt;)&lt;span style="color: blue"&gt;this&lt;/span&gt;).PropertyChanged;&lt;/pre&gt;

&lt;p&gt;但我们把this转化为具体类型之后，我们实际上是在从“外部”访问接口上定义的成员。换句话说，在这种情况下我们并不处于定义事件的对象内部，我们无法获得这个所谓的“委托”对象，因为此时可能根本不存在这么一个委托对象，我们只知道事件的add和remove访问器。那么，我们又如何让其自动实现呢？此时强制提供add和remove访问器就是顺理成章的事情了。&lt;/p&gt;

&lt;p&gt;总体而言，我这系列的第一枪打得有点歪，开了个坏头。当然从好处想，也是通过交流让我，还有潜在不明真相的同学了解到一些细节。还有再次确认了不能迷信权威，这次Eric Lippert的回答的确不够有说服力，但他还是得到了最多的支持，名气这东西的确挺令人嘘唏的。话说我刚才去StackOverflow上对他的回答投了反对票，可能是已经被采纳为正确答案了吧，我反而还被扣了一份，哈哈。&lt;/p&gt;

&lt;h1&gt;相关文章&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;C#的设计缺陷（1）：显式实现接口内的事件&lt;/li&gt;
&lt;/ul&gt;</description>
      <comments>http://blog.zhaojie.me/2012/05/csharp-design-flaws-1-explicitly-implement-interface-event.html#comments</comments>
      <pubDate>Sun, 20 May 2012 21:07:12 GMT</pubDate>
      <lastBuildDate>Mon, 28 May 2012 12:27:46 GMT</lastBuildDate>
    </item>
    <item>
      <author>jeffz@live.com (老赵)</author>
      <category domain="http://blog.zhaojie.me/dotnet/">.Net框架</category>
      <category domain="http://blog.zhaojie.me/practice/">实践优化</category>
      <title>编写一个“绑定友好”的WPF控件</title>
      <link>http://blog.zhaojie.me/2012/05/wpf-binding-friendly-user-control.html</link>
      <guid>http://blog.zhaojie.me/2012/05/wpf-binding-friendly-user-control.html</guid>
      <description>&lt;p&gt;最近在搞WPF开发，这对我来说是个陌生的领域。话说回来，可能是缺少耐心的缘故，我现在学习新事物的方式主要是“看一些入门文档”，“看一些示例”，然后“猜测”其实现并摸索着使用。在很多时候这种做法问题不大，但一旦有地方猜错了，但在一段时间里似乎和实践还挺吻合的，则一旦遇到问题就会卡死。上周五我就被一个WPF绑定的问题搞得焦头烂额，虽说基本搞定，但还是想验证下是否会有更好的做法，特此记录一下，欢迎大家指正。&lt;/p&gt;

&lt;h1&gt;目标与障碍&lt;/h1&gt;

&lt;p&gt;简单地说，我想做的事情是编写一个“绑定友好”的用户控件，它可以像Telerik的RadNumericUpDown控件那样使用：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;telerik&lt;/span&gt;&lt;span style="color: blue"&gt;:&lt;/span&gt;&lt;span style="color: #a31515"&gt;RadNumericUpDown &lt;/span&gt;&lt;span style="color: red"&gt;Value&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;Path&lt;/span&gt;&lt;span style="color: blue"&gt;=NumberValue}&amp;quot; /&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过控件属性的形式直接绑定一个值上去，看上去应该是最基本的要求吧？那么我们就来实现一个类似的控件，他有两个属性，一个是Text字符串属性，另一个是Number整型属性，分别交由一个文本框和一个滑动条来控制。&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;UserControl&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;Grid&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
        &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;StackPanel&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
            &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;TextBox &lt;/span&gt;&lt;span style="color: red"&gt;Text&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;...&amp;quot; /&amp;gt;
            &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;Slider &lt;/span&gt;&lt;span style="color: red"&gt;Minimum&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;0&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Maximum&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;100&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Value&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;...&amp;quot; /&amp;gt;
        &amp;lt;/&lt;/span&gt;&lt;span style="color: #a31515"&gt;StackPanel&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;  
    &amp;lt;/&lt;/span&gt;&lt;span style="color: #a31515"&gt;Grid&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;/&lt;/span&gt;&lt;span style="color: #a31515"&gt;UserControl&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;自然，MVVM是不可或缺的，因为在真实环境中一个用户控件的逻辑也会颇为复杂，我们需要对模型和界面进行分离。这个最简单的ViewModel定义如下（自然，实际情况下还需要实现INotifyPropertyChanged接口）：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ValueInputViewModel &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;INotifyPropertyChanged
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;public string &lt;/span&gt;Text { &lt;span style="color: blue"&gt;get&lt;/span&gt;; &lt;span style="color: blue"&gt;set&lt;/span&gt;; }

    &lt;span style="color: blue"&gt;public int &lt;/span&gt;Number { &lt;span style="color: blue"&gt;get&lt;/span&gt;; &lt;span style="color: blue"&gt;set&lt;/span&gt;; }
}&lt;/pre&gt;

&lt;p&gt;我之前都是使用DataContext作为ViewModel的容器，例如在BadValueInput.xaml.cs中：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public partial class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;BadValueInput &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;UserControl
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;BadValueInput()
    {
        InitializeComponent();

        &lt;span style="color: blue"&gt;this&lt;/span&gt;.DataContext = &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ValueInputViewModel&lt;/span&gt;();
    }

    ...
}&lt;/pre&gt;

&lt;p&gt;于是便可以在BadValueInput.xaml里绑定：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;TextBox &lt;/span&gt;&lt;span style="color: red"&gt;Text&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;Path&lt;/span&gt;&lt;span style="color: blue"&gt;=Text, &lt;/span&gt;&lt;span style="color: red"&gt;UpdateSourceTrigger&lt;/span&gt;&lt;span style="color: blue"&gt;=PropertyChanged}&amp;quot; /&amp;gt;
&amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;Slider &lt;/span&gt;&lt;span style="color: red"&gt;Minimum&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;0&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Maximum&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;100&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Value&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;Path&lt;/span&gt;&lt;span style="color: blue"&gt;=Number}&amp;quot; /&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;然后再定义两个依赖属性即可。接着我们在MainWindow.xaml里使用这个类，同样使用MVVM模式：创建MainWindowViewModel类型，包含MyText和MyNumber两个属性，实例化并赋值给MainWindow的DataContext，然后在XAML里绑定至BadValueInput的两个属性上：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;view&lt;/span&gt;&lt;span style="color: blue"&gt;:&lt;/span&gt;&lt;span style="color: #a31515"&gt;BadValueInput &lt;/span&gt;&lt;span style="color: red"&gt;Text&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;Path&lt;/span&gt;&lt;span style="color: blue"&gt;=MyText}&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Number&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;Path&lt;/span&gt;&lt;span style="color: blue"&gt;=MyNumber}&amp;quot; /&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;从我的设想中，这种做法没有任何问题：父控件（MainWindow）和子控件（BadValueInput）都有自身的DataContext，互不影响。父控件将自己的MyText和MyNumber分别绑定至子控件的Text和Number属性上，也符合直觉，但执行后的结果却并非如此：&lt;/p&gt;

&lt;pre class="code"&gt;System.Windows.Data Error: 40 : BindingExpression path error: 'MyText' property not found on 'object' ''ValueInputViewModel' (HashCode=6943688)'. BindingExpression:Path=MyText; DataItem='ValueInputViewModel' (HashCode=6943688); target element is 'BadValueInput' (Name=''); target property is 'Text' (type 'String')
System.Windows.Data Error: 40 : BindingExpression path error: 'MyNumber' property not found on 'object' ''ValueInputViewModel' (HashCode=6943688)'. BindingExpression:Path=MyNumber; DataItem='ValueInputViewModel' (HashCode=6943688); target element is 'BadValueInput' (Name=''); target property is 'Number' (type 'Int32')&lt;/pre&gt;

&lt;p&gt;在Output窗口中出现了这样两条错误信息，意思是ValueInputViewModel上没有MyText和MyNumber两个属性。于是我就搞不懂了，为什么定义在MainWindow里的绑定使用的会是BadValueInput的DataContext，而不是当前上下文，即MainWindow的DataContext？我始终觉得这是种违反直觉的逻辑。&lt;/p&gt;

&lt;h1&gt;不使用DataContext作为ViewModel容器&lt;/h1&gt;

&lt;p&gt;我在微薄上提出这个问题之后收到了不少回应，很多朋友说是使用&lt;code&gt;RelativeSource就可以解决问题，也就是让子控件可以找到父控件的DataContext，甚至说直接在子控件里直接指定父控件ViewModel路径。对于这个做法我不敢苟同，在我看来子控件应该是可以独立地自由使用的一个组件，它不应该根据父控件去调整自己的实现。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;因此，即便这样的做法可以解决这一场景下的问题，但在我看来这完全属于在“凑”结果。&lt;/code&gt;&lt;code&gt;我需要的是尽可能完善的解决方案，就像RadNumericUpDown那样干净清爽。我认为程序员还是需要一点完美主义，而不是仅仅为了解决问题而运用Workaround。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;其实解决方案也很简单，&lt;a href="http://weibo.com/waynebabywang"&gt;@韦恩卑鄙&lt;/a&gt;告诉我，假如要避免出现这种情况，应该避免使用DataContext作为ViewModel容器，严格来说这是一种轻度滥用。其实只要遵循这个原则，这个问题也很容易解决。例如，在ValueInput.xaml.cs里定义个ViewModel属性：&lt;/code&gt;&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public partial class &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ValueInput &lt;/span&gt;: &lt;span style="color: #2b91af"&gt;UserControl
&lt;/span&gt;{
    &lt;span style="color: blue"&gt;public &lt;/span&gt;ValueInput()
        : &lt;span style="color: blue"&gt;this&lt;/span&gt;(&lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ValueInputViewModel&lt;/span&gt;())
    { }

    &lt;span style="color: blue"&gt;public &lt;/span&gt;ValueInput(&lt;span style="color: #2b91af"&gt;ValueInputViewModel &lt;/span&gt;viewModel)
    {
        InitializeComponent();

        &lt;span style="color: blue"&gt;this&lt;/span&gt;.ViewModel = viewModel;
    }

    &lt;span style="color: blue"&gt;public static readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DependencyProperty &lt;/span&gt;ViewModelProperty =
        &lt;span style="color: #2b91af"&gt;DependencyProperty&lt;/span&gt;.Register(&lt;span style="color: #a31515"&gt;&amp;quot;ViewModel&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;ValueInputViewModel&lt;/span&gt;), &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;ValueInput&lt;/span&gt;));

    &lt;span style="color: blue"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af"&gt;ValueInputViewModel &lt;/span&gt;ViewModel
    {
        &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: #2b91af"&gt;ValueInputViewModel&lt;/span&gt;)GetValue(ViewModelProperty); }
        &lt;span style="color: blue"&gt;set &lt;/span&gt;{ SetValue(ViewModelProperty, &lt;span style="color: blue"&gt;value&lt;/span&gt;); }
    }
}&lt;/pre&gt;

&lt;p&gt;然后在ValueInput.xaml里绑定时指定特定的成员：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;UserControl &lt;/span&gt;&lt;span style="color: red"&gt;x&lt;/span&gt;&lt;span style="color: blue"&gt;:&lt;/span&gt;&lt;span style="color: red"&gt;Class&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;WpfUserControl.Views.ValueInput&amp;quot;
             &lt;/span&gt;&lt;span style="color: red"&gt;x&lt;/span&gt;&lt;span style="color: blue"&gt;:&lt;/span&gt;&lt;span style="color: red"&gt;Name&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;Self&amp;quot;&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;Grid&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
        &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;StackPanel&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
            &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;TextBox &lt;/span&gt;&lt;span style="color: red"&gt;Text&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;ViewModel&lt;/span&gt;&lt;span style="color: blue"&gt;.Text, &lt;/span&gt;&lt;span style="color: red"&gt;ElementName&lt;/span&gt;&lt;span style="color: blue"&gt;=Self, &lt;/span&gt;&lt;span style="color: red"&gt;UpdateSourceTrigger&lt;/span&gt;&lt;span style="color: blue"&gt;=PropertyChanged}&amp;quot; /&amp;gt;
            &amp;lt;&lt;/span&gt;&lt;span style="color: #a31515"&gt;Slider &lt;/span&gt;&lt;span style="color: red"&gt;Minimum&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;0&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Maximum&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;100&amp;quot; &lt;/span&gt;&lt;span style="color: red"&gt;Value&lt;/span&gt;&lt;span style="color: blue"&gt;=&amp;quot;{&lt;/span&gt;&lt;span style="color: #a31515"&gt;Binding &lt;/span&gt;&lt;span style="color: red"&gt;ViewModel&lt;/span&gt;&lt;span style="color: blue"&gt;.Number, &lt;/span&gt;&lt;span style="color: red"&gt;ElementName&lt;/span&gt;&lt;span style="color: blue"&gt;=Self}&amp;quot; /&amp;gt;
        &amp;lt;/&lt;/span&gt;&lt;span style="color: #a31515"&gt;StackPanel&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
    &amp;lt;/&lt;/span&gt;&lt;span style="color: #a31515"&gt;Grid&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;
&amp;lt;/&lt;/span&gt;&lt;span style="color: #a31515"&gt;UserControl&lt;/span&gt;&lt;span style="color: blue"&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;如今的绑定不光指定Path，还会使用ElementName将Source定义成当前控件对象。不过接下来的问题是，如何将控件的Text和Number属性，与ViewModel中的属性关联起来呢？目前我只知道使用代码来实现这种同步，这需要我们在ValueInput.xaml里添加更多代码：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public &lt;/span&gt;ValueInput(&lt;span style="color: #2b91af"&gt;ValueInputViewModel &lt;/span&gt;viewModel)
{
    InitializeComponent();

    viewModel.PropertyChanged += (_, args) =&amp;gt;
    {
        &lt;span style="color: blue"&gt;if &lt;/span&gt;(args.PropertyName == &lt;span style="color: #a31515"&gt;&amp;quot;Text&amp;quot;&lt;/span&gt;)
        {
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(!&lt;span style="color: #2b91af"&gt;String&lt;/span&gt;.Equals(viewModel.Text, &lt;span style="color: blue"&gt;this&lt;/span&gt;.Text))
            {
                &lt;span style="color: blue"&gt;this&lt;/span&gt;.Text = viewModel.Text;
            }
        }
        &lt;span style="color: blue"&gt;else if &lt;/span&gt;(args.PropertyName == &lt;span style="color: #a31515"&gt;&amp;quot;Number&amp;quot;&lt;/span&gt;)
        {
            &lt;span style="color: blue"&gt;if &lt;/span&gt;(!viewModel.Number.Equals(&lt;span style="color: blue"&gt;this&lt;/span&gt;.Number))
            {
                &lt;span style="color: blue"&gt;this&lt;/span&gt;.Number = viewModel.Number;
            }
        }
    };

    &lt;span style="color: blue"&gt;this&lt;/span&gt;.ViewModel = viewModel;
}

&lt;span style="color: blue"&gt;public static readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DependencyProperty &lt;/span&gt;TextProperty =
    &lt;span style="color: #2b91af"&gt;DependencyProperty&lt;/span&gt;.Register(
        &lt;span style="color: #a31515"&gt;&amp;quot;Text&amp;quot;&lt;/span&gt;,
        &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: blue"&gt;string&lt;/span&gt;),
        &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;ValueInput&lt;/span&gt;),
        &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;FrameworkPropertyMetadata&lt;/span&gt;(OnTextPropertyChanged) { BindsTwoWayByDefault = &lt;span style="color: blue"&gt;true &lt;/span&gt;});

&lt;span style="color: blue"&gt;private static void &lt;/span&gt;OnTextPropertyChanged(&lt;span style="color: #2b91af"&gt;DependencyObject &lt;/span&gt;o, &lt;span style="color: #2b91af"&gt;DependencyPropertyChangedEventArgs &lt;/span&gt;args)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;valueInput = (&lt;span style="color: #2b91af"&gt;ValueInput&lt;/span&gt;)o;
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(!&lt;span style="color: #2b91af"&gt;String&lt;/span&gt;.Equals(valueInput.ViewModel.Text, valueInput.Text))
    {
        valueInput.ViewModel.Text = valueInput.Text;
    }
}

&lt;span style="color: blue"&gt;public string &lt;/span&gt;Text
{
    &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: blue"&gt;string&lt;/span&gt;)GetValue(TextProperty); }
    &lt;span style="color: blue"&gt;set &lt;/span&gt;{ SetValue(TextProperty, &lt;span style="color: blue"&gt;value&lt;/span&gt;); }
}

&lt;span style="color: blue"&gt;public static readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DependencyProperty &lt;/span&gt;NumberProperty =
    &lt;span style="color: #2b91af"&gt;DependencyProperty&lt;/span&gt;.Register(
        &lt;span style="color: #a31515"&gt;&amp;quot;Number&amp;quot;&lt;/span&gt;,
        &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: blue"&gt;int&lt;/span&gt;),
        &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;ValueInput&lt;/span&gt;),
        &lt;span style="color: blue"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af"&gt;FrameworkPropertyMetadata&lt;/span&gt;(OnNumberPropertyChanged) { BindsTwoWayByDefault = &lt;span style="color: blue"&gt;true &lt;/span&gt;});

&lt;span style="color: blue"&gt;private static void &lt;/span&gt;OnNumberPropertyChanged(&lt;span style="color: #2b91af"&gt;DependencyObject &lt;/span&gt;o, &lt;span style="color: #2b91af"&gt;DependencyPropertyChangedEventArgs &lt;/span&gt;args)
{
    &lt;span style="color: blue"&gt;var &lt;/span&gt;valueInput = (&lt;span style="color: #2b91af"&gt;ValueInput&lt;/span&gt;)o;
    &lt;span style="color: blue"&gt;if &lt;/span&gt;(!valueInput.ViewModel.Number.Equals(valueInput.Number))
    {
        valueInput.ViewModel.Number = valueInput.Number;
    }
}

&lt;span style="color: blue"&gt;public int &lt;/span&gt;Number
{
    &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: blue"&gt;int&lt;/span&gt;)GetValue(NumberProperty); }
    &lt;span style="color: blue"&gt;set &lt;/span&gt;{ SetValue(NumberProperty, &lt;span style="color: blue"&gt;value&lt;/span&gt;); }
}&lt;/pre&gt;

&lt;p&gt;为了将控件上属性的改变同步至ViewModel，我们在定义依赖属性的时候提供propertyChangedCallback参数。同理，为了将ViewModel上属性的改变同步至控件，我们会监听ViewModel对象的PropertyChanged事件，这样的做法虽然麻烦，但的确管用。&lt;/p&gt;

&lt;p&gt;如果我们要在MainWindow里使用这个控件，我们可以继续使用DataContext，此时子控件的DataContext属性会获取到父控件的DataContext对象，这自然不会出现取不到属性的问题。当然，如果父控件本身也希望成为一个独立控件的话，也可以使用同样的做法，即创建自身的ViewModel属性并使用ElementName指定Source，继续避免对DataContext产生依赖。&lt;/p&gt;

&lt;h1&gt;示例代码与疑问&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://github.com/JeffreyZhao/samples/tree/master/WpfUserControl"&gt;本文的示例代码已存放至GitHub&lt;/a&gt;。我周五遇到的这个问题算是这么解决了，但其实我还是有一些疑问，例如：有没有更简单的做法？ValueInput.xaml.cs里用于同步控件属性与ViewModel属性的代码实在太多，也很容易写错。此外，能否在控件上定义一个只读的属性？例如代码中我额外添加的ReadOnlyValue依赖属性：&lt;/p&gt;

&lt;pre class="code"&gt;&lt;span style="color: blue"&gt;public static readonly &lt;/span&gt;&lt;span style="color: #2b91af"&gt;DependencyProperty &lt;/span&gt;ReadOnlyValueProperty =
    &lt;span style="color: #2b91af"&gt;DependencyProperty&lt;/span&gt;.Register(&lt;span style="color: #a31515"&gt;&amp;quot;ReadOnlyValue&amp;quot;&lt;/span&gt;, &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: blue"&gt;int&lt;/span&gt;), &lt;span style="color: blue"&gt;typeof&lt;/span&gt;(&lt;span style="color: #2b91af"&gt;ValueInput&lt;/span&gt;));

&lt;span style="color: blue"&gt;public int &lt;/span&gt;ReadOnlyValue
{
    &lt;span style="color: blue"&gt;get &lt;/span&gt;{ &lt;span style="color: blue"&gt;return &lt;/span&gt;(&lt;span style="color: blue"&gt;int&lt;/span&gt;)GetValue(ReadOnlyValueProperty); }
    &lt;span style="color: blue"&gt;private set &lt;/span&gt;{ SetValue(ReadOnlyValueProperty, &lt;span style="color: blue"&gt;value&lt;/span&gt;); }
}&lt;/pre&gt;

&lt;p&gt;但是一旦缺少公开的setter，在XAML里就无法绑定这个属性了，即便我把绑定的Mode设为OneWayToSource。初学WPF，疑问很多，希望大家多多帮助。&lt;/p&gt;</description>
      <comments>http://blog.zhaojie.me/2012/05/wpf-binding-friendly-user-control.html#comments</comments>
      <pubDate>Sun, 13 May 2012 23:35:25 GMT</pubDate>
      <lastBuildDate>Sun, 13 May 2012 23:35:25 GMT</lastBuildDate>
    </item>
  </channel>
</rss>